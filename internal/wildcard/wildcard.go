//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package wildcard ;func Index (pattern ,name string )(_ffc int ){if pattern ==""||pattern =="\u002a"{return 0;};_bb :=make ([]rune ,0,len (name ));_ag :=make ([]rune ,0,len (pattern ));for _ ,_cb :=range name {_bb =append (_bb ,_cb );};for _ ,_acf :=range pattern {_ag =append (_ag ,_acf );
};return _gc (_bb ,_ag ,0);};func Match (pattern ,name string )(_f bool ){if pattern ==""{return name ==pattern ;};if pattern =="\u002a"{return true ;};_da :=make ([]rune ,0,len (name ));_ce :=make ([]rune ,0,len (pattern ));for _ ,_b :=range name {_da =append (_da ,_b );
};for _ ,_cc :=range pattern {_ce =append (_ce ,_cc );};_afb :=false ;return _be (_da ,_ce ,_afb );};func _gc (_ddd ,_bc []rune ,_bcg int )int {for len (_bc )> 0{switch _bc [0]{default:if len (_ddd )==0{return -1;};if _ddd [0]!=_bc [0]{return _gc (_ddd [1:],_bc ,_bcg +1);
};case '?':if len (_ddd )==0{return -1;};case '*':if len (_ddd )==0{return -1;};_dg :=_gc (_ddd ,_bc [1:],_bcg );if _dg !=-1{return _bcg ;}else {_dg =_gc (_ddd [1:],_bc ,_bcg );if _dg !=-1{return _bcg ;}else {return -1;};};};_ddd =_ddd [1:];_bc =_bc [1:];
};return _bcg ;};func _be (_afd ,_ga []rune ,_fa bool )bool {for len (_ga )> 0{switch _ga [0]{default:if len (_afd )==0||_afd [0]!=_ga [0]{return false ;};case '?':if len (_afd )==0&&!_fa {return false ;};case '*':return _be (_afd ,_ga [1:],_fa )||(len (_afd )> 0&&_be (_afd [1:],_ga ,_fa ));
};_afd =_afd [1:];_ga =_ga [1:];};return len (_afd )==0&&len (_ga )==0;};func MatchSimple (pattern ,name string )bool {if pattern ==""{return name ==pattern ;};if pattern =="\u002a"{return true ;};_e :=make ([]rune ,0,len (name ));_a :=make ([]rune ,0,len (pattern ));
for _ ,_ed :=range name {_e =append (_e ,_ed );};for _ ,_dd :=range pattern {_a =append (_a ,_dd );};_g :=true ;return _be (_e ,_a ,_g );};