//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_fe "bytes";_b "fmt";_ge "github.com/unidoc/unioffice/v2/common/logger";_ee "io";_d "math";_f "strconv";_c "strings";_g "time";);func _db (_eg []byte )[]byte {for _ab :=0;_ab < len (_eg )/2;_ab ++{_bdb :=len (_eg )-1-_ab ;_eg [_ab ],_eg [_bdb ]=_eg [_bdb ],_eg [_ab ];
};return _eg ;};const _dc =1e-10;

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};const _bcg int =-1;

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_bb bool ;_bd bool ;_feb bool ;_cb bool ;_a bool ;_ec bool ;_ef int64 ;_cg int ;};const _gea int =-1;

// AddToken adds a format token to the format.
func (_fd *Format )AddToken (t FmtType ,l []byte ){if _fd ._a {_fd ._a =false ;return ;};switch t {case FmtTypeDecimal :_fd ._ec =true ;case FmtTypeUnderscore :_fd ._a =true ;case FmtTypeText :_fd .Whole =append (_fd .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_fd .Whole =append (_fd .Whole ,Token {Type :t ,DateTime :string (l )});
case FmtTypePercent :_fd ._bd =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_ad :=range l {if _fd .IsExponential {_fd .Exponent =append (_fd .Exponent ,Token {Type :t ,Literal :_ad });
}else if !_fd ._ec {_fd .Whole =append (_fd .Whole ,Token {Type :t ,Literal :_ad });}else {_fd .Fractional =append (_fd .Fractional ,Token {Type :t ,Literal :_ad });};};case FmtTypeDigitOptThousands :_fd ._cb =true ;case FmtTypeFraction :_ba :=_c .Split (string (l ),"\u002f");
if len (_ba )==2{_fd ._bb =true ;_fd ._ef ,_ =_f .ParseInt (_ba [1],10,64);for _ ,_ca :=range _ba [1]{if _ca =='?'||_ca =='0'{_fd ._cg ++;};};};default:_ge .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );
};};const _eda int =0;func _bfd (_ce int64 )int64 {if _ce < 0{return -_ce ;};return _ce ;};type Lexer struct{_bdaf Format ;_eag []Format ;};func _cdd (_eff ,_afd float64 ,_agd Format )[]byte {if len (_agd .Fractional )==0{return nil ;};_ffcg :=_f .AppendFloat (nil ,_eff ,'f',-1,64);
if len (_ffcg )> 2{_ffcg =_ffcg [2:];}else {_ffcg =nil ;};_egg :=make ([]byte ,0,len (_ffcg ));_egg =append (_egg ,'.');_adbg :=0;_fa :for _abf :=0;_abf < len (_agd .Fractional );_abf ++{_egf :=_abf ;_bgf :=_agd .Fractional [_abf ];switch _bgf .Type {case FmtTypeDigit :if _egf < len (_ffcg ){_egg =append (_egg ,_ffcg [_egf ]);
_adbg ++;}else {_egg =append (_egg ,'0');};case FmtTypeDigitOpt :if _egf >=0{_egg =append (_egg ,_ffcg [_egf ]);_adbg ++;}else {break _fa ;};case FmtTypeLiteral :_egg =append (_egg ,_bgf .Literal );default:_ge .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_bgf );
};};return _egg ;};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _d .Abs (v )>=_dd ||_d .Abs (v )<=_dc &&v !=0{return _acc (v );};_da :=make ([]byte ,0,15);_da =_f .AppendFloat (_da ,v ,'f',-1,64);if len (_da )> 11{_gdd :=_da [11]-'0';if _gdd >=5&&_gdd <=9{_da [10]++;_da =_da [0:11];
_da =_baeg (_da );};_da =_da [0:11];}else if len (_da )==11{if _da [len (_da )-1]=='9'{_da [len (_da )-1]++;_da =_baeg (_da );};};_da =_cff (_da );return string (_da );};const _dd =1e11;func _baeg (_baa []byte )[]byte {for _ede :=len (_baa )-1;_ede > 0;
_ede --{if _baa [_ede ]=='9'+1{_baa [_ede ]='0';if _baa [_ede -1]=='.'{_ede --;};_baa [_ede -1]++;};};if _baa [0]=='9'+1{_baa [0]='0';copy (_baa [1:],_baa [0:]);_baa [0]='1';};return _baa ;};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;
FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);func _acc (_ga float64 )string {_beg :=_f .FormatFloat (_ga ,'E',-1,64);_acg :=_f .FormatFloat (_ga ,'E',5,64);
if len (_beg )< len (_acg ){return _f .FormatFloat (_ga ,'E',2,64);};return _acg ;};func _bba (_gbd float64 ,_cf Format ,_gf bool )string {if _cf ._feb {return NumberGeneric (_gbd );};_abe :=make ([]byte ,0,20);_add :=_d .Signbit (_gbd );_dcf :=_d .Abs (_gbd );
_adb :=int64 (0);_cga :=int64 (0);if _cf .IsExponential {for _dcf >=10{_cga ++;_dcf /=10;};for _dcf < 1{_cga --;_dcf *=10;};}else if _cf ._bd {_dcf *=100;}else if _cf ._bb {if _cf ._ef ==0{_eed :=_d .Pow (10,float64 (_cf ._cg ));_ae ,_dcc :=1.0,1.0;_ =_ae ;
for _fee :=1.0;_fee < _eed ;_fee ++{_ ,_af :=_d .Modf (_dcf *float64 (_fee ));if _af < _dcc {_dcc =_af ;_ae =_fee ;if _af ==0{break ;};};};_cf ._ef =int64 (_ae );};_adb =int64 (_dcf *float64 (_cf ._ef )+0.5);if len (_cf .Whole )> 0&&_adb > _cf ._ef {_adb =int64 (_dcf *float64 (_cf ._ef ))%_cf ._ef ;
_dcf -=float64 (_adb )/float64 (_cf ._ef );}else {_dcf -=float64 (_adb )/float64 (_cf ._ef );if _d .Abs (_dcf )< 1{_cfb :=true ;for _ ,_ac :=range _cf .Whole {if _ac .Type ==FmtTypeDigitOpt {continue ;};if _ac .Type ==FmtTypeLiteral &&_ac .Literal ==' '{continue ;
};_cfb =false ;};if _cfb {_cf .Whole =nil ;};};};};_gg :=1;for _ ,_bf :=range _cf .Fractional {if _bf .Type ==FmtTypeDigit ||_bf .Type ==FmtTypeDigitOpt {_gg ++;};};_dcf +=5*_d .Pow10 (-_gg );_ed ,_ddg :=_d .Modf (_dcf );_abe =append (_abe ,_bc (_ed ,_gbd ,_cf )...);
_abe =append (_abe ,_cdd (_ddg ,_gbd ,_cf )...);_abe =append (_abe ,_eeb (_cga ,_cf )...);if _cf ._bb {_abe =_f .AppendInt (_abe ,_adb ,10);_abe =append (_abe ,'/');_abe =_f .AppendInt (_abe ,_cf ._ef ,10);};if !_gf &&_add {return "\u002d"+string (_abe );
};return string (_abe );};func _ece (_bac _g .Time ,_ffb string )[]byte {_aef :=[]byte {};_bgc :=0;for _afc :=0;_afc < len (_ffb );_afc ++{var _geg string ;if _ffb [_afc ]=='/'{_geg =string (_ffb [_bgc :_afc ]);_bgc =_afc +1;}else if _afc ==len (_ffb )-1{_geg =string (_ffb [_bgc :_afc +1]);
}else {continue ;};switch _geg {case "\u0079\u0079":_aef =_bac .AppendFormat (_aef ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_aef =_bac .AppendFormat (_aef ,"\u0032\u0030\u0030\u0036");case "\u006d":_aef =_bac .AppendFormat (_aef ,"\u0031");case "\u006d\u006d":_aef =_bac .AppendFormat (_aef ,"\u0030\u0031");
case "\u006d\u006d\u006d":_aef =_bac .AppendFormat (_aef ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_aef =_bac .AppendFormat (_aef ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _bac .Month (){case _g .January ,_g .July ,_g .June :_aef =append (_aef ,'J');
case _g .February :_aef =append (_aef ,'M');case _g .March ,_g .May :_aef =append (_aef ,'M');case _g .April ,_g .August :_aef =append (_aef ,'A');case _g .September :_aef =append (_aef ,'S');case _g .October :_aef =append (_aef ,'O');case _g .November :_aef =append (_aef ,'N');
case _g .December :_aef =append (_aef ,'D');};case "\u0064":_aef =_bac .AppendFormat (_aef ,"\u0032");case "\u0064\u0064":_aef =_bac .AppendFormat (_aef ,"\u0030\u0032");case "\u0064\u0064\u0064":_aef =_bac .AppendFormat (_aef ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_aef =_bac .AppendFormat (_aef ,"\u004d\u006f\u006e\u0064\u0061\u0079");
default:_ge .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_geg );};if _ffb [_afc ]=='/'{_aef =append (_aef ,'/');};};return _aef ;};const _afe int =34;


// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_ag :=Parse (f );if len (_ag )==1{return _bba (v ,_ag [0],false );}else if len (_ag )> 1&&v < 0{return _bba (v ,_ag [1],true );
}else if len (_ag )> 2&&v ==0{return _bba (v ,_ag [2],false );};return _bba (v ,_ag [0],false );};const _gc int =0;func IsNumber (data string )(_gbf bool ){_abc ,_egd ,_gce :=0,0,len (data );_agb :=len (data );_gga ,_gda ,_adg :=0,0,0;_ =_gda ;_ =_adg ;
_ =_gga ;{_abc =_gc ;_gga =0;_gda =0;_adg =0;};{if _egd ==_gce {goto _gfb ;};switch _abc {case 0:goto _bgg ;case 1:goto _cfg ;case 2:goto _ea ;case 3:goto _aa ;case 4:goto _edg ;case 5:goto _agae ;case 6:goto _daa ;case 7:goto _agac ;};goto _gac ;_eca :_gda =_egd ;
_egd --;{_gbf =false ;};goto _aefc ;_ege :_gda =_egd ;_egd --;{_gbf =_gda ==len (data );};goto _aefc ;_cgd :_gda =_egd ;_egd --;{_gbf =_gda ==len (data );};goto _aefc ;_dbc :switch _adg {case 2:{_egd =(_gda )-1;_gbf =_gda ==len (data );};case 3:{_egd =(_gda )-1;
_gbf =false ;};};goto _aefc ;_aefc :_gga =0;if _egd ++;_egd ==_gce {goto _aag ;};_bgg :_gga =_egd ;switch data [_egd ]{case 43:goto _bcf ;case 45:goto _bcf ;};if 48<=data [_egd ]&&data [_egd ]<=57{goto _effb ;};goto _fede ;_fede :if _egd ++;_egd ==_gce {goto _bga ;
};_cfg :goto _fede ;_bcf :if _egd ++;_egd ==_gce {goto _decc ;};_ea :if 48<=data [_egd ]&&data [_egd ]<=57{goto _effb ;};goto _fede ;_effb :if _egd ++;_egd ==_gce {goto _bce ;};_aa :if data [_egd ]==46{goto _dccga ;};if 48<=data [_egd ]&&data [_egd ]<=57{goto _effb ;
};goto _fede ;_dccga :if _egd ++;_egd ==_gce {goto _edf ;};_edg :if 48<=data [_egd ]&&data [_egd ]<=57{goto _cca ;};goto _fede ;_cca :if _egd ++;_egd ==_gce {goto _gde ;};_agae :if data [_egd ]==69{goto _cee ;};if 48<=data [_egd ]&&data [_egd ]<=57{goto _cca ;
};goto _fede ;_cee :if _egd ++;_egd ==_gce {goto _fcag ;};_daa :switch data [_egd ]{case 43:goto _bec ;case 45:goto _bec ;};goto _fede ;_bec :_gda =_egd +1;_adg =3;goto _ffg ;_cce :_gda =_egd +1;_adg =2;goto _ffg ;_ffg :if _egd ++;_egd ==_gce {goto _fce ;
};_agac :if 48<=data [_egd ]&&data [_egd ]<=57{goto _cce ;};goto _fede ;_gac :_aag :_abc =0;goto _gfb ;_bga :_abc =1;goto _gfb ;_decc :_abc =2;goto _gfb ;_bce :_abc =3;goto _gfb ;_edf :_abc =4;goto _gfb ;_gde :_abc =5;goto _gfb ;_fcag :_abc =6;goto _gfb ;
_fce :_abc =7;goto _gfb ;_gfb :{};if _egd ==_agb {switch _abc {case 1:goto _eca ;case 2:goto _eca ;case 3:goto _ege ;case 4:goto _eca ;case 5:goto _cgd ;case 6:goto _eca ;case 7:goto _dbc ;};};};if _abc ==_gea {return false ;};return ;};func _cff (_gff []byte )[]byte {_fcd :=len (_gff );
_bag :=false ;_bagc :=false ;for _gdb :=len (_gff )-1;_gdb >=0;_gdb --{if _gff [_gdb ]=='0'&&!_bagc &&!_bag {_fcd =_gdb ;}else if _gff [_gdb ]=='.'{_bag =true ;}else {_bagc =true ;};};if _bag &&_bagc {if _gff [_fcd -1]=='.'{_fcd --;};return _gff [0:_fcd ];
};return _gff ;};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_bbe :=Parse (f );var _bbef Format ;if len (_bbe )==1{_bbef =_bbe [0];}else if len (_bbe )==4{_bbef =_bbe [3];};_bge :=false ;for _ ,_dg :=range _bbef .Whole {if _dg .Type ==FmtTypeText {_bge =true ;};};if !_bge {return v ;
};_bgeg :=_fe .Buffer {};for _ ,_gee :=range _bbef .Whole {switch _gee .Type {case FmtTypeLiteral :_bgeg .WriteByte (_gee .Literal );case FmtTypeText :_bgeg .WriteString (v );};};return _bgeg .String ();};var _gb =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};
func (_gd FmtType )String ()string {if _gd >=FmtType (len (_gb )-1){return _b .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_gd );};return _fg [_gb [_gd ]:_gb [_gd +1]];};const _fg ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";
func _bc (_cd ,_edd float64 ,_dccg Format )[]byte {if len (_dccg .Whole )==0{return nil ;};_dee :=_g .Date (1899,12,30,0,0,0,0,_g .UTC );_caa :=_dee .Add (_g .Duration (_edd *float64 (24*_g .Hour )));_caa =_bcec (_caa );_fb :=_f .AppendFloat (nil ,_cd ,'f',-1,64);
_bda :=make ([]byte ,0,len (_fb ));_fc :=0;_fgb :=1;_ggfg :for _cgad :=len (_dccg .Whole )-1;_cgad >=0;_cgad --{_efc :=len (_fb )-1-_fc ;_dea :=_dccg .Whole [_cgad ];switch _dea .Type {case FmtTypeDigit :if _efc >=0{_bda =append (_bda ,_fb [_efc ]);_fc ++;
_fgb =_cgad ;}else {_bda =append (_bda ,'0');};case FmtTypeDigitOpt :if _efc >=0{_bda =append (_bda ,_fb [_efc ]);_fc ++;_fgb =_cgad ;}else {for _ggd :=_cgad ;_ggd >=0;_ggd --{_bae :=_dccg .Whole [_ggd ];if _bae .Type ==FmtTypeLiteral {_bda =append (_bda ,_bae .Literal );
};};break _ggfg ;};case FmtTypeDollar :for _feda :=_fc ;_feda < len (_fb );_feda ++{_bda =append (_bda ,_fb [len (_fb )-1-_feda ]);_fc ++;};_bda =append (_bda ,'$');case FmtTypeComma :if !_dccg ._cb {_bda =append (_bda ,',');};case FmtTypeLiteral :_bda =append (_bda ,_dea .Literal );
case FmtTypeDate :_bda =append (_bda ,_db (_ece (_caa ,_dea .DateTime ))...);case FmtTypeTime :_bda =append (_bda ,_db (_aga (_caa ,_edd ,_dea .DateTime ))...);default:_ge .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_dea );
};};_ffc :=_db (_bda );if _fc < len (_fb )&&(_fc !=0||_dccg ._ec ){_aeg :=len (_fb )-_fc ;_fca :=make ([]byte ,len (_ffc )+_aeg );copy (_fca ,_ffc [0:_fgb ]);copy (_fca [_fgb :],_fb [0:]);copy (_fca [_fgb +_aeg :],_ffc [_fgb :]);_ffc =_fca ;};if _dccg ._cb {_gbb :=_fe .Buffer {};
_fdd :=0;for _cba :=len (_ffc )-1;_cba >=0;_cba --{if !(_ffc [_cba ]>='0'&&_ffc [_cba ]<='9'){_fdd ++;}else {break ;};};for _abd :=0;_abd < len (_ffc );_abd ++{_cfa :=(len (_ffc )-_abd -_fdd );if _cfa %3==0&&_cfa !=0&&_abd !=0{_gbb .WriteByte (',');};_gbb .WriteByte (_ffc [_abd ]);
};_ffc =_gbb .Bytes ();};return _ffc ;};const _gacd int =34;func _bcec (_fdfe _g .Time )_g .Time {_fdfe =_fdfe .UTC ();return _g .Date (_fdfe .Year (),_fdfe .Month (),_fdfe .Day (),_fdfe .Hour (),_fdfe .Minute (),_fdfe .Second (),_fdfe .Nanosecond (),_g .Local );
};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_fgc ,_ :=_f .ParseFloat (v ,64);return Number (_fgc ,f );};return String (v ,f );};func _aga (_fga _g .Time ,_gbe float64 ,_gfe string )[]byte {_bagg :=[]byte {};_gege :=0;for _aba :=0;_aba < len (_gfe );
_aba ++{var _cda string ;if _gfe [_aba ]==':'{_cda =string (_gfe [_gege :_aba ]);_gege =_aba +1;}else if _aba ==len (_gfe )-1{_cda =string (_gfe [_gege :_aba +1]);}else {continue ;};switch _cda {case "\u0064":_bagg =_fga .AppendFormat (_bagg ,"\u0032");
case "\u0068":_bagg =_fga .AppendFormat (_bagg ,"\u0033");case "\u0068\u0068":_bagg =_fga .AppendFormat (_bagg ,"\u0031\u0035");case "\u006d":_bagg =_fga .AppendFormat (_bagg ,"\u0034");case "\u006d\u006d":_bagg =_fga .AppendFormat (_bagg ,"\u0030\u0034");
case "\u0073":_bagg =_fga .Round (_g .Second ).AppendFormat (_bagg ,"\u0035");case "\u0073\u002e\u0030":_bagg =_fga .Round (_g .Second /10).AppendFormat (_bagg ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_bagg =_fga .Round (_g .Second /100).AppendFormat (_bagg ,"\u0035\u002e\u0030\u0030");
case "\u0073\u002e\u00300\u0030":_bagg =_fga .Round (_g .Second /1000).AppendFormat (_bagg ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_bagg =_fga .Round (_g .Second ).AppendFormat (_bagg ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_bagg =_fga .Round (_g .Second /10).AppendFormat (_bagg ,"\u0030\u0035\u002e\u0030");
case "\u0073\u0073\u002e0\u0030":_bagg =_fga .Round (_g .Second /100).AppendFormat (_bagg ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_bagg =_fga .Round (_g .Second /1000).AppendFormat (_bagg ,"\u0030\u0035\u002e\u0030\u0030\u0030");
case "\u0041\u004d\u002fP\u004d":_bagg =_fga .AppendFormat (_bagg ,"\u0050\u004d");case "\u005b\u0068\u005d":_bagg =_f .AppendInt (_bagg ,int64 (_gbe *24),10);case "\u005b\u006d\u005d":_bagg =_f .AppendInt (_bagg ,int64 (_gbe *24*60),10);case "\u005b\u0073\u005d":_bagg =_f .AppendInt (_bagg ,int64 (_gbe *24*60*60),10);
case "":default:_ge .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_cda );};if _gfe [_aba ]==':'{_bagg =append (_bagg ,':');};};return _bagg ;
};func Parse (s string )[]Format {_ced :=Lexer {};_ced .Lex (_c .NewReader (s ));_ced ._eag =append (_ced ._eag ,_ced ._bdaf );return _ced ._eag ;};func (_efg *Lexer )Lex (r _ee .Reader ){_afdg ,_aec ,_gge :=0,0,0;_baea :=-1;_fffc ,_bcga ,_dafg :=0,0,0;
_ =_bcga ;_ =_dafg ;_dbce :=1;_ =_dbce ;_eggd :=make ([]byte ,4096);_efe :=false ;for !_efe {_bcee :=0;if _fffc > 0{_bcee =_aec -_fffc ;};_aec =0;_bgcc ,_dafd :=r .Read (_eggd [_bcee :]);if _bgcc ==0||_dafd !=nil {_efe =true ;};_gge =_bgcc +_bcee ;if _gge < len (_eggd ){_baea =_gge ;
};{_afdg =_daf ;_fffc =0;_bcga =0;_dafg =0;};{if _aec ==_gge {goto _fea ;};switch _afdg {case 34:goto _bcfg ;case 35:goto _dgd ;case 0:goto _dde ;case 36:goto _gcb ;case 37:goto _bcb ;case 1:goto _adc ;case 2:goto _fbc ;case 38:goto _deg ;case 3:goto _dgb ;
case 4:goto _dbe ;case 39:goto _aeea ;case 5:goto _eeg ;case 6:goto _feba ;case 7:goto _gfed ;case 8:goto _cfge ;case 40:goto _ceac ;case 9:goto _acd ;case 41:goto _dga ;case 10:goto _gbg ;case 42:goto _faa ;case 11:goto _fae ;case 43:goto _eaad ;case 44:goto _afb ;
case 45:goto _fffcb ;case 12:goto _bafc ;case 46:goto _fag ;case 13:goto _edff ;case 14:goto _fgbe ;case 15:goto _fac ;case 16:goto _ebba ;case 47:goto _bcc ;case 17:goto _gfc ;case 48:goto _ffge ;case 18:goto _ceb ;case 19:goto _fba ;case 20:goto _adfa ;
case 49:goto _efa ;case 50:goto _gdac ;case 21:goto _bfg ;case 22:goto _gfcf ;case 23:goto _cac ;case 24:goto _ffgc ;case 25:goto _gfeee ;case 51:goto _becb ;case 26:goto _fegf ;case 52:goto _gdab ;case 53:goto _fec ;case 54:goto _gacf ;case 55:goto _efac ;
case 56:goto _eege ;case 57:goto _bfed ;case 27:goto _cec ;case 28:goto _eee ;case 29:goto _aaa ;case 30:goto _ceab ;case 31:goto _ded ;case 58:goto _gdf ;case 32:goto _bfb ;case 59:goto _dgdb ;case 33:goto _dbec ;case 60:goto _cfgg ;case 61:goto _bbc ;
case 62:goto _aagg ;};goto _egda ;_ggb :switch _dafg {case 2:{_aec =(_bcga )-1;_efg ._bdaf .AddToken (FmtTypeDigit ,nil );};case 3:{_aec =(_bcga )-1;_efg ._bdaf .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_aec =(_bcga )-1;};case 8:{_aec =(_bcga )-1;_efg ._bdaf .AddToken (FmtTypePercent ,nil );
};case 13:{_aec =(_bcga )-1;_efg ._bdaf .AddToken (FmtTypeFraction ,_eggd [_fffc :_bcga ]);};case 14:{_aec =(_bcga )-1;_efg ._bdaf .AddToken (FmtTypeDate ,_eggd [_fffc :_bcga ]);};case 15:{_aec =(_bcga )-1;_efg ._bdaf .AddToken (FmtTypeTime ,_eggd [_fffc :_bcga ]);
};case 16:{_aec =(_bcga )-1;_efg ._bdaf .AddToken (FmtTypeTime ,_eggd [_fffc :_bcga ]);};case 18:{_aec =(_bcga )-1;};case 20:{_aec =(_bcga )-1;_efg ._bdaf .AddToken (FmtTypeLiteral ,_eggd [_fffc :_bcga ]);};case 21:{_aec =(_bcga )-1;_efg ._bdaf .AddToken (FmtTypeLiteral ,_eggd [_fffc +1:_bcga -1]);
};};goto _fdf ;_eaf :_aec =(_bcga )-1;{_efg ._bdaf .AddToken (FmtTypeFraction ,_eggd [_fffc :_bcga ]);};goto _fdf ;_aee :_aec =(_bcga )-1;{_efg ._bdaf .AddToken (FmtTypeDigitOpt ,nil );};goto _fdf ;_bbf :_bcga =_aec +1;{_efg ._bdaf .AddToken (FmtTypeDigitOptThousands ,nil );
};goto _fdf ;_aegg :_aec =(_bcga )-1;{_efg ._bdaf .AddToken (FmtTypePercent ,nil );};goto _fdf ;_agacd :_aec =(_bcga )-1;{_efg ._bdaf .AddToken (FmtTypeDate ,_eggd [_fffc :_bcga ]);};goto _fdf ;_egga :_aec =(_bcga )-1;{_efg ._bdaf .AddToken (FmtTypeDigit ,nil );
};goto _fdf ;_dca :_aec =(_bcga )-1;{_efg ._bdaf .AddToken (FmtTypeTime ,_eggd [_fffc :_bcga ]);};goto _fdf ;_gfd :_aec =(_bcga )-1;{_efg ._bdaf .AddToken (FmtTypeLiteral ,_eggd [_fffc :_bcga ]);};goto _fdf ;_baec :_bcga =_aec +1;{_efg ._bdaf ._feb =true ;
};goto _fdf ;_dbb :_bcga =_aec +1;{_efg ._bdaf .AddToken (FmtTypeLiteral ,_eggd [_fffc :_bcga ]);};goto _fdf ;_bfdf :_bcga =_aec +1;{_efg ._bdaf .AddToken (FmtTypeDollar ,nil );};goto _fdf ;_cfbd :_bcga =_aec +1;{_efg ._bdaf .AddToken (FmtTypeComma ,nil );
};goto _fdf ;_agf :_bcga =_aec +1;{_efg ._bdaf .AddToken (FmtTypeDecimal ,nil );};goto _fdf ;_ccf :_bcga =_aec +1;{_efg .nextFmt ();};goto _fdf ;_gbfe :_bcga =_aec +1;{_efg ._bdaf .AddToken (FmtTypeText ,nil );};goto _fdf ;_gegg :_bcga =_aec +1;{_efg ._bdaf .AddToken (FmtTypeUnderscore ,nil );
};goto _fdf ;_cea :_bcga =_aec ;_aec --;{_efg ._bdaf .AddToken (FmtTypeLiteral ,_eggd [_fffc :_bcga ]);};goto _fdf ;_ace :_bcga =_aec ;_aec --;{_efg ._bdaf .AddToken (FmtTypeLiteral ,_eggd [_fffc +1:_bcga -1]);};goto _fdf ;_gfdc :_bcga =_aec ;_aec --;{_efg ._bdaf .AddToken (FmtTypeDigitOpt ,nil );
};goto _fdf ;_ada :_bcga =_aec ;_aec --;{_efg ._bdaf .AddToken (FmtTypeFraction ,_eggd [_fffc :_bcga ]);};goto _fdf ;_bca :_bcga =_aec ;_aec --;{_efg ._bdaf .AddToken (FmtTypePercent ,nil );};goto _fdf ;_gfee :_bcga =_aec ;_aec --;{_efg ._bdaf .AddToken (FmtTypeDate ,_eggd [_fffc :_bcga ]);
};goto _fdf ;_feg :_bcga =_aec ;_aec --;{_efg ._bdaf .AddToken (FmtTypeDigit ,nil );};goto _fdf ;_gggb :_bcga =_aec ;_aec --;{_efg ._bdaf .AddToken (FmtTypeTime ,_eggd [_fffc :_bcga ]);};goto _fdf ;_adf :_bcga =_aec ;_aec --;{};goto _fdf ;_bgb :_bcga =_aec +1;
{_efg ._bdaf .IsExponential =true ;};goto _fdf ;_eedb :_bcga =_aec +1;{_efg ._bdaf .AddToken (FmtTypeLiteral ,_eggd [_fffc +1:_bcga ]);};goto _fdf ;_fdf :_fffc =0;if _aec ++;_aec ==_gge {goto _caf ;};_bcfg :_fffc =_aec ;switch _eggd [_aec ]{case 34:goto _aed ;
case 35:goto _dgf ;case 36:goto _bfdf ;case 37:goto _bfe ;case 44:goto _cfbd ;case 46:goto _agf ;case 47:goto _gcfa ;case 48:goto _bgbf ;case 58:goto _egc ;case 59:goto _ccf ;case 63:goto _cedg ;case 64:goto _gbfe ;case 65:goto _ccae ;case 69:goto _cgdg ;
case 71:goto _gacb ;case 91:goto _adfaa ;case 92:goto _cgg ;case 95:goto _gegg ;case 100:goto _gcfa ;case 104:goto _egc ;case 109:goto _dba ;case 115:goto _bcbf ;case 121:goto _dad ;};if 49<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _gcfg ;};goto _dbb ;_aed :_bcga =_aec +1;
_dafg =20;goto _ceec ;_ceec :if _aec ++;_aec ==_gge {goto _dbaf ;};_dgd :if _eggd [_aec ]==34{goto _cfe ;};goto _bdba ;_bdba :if _aec ++;_aec ==_gge {goto _adca ;};_dde :if _eggd [_aec ]==34{goto _cfe ;};goto _bdba ;_cfe :_bcga =_aec +1;_dafg =21;goto _bggb ;
_bggb :if _aec ++;_aec ==_gge {goto _bee ;};_gcb :if _eggd [_aec ]==34{goto _bdba ;};goto _ace ;_dgf :_bcga =_aec +1;_dafg =3;goto _fab ;_fab :if _aec ++;_aec ==_gge {goto _fge ;};_bcb :switch _eggd [_aec ]{case 35:goto _cad ;case 37:goto _cad ;case 44:goto _eegd ;
case 47:goto _abef ;case 48:goto _cad ;case 63:goto _cad ;};goto _gfdc ;_cad :if _aec ++;_aec ==_gge {goto _ebd ;};_adc :switch _eggd [_aec ]{case 35:goto _cad ;case 37:goto _cad ;case 47:goto _abef ;case 48:goto _cad ;case 63:goto _cad ;};goto _ggb ;_abef :if _aec ++;
_aec ==_gge {goto _aeb ;};_fbc :switch _eggd [_aec ]{case 35:goto _cab ;case 37:goto _dac ;case 48:goto _cbe ;case 63:goto _cab ;};if 49<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _cbg ;};goto _ggb ;_cab :_bcga =_aec +1;goto _adgb ;_adgb :if _aec ++;_aec ==_gge {goto _bab ;
};_deg :switch _eggd [_aec ]{case 35:goto _cab ;case 37:goto _cab ;case 44:goto _cab ;case 46:goto _cab ;case 48:goto _cab ;case 63:goto _cab ;case 65:goto _deag ;};goto _ada ;_deag :if _aec ++;_aec ==_gge {goto _aeeg ;};_dgb :switch _eggd [_aec ]{case 47:goto _gcc ;
case 77:goto _gad ;};goto _eaf ;_gcc :if _aec ++;_aec ==_gge {goto _eac ;};_dbe :if _eggd [_aec ]==80{goto _eaa ;};goto _eaf ;_eaa :_bcga =_aec +1;goto _dfa ;_dfa :if _aec ++;_aec ==_gge {goto _cag ;};_aeea :if _eggd [_aec ]==65{goto _deag ;};goto _ada ;
_gad :if _aec ++;_aec ==_gge {goto _bgaa ;};_eeg :if _eggd [_aec ]==47{goto _gfeec ;};goto _eaf ;_gfeec :if _aec ++;_aec ==_gge {goto _fcee ;};_feba :if _eggd [_aec ]==80{goto _afea ;};goto _eaf ;_afea :if _aec ++;_aec ==_gge {goto _ffa ;};_gfed :if _eggd [_aec ]==77{goto _eaa ;
};goto _eaf ;_dac :if _aec ++;_aec ==_gge {goto _gccc ;};_cfge :switch _eggd [_aec ]{case 35:goto _ggfb ;case 37:goto _aad ;case 63:goto _ggfb ;};if 48<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _bed ;};goto _ggb ;_ggfb :_bcga =_aec +1;goto _fda ;_fda :if _aec ++;
_aec ==_gge {goto _dfc ;};_ceac :switch _eggd [_aec ]{case 35:goto _cab ;case 37:goto _gcge ;case 44:goto _cab ;case 46:goto _cab ;case 48:goto _cab ;case 63:goto _cab ;case 65:goto _deag ;};goto _ada ;_gcge :if _aec ++;_aec ==_gge {goto _dacc ;};_acd :switch _eggd [_aec ]{case 35:goto _bdg ;
case 44:goto _bdg ;case 46:goto _bdg ;case 48:goto _bdg ;case 63:goto _bdg ;};goto _eaf ;_bdg :_bcga =_aec +1;goto _fcf ;_fcf :if _aec ++;_aec ==_gge {goto _bdbc ;};_dga :switch _eggd [_aec ]{case 35:goto _bdg ;case 44:goto _bdg ;case 46:goto _bdg ;case 48:goto _bdg ;
case 63:goto _bdg ;case 65:goto _deag ;};goto _ada ;_aad :if _aec ++;_aec ==_gge {goto _ddfe ;};_gbg :if _eggd [_aec ]==37{goto _aad ;};if 48<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _bed ;};goto _ggb ;_bed :_bcga =_aec +1;_dafg =13;goto _dcb ;_dcb :if _aec ++;
_aec ==_gge {goto _gcgc ;};_faa :switch _eggd [_aec ]{case 35:goto _cab ;case 37:goto _acb ;case 44:goto _cab ;case 46:goto _cab ;case 48:goto _gcf ;case 63:goto _cab ;case 65:goto _deag ;};if 49<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _bed ;};goto _ada ;
_acb :if _aec ++;_aec ==_gge {goto _gffd ;};_fae :switch _eggd [_aec ]{case 35:goto _bdg ;case 37:goto _aad ;case 44:goto _bdg ;case 46:goto _bdg ;case 63:goto _bdg ;};if 48<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _bed ;};goto _eaf ;_gcf :_bcga =_aec +1;
goto _dff ;_dff :if _aec ++;_aec ==_gge {goto _edee ;};_eaad :switch _eggd [_aec ]{case 35:goto _cab ;case 37:goto _gcf ;case 44:goto _cab ;case 46:goto _cab ;case 48:goto _gcf ;case 63:goto _cab ;case 65:goto _deag ;};if 49<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _bed ;
};goto _ada ;_cbe :_bcga =_aec +1;goto _ebb ;_ebb :if _aec ++;_aec ==_gge {goto _gaca ;};_afb :switch _eggd [_aec ]{case 35:goto _cab ;case 37:goto _gcf ;case 44:goto _cab ;case 46:goto _cab ;case 48:goto _cbe ;case 63:goto _cab ;case 65:goto _deag ;};
if 49<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _cbg ;};goto _ada ;_cbg :_bcga =_aec +1;goto _aaf ;_aaf :if _aec ++;_aec ==_gge {goto _adbd ;};_fffcb :switch _eggd [_aec ]{case 35:goto _cab ;case 37:goto _bed ;case 44:goto _cab ;case 46:goto _cab ;case 48:goto _cbe ;
case 63:goto _cab ;case 65:goto _deag ;};if 49<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _cbg ;};goto _ada ;_eegd :if _aec ++;_aec ==_gge {goto _dcgf ;};_bafc :if _eggd [_aec ]==35{goto _bbf ;};goto _aee ;_bfe :_bcga =_aec +1;_dafg =8;goto _gec ;_gec :if _aec ++;
_aec ==_gge {goto _bdf ;};_fag :switch _eggd [_aec ]{case 35:goto _dcg ;case 37:goto _dgad ;case 48:goto _cddc ;case 63:goto _dcg ;};if 49<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _bcd ;};goto _bca ;_dcg :if _aec ++;_aec ==_gge {goto _aac ;};_edff :switch _eggd [_aec ]{case 35:goto _dcg ;
case 47:goto _abef ;case 48:goto _dcg ;case 63:goto _dcg ;};goto _aegg ;_dgad :if _aec ++;_aec ==_gge {goto _agfe ;};_fgbe :if _eggd [_aec ]==37{goto _dgad ;};if 48<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _bcd ;};goto _ggb ;_bcd :if _aec ++;_aec ==_gge {goto _ffbd ;
};_fac :switch _eggd [_aec ]{case 37:goto _dgad ;case 47:goto _abef ;};if 48<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _bcd ;};goto _ggb ;_cddc :if _aec ++;_aec ==_gge {goto _gbfc ;};_ebba :switch _eggd [_aec ]{case 35:goto _dcg ;case 37:goto _dgad ;case 47:goto _abef ;
case 48:goto _cddc ;case 63:goto _dcg ;};if 49<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _bcd ;};goto _aegg ;_gcfa :_bcga =_aec +1;goto _aaga ;_aaga :if _aec ++;_aec ==_gge {goto _aca ;};_bcc :switch _eggd [_aec ]{case 47:goto _gcfa ;case 100:goto _gcfa ;
case 109:goto _gcfa ;case 121:goto _ecf ;};goto _gfee ;_ecf :if _aec ++;_aec ==_gge {goto _bbeg ;};_gfc :if _eggd [_aec ]==121{goto _gcfa ;};goto _agacd ;_bgbf :_bcga =_aec +1;_dafg =2;goto _dcgg ;_dcgg :if _aec ++;_aec ==_gge {goto _eedg ;};_ffge :switch _eggd [_aec ]{case 35:goto _cad ;
case 37:goto _bbed ;case 47:goto _abef ;case 48:goto _ecea ;case 63:goto _cad ;};if 49<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _gcfb ;};goto _feg ;_bbed :if _aec ++;_aec ==_gge {goto _aeab ;};_ceb :switch _eggd [_aec ]{case 35:goto _cad ;case 37:goto _bbed ;
case 47:goto _abef ;case 48:goto _bbed ;case 63:goto _cad ;};if 49<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _bcd ;};goto _egga ;_ecea :if _aec ++;_aec ==_gge {goto _agdb ;};_fba :switch _eggd [_aec ]{case 35:goto _cad ;case 37:goto _bbed ;case 47:goto _abef ;
case 48:goto _ecea ;case 63:goto _cad ;};if 49<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _gcfb ;};goto _egga ;_gcfb :if _aec ++;_aec ==_gge {goto _eafa ;};_adfa :switch _eggd [_aec ]{case 37:goto _bcd ;case 47:goto _abef ;};if 48<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _gcfb ;
};goto _ggb ;_gcfg :_bcga =_aec +1;_dafg =20;goto _edb ;_edb :if _aec ++;_aec ==_gge {goto _gfcd ;};_efa :switch _eggd [_aec ]{case 37:goto _bcd ;case 47:goto _abef ;};if 48<=_eggd [_aec ]&&_eggd [_aec ]<=57{goto _gcfb ;};goto _cea ;_egc :_bcga =_aec +1;
_dafg =15;goto _cbf ;_cbf :if _aec ++;_aec ==_gge {goto _fcfg ;};_gdac :switch _eggd [_aec ]{case 58:goto _egc ;case 65:goto _faag ;case 104:goto _egc ;case 109:goto _egc ;case 115:goto _bcbf ;};goto _gggb ;_faag :if _aec ++;_aec ==_gge {goto _acbc ;};
_bfg :switch _eggd [_aec ]{case 47:goto _bdac ;case 77:goto _ccg ;};goto _ggb ;_bdac :if _aec ++;_aec ==_gge {goto _dffa ;};_gfcf :if _eggd [_aec ]==80{goto _egc ;};goto _ggb ;_ccg :if _aec ++;_aec ==_gge {goto _cabd ;};_cac :if _eggd [_aec ]==47{goto _bde ;
};goto _ggb ;_bde :if _aec ++;_aec ==_gge {goto _ddeg ;};_ffgc :if _eggd [_aec ]==80{goto _ccgd ;};goto _ggb ;_ccgd :if _aec ++;_aec ==_gge {goto _bgegc ;};_gfeee :if _eggd [_aec ]==77{goto _egc ;};goto _ggb ;_bcbf :_bcga =_aec +1;_dafg =15;goto _bgac ;
_bgac :if _aec ++;_aec ==_gge {goto _ggag ;};_becb :switch _eggd [_aec ]{case 46:goto _gfg ;case 58:goto _egc ;case 65:goto _faag ;case 104:goto _egc ;case 109:goto _egc ;case 115:goto _bcbf ;};goto _gggb ;_gfg :if _aec ++;_aec ==_gge {goto _dbd ;};_fegf :if _eggd [_aec ]==48{goto _bea ;
};goto _dca ;_bea :_bcga =_aec +1;_dafg =15;goto _cbcf ;_cbcf :if _aec ++;_aec ==_gge {goto _fabc ;};_gdab :switch _eggd [_aec ]{case 48:goto _addg ;case 58:goto _egc ;case 65:goto _faag ;case 104:goto _egc ;case 109:goto _egc ;case 115:goto _bcbf ;};goto _gggb ;
_addg :_bcga =_aec +1;_dafg =15;goto _cfbc ;_cfbc :if _aec ++;_aec ==_gge {goto _cggg ;};_fec :switch _eggd [_aec ]{case 48:goto _egc ;case 58:goto _egc ;case 65:goto _faag ;case 104:goto _egc ;case 109:goto _egc ;case 115:goto _bcbf ;};goto _gggb ;_cedg :_bcga =_aec +1;
_dafg =5;goto _fcad ;_fcad :if _aec ++;_aec ==_gge {goto _acf ;};_gacf :switch _eggd [_aec ]{case 35:goto _cad ;case 37:goto _cad ;case 47:goto _abef ;case 48:goto _cad ;case 63:goto _cad ;};goto _adf ;_ccae :_bcga =_aec +1;_dafg =20;goto _abcg ;_abcg :if _aec ++;
_aec ==_gge {goto _fgac ;};_efac :switch _eggd [_aec ]{case 47:goto _bdac ;case 77:goto _ccg ;};goto _cea ;_cgdg :if _aec ++;_aec ==_gge {goto _ecaa ;};_eege :switch _eggd [_aec ]{case 43:goto _bgb ;case 45:goto _bgb ;};goto _cea ;_gacb :_bcga =_aec +1;
goto _abad ;_abad :if _aec ++;_aec ==_gge {goto _ffff ;};_bfed :if _eggd [_aec ]==101{goto _aea ;};goto _cea ;_aea :if _aec ++;_aec ==_gge {goto _fcc ;};_cec :if _eggd [_aec ]==110{goto _dbcf ;};goto _gfd ;_dbcf :if _aec ++;_aec ==_gge {goto _aedg ;};_eee :if _eggd [_aec ]==101{goto _accd ;
};goto _gfd ;_accd :if _aec ++;_aec ==_gge {goto _acfc ;};_aaa :if _eggd [_aec ]==114{goto _dfg ;};goto _gfd ;_dfg :if _aec ++;_aec ==_gge {goto _gffb ;};_ceab :if _eggd [_aec ]==97{goto _feee ;};goto _gfd ;_feee :if _aec ++;_aec ==_gge {goto _dae ;};_ded :if _eggd [_aec ]==108{goto _baec ;
};goto _gfd ;_adfaa :_bcga =_aec +1;_dafg =20;goto _gdace ;_gdace :if _aec ++;_aec ==_gge {goto _dgbd ;};_gdf :switch _eggd [_aec ]{case 104:goto _gab ;case 109:goto _gab ;case 115:goto _gab ;};goto _ecb ;_ecb :if _aec ++;_aec ==_gge {goto _bdfc ;};_bfb :if _eggd [_aec ]==93{goto _fdg ;
};goto _ecb ;_fdg :_bcga =_aec +1;_dafg =18;goto _egea ;_edge :_bcga =_aec +1;_dafg =16;goto _egea ;_egea :if _aec ++;_aec ==_gge {goto _bcba ;};_dgdb :if _eggd [_aec ]==93{goto _fdg ;};goto _ecb ;_gab :if _aec ++;_aec ==_gge {goto _bdfa ;};_dbec :if _eggd [_aec ]==93{goto _edge ;
};goto _ecb ;_cgg :if _aec ++;_aec ==_gge {goto _gabc ;};_cfgg :goto _eedb ;_dba :_bcga =_aec +1;_dafg =14;goto _efeg ;_efeg :if _aec ++;_aec ==_gge {goto _eegb ;};_bbc :switch _eggd [_aec ]{case 47:goto _gcfa ;case 58:goto _egc ;case 65:goto _faag ;case 100:goto _gcfa ;
case 104:goto _egc ;case 109:goto _dba ;case 115:goto _bcbf ;case 121:goto _ecf ;};goto _gfee ;_dad :if _aec ++;_aec ==_gge {goto _dab ;};_aagg :if _eggd [_aec ]==121{goto _gcfa ;};goto _cea ;_egda :_caf :_afdg =34;goto _fea ;_dbaf :_afdg =35;goto _fea ;
_adca :_afdg =0;goto _fea ;_bee :_afdg =36;goto _fea ;_fge :_afdg =37;goto _fea ;_ebd :_afdg =1;goto _fea ;_aeb :_afdg =2;goto _fea ;_bab :_afdg =38;goto _fea ;_aeeg :_afdg =3;goto _fea ;_eac :_afdg =4;goto _fea ;_cag :_afdg =39;goto _fea ;_bgaa :_afdg =5;
goto _fea ;_fcee :_afdg =6;goto _fea ;_ffa :_afdg =7;goto _fea ;_gccc :_afdg =8;goto _fea ;_dfc :_afdg =40;goto _fea ;_dacc :_afdg =9;goto _fea ;_bdbc :_afdg =41;goto _fea ;_ddfe :_afdg =10;goto _fea ;_gcgc :_afdg =42;goto _fea ;_gffd :_afdg =11;goto _fea ;
_edee :_afdg =43;goto _fea ;_gaca :_afdg =44;goto _fea ;_adbd :_afdg =45;goto _fea ;_dcgf :_afdg =12;goto _fea ;_bdf :_afdg =46;goto _fea ;_aac :_afdg =13;goto _fea ;_agfe :_afdg =14;goto _fea ;_ffbd :_afdg =15;goto _fea ;_gbfc :_afdg =16;goto _fea ;_aca :_afdg =47;
goto _fea ;_bbeg :_afdg =17;goto _fea ;_eedg :_afdg =48;goto _fea ;_aeab :_afdg =18;goto _fea ;_agdb :_afdg =19;goto _fea ;_eafa :_afdg =20;goto _fea ;_gfcd :_afdg =49;goto _fea ;_fcfg :_afdg =50;goto _fea ;_acbc :_afdg =21;goto _fea ;_dffa :_afdg =22;
goto _fea ;_cabd :_afdg =23;goto _fea ;_ddeg :_afdg =24;goto _fea ;_bgegc :_afdg =25;goto _fea ;_ggag :_afdg =51;goto _fea ;_dbd :_afdg =26;goto _fea ;_fabc :_afdg =52;goto _fea ;_cggg :_afdg =53;goto _fea ;_acf :_afdg =54;goto _fea ;_fgac :_afdg =55;goto _fea ;
_ecaa :_afdg =56;goto _fea ;_ffff :_afdg =57;goto _fea ;_fcc :_afdg =27;goto _fea ;_aedg :_afdg =28;goto _fea ;_acfc :_afdg =29;goto _fea ;_gffb :_afdg =30;goto _fea ;_dae :_afdg =31;goto _fea ;_dgbd :_afdg =58;goto _fea ;_bdfc :_afdg =32;goto _fea ;_bcba :_afdg =59;
goto _fea ;_bdfa :_afdg =33;goto _fea ;_gabc :_afdg =60;goto _fea ;_eegb :_afdg =61;goto _fea ;_dab :_afdg =62;goto _fea ;_fea :{};if _aec ==_baea {switch _afdg {case 35:goto _cea ;case 0:goto _ggb ;case 36:goto _ace ;case 37:goto _gfdc ;case 1:goto _ggb ;
case 2:goto _ggb ;case 38:goto _ada ;case 3:goto _eaf ;case 4:goto _eaf ;case 39:goto _ada ;case 5:goto _eaf ;case 6:goto _eaf ;case 7:goto _eaf ;case 8:goto _ggb ;case 40:goto _ada ;case 9:goto _eaf ;case 41:goto _ada ;case 10:goto _ggb ;case 42:goto _ada ;
case 11:goto _eaf ;case 43:goto _ada ;case 44:goto _ada ;case 45:goto _ada ;case 12:goto _aee ;case 46:goto _bca ;case 13:goto _aegg ;case 14:goto _ggb ;case 15:goto _ggb ;case 16:goto _aegg ;case 47:goto _gfee ;case 17:goto _agacd ;case 48:goto _feg ;
case 18:goto _egga ;case 19:goto _egga ;case 20:goto _ggb ;case 49:goto _cea ;case 50:goto _gggb ;case 21:goto _ggb ;case 22:goto _ggb ;case 23:goto _ggb ;case 24:goto _ggb ;case 25:goto _ggb ;case 51:goto _gggb ;case 26:goto _dca ;case 52:goto _gggb ;
case 53:goto _gggb ;case 54:goto _adf ;case 55:goto _cea ;case 56:goto _cea ;case 57:goto _cea ;case 27:goto _gfd ;case 28:goto _gfd ;case 29:goto _gfd ;case 30:goto _gfd ;case 31:goto _gfd ;case 58:goto _cea ;case 32:goto _ggb ;case 59:goto _ggb ;case 33:goto _gfd ;
case 60:goto _cea ;case 61:goto _gfee ;case 62:goto _cea ;};};};if _fffc > 0{copy (_eggd [0:],_eggd [_fffc :]);};};_ =_baea ;if _afdg ==_gea {_ge .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};
};const _dec int =0;const _daf int =34;func (_fff *Lexer )nextFmt (){_fff ._eag =append (_fff ._eag ,_fff ._bdaf );_fff ._bdaf =Format {}};func _eeb (_cdg int64 ,_cgb Format )[]byte {if !_cgb .IsExponential ||len (_cgb .Exponent )==0{return nil ;};_be :=_f .AppendInt (nil ,_bfd (_cdg ),10);
_df :=make ([]byte ,0,len (_be )+2);_df =append (_df ,'E');if _cdg >=0{_df =append (_df ,'+');}else {_df =append (_df ,'-');_cdg *=-1;};_ggg :=0;_cbc :for _bbd :=len (_cgb .Exponent )-1;_bbd >=0;_bbd --{_edc :=len (_be )-1-_ggg ;_fef :=_cgb .Exponent [_bbd ];
switch _fef .Type {case FmtTypeDigit :if _edc >=0{_df =append (_df ,_be [_edc ]);_ggg ++;}else {_df =append (_df ,'0');};case FmtTypeDigitOpt :if _edc >=0{_df =append (_df ,_be [_edc ]);_ggg ++;}else {for _baf :=_bbd ;_baf >=0;_baf --{_eb :=_cgb .Exponent [_baf ];
if _eb .Type ==FmtTypeLiteral {_df =append (_df ,_eb .Literal );};};break _cbc ;};case FmtTypeLiteral :_df =append (_df ,_fef .Literal );default:_ge .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_fef );
};};if _ggg < len (_be ){_df =append (_df ,_be [len (_be )-_ggg -1:_ggg -1]...);};_db (_df [2:]);return _df ;};

// FmtType is the type of a format token.
//
//go:generate stringer -type=FmtType
type FmtType byte ;