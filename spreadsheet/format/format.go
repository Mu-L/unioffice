//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_cca "bytes";_g "fmt";_b "github.com/unidoc/unioffice/common/logger";_db "io";_cc "math";_dc "strconv";_c "strings";_f "time";);func _ced (_bcdg _f .Time )_f .Time {_bcdg =_bcdg .UTC ();return _f .Date (_bcdg .Year (),_bcdg .Month (),_bcdg .Day (),_bcdg .Hour (),_bcdg .Minute (),_bcdg .Second (),_bcdg .Nanosecond (),_f .Local );
};func (_cd FmtType )String ()string {if _cd >=FmtType (len (_ca )-1){return _g .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_cd );};return _a [_ca [_cd ]:_ca [_cd +1]];};const _de =1e-10;func _efaf (_deb []byte )[]byte {for _aac :=len (_deb )-1;
_aac > 0;_aac --{if _deb [_aac ]=='9'+1{_deb [_aac ]='0';if _deb [_aac -1]=='.'{_aac --;};_deb [_aac -1]++;};};if _deb [0]=='9'+1{_deb [0]='0';copy (_deb [1:],_deb [0:]);_deb [0]='1';};return _deb ;};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _cc .Abs (v )>=_e ||_cc .Abs (v )<=_de &&v !=0{return _cgab (v );};_bd :=make ([]byte ,0,15);_bd =_dc .AppendFloat (_bd ,v ,'f',-1,64);if len (_bd )> 11{_ffa :=_bd [11]-'0';if _ffa >=5&&_ffa <=9{_bd [10]++;_bd =_bd [0:11];
_bd =_efaf (_bd );};_bd =_bd [0:11];}else if len (_bd )==11{if _bd [len (_bd )-1]=='9'{_bd [len (_bd )-1]++;_bd =_efaf (_bd );};};_bd =_aa (_bd );return string (_bd );};const _ecb int =0;func _gdg (_fce int64 ,_deg Format )[]byte {if !_deg .IsExponential ||len (_deg .Exponent )==0{return nil ;
};_fac :=_dc .AppendInt (nil ,_dgc (_fce ),10);_egb :=make ([]byte ,0,len (_fac )+2);_egb =append (_egb ,'E');if _fce >=0{_egb =append (_egb ,'+');}else {_egb =append (_egb ,'-');_fce *=-1;};_fdee :=0;_bfb :for _bef :=len (_deg .Exponent )-1;_bef >=0;_bef --{_feb :=len (_fac )-1-_fdee ;
_efa :=_deg .Exponent [_bef ];switch _efa .Type {case FmtTypeDigit :if _feb >=0{_egb =append (_egb ,_fac [_feb ]);_fdee ++;}else {_egb =append (_egb ,'0');};case FmtTypeDigitOpt :if _feb >=0{_egb =append (_egb ,_fac [_feb ]);_fdee ++;}else {for _abg :=_bef ;
_abg >=0;_abg --{_efe :=_deg .Exponent [_abg ];if _efe .Type ==FmtTypeLiteral {_egb =append (_egb ,_efe .Literal );};};break _bfb ;};case FmtTypeLiteral :_egb =append (_egb ,_efa .Literal );default:_b .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_efa );
};};if _fdee < len (_fac ){_egb =append (_egb ,_fac [len (_fac )-_fdee -1:_fdee -1]...);};_ga (_egb [2:]);return _egb ;};func _cgab (_fee float64 )string {_bab :=_dc .FormatFloat (_fee ,'E',-1,64);_efc :=_dc .FormatFloat (_fee ,'E',5,64);if len (_bab )< len (_efc ){return _dc .FormatFloat (_fee ,'E',2,64);
};return _efc ;};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_dg :=Parse (f );var _eb Format ;if len (_dg )==1{_eb =_dg [0];}else if len (_dg )==4{_eb =_dg [3];};_bce :=false ;for _ ,_ge :=range _eb .Whole {if _ge .Type ==FmtTypeText {_bce =true ;};};if !_bce {return v ;};
_gfdd :=_cca .Buffer {};for _ ,_fe :=range _eb .Whole {switch _fe .Type {case FmtTypeLiteral :_gfdd .WriteByte (_fe .Literal );case FmtTypeText :_gfdd .WriteString (v );};};return _gfdd .String ();};const _aeg int =0;func _cga (_cac float64 ,_ff Format ,_ce bool )string {if _ff ._dfa {return NumberGeneric (_cac );
};_dd :=make ([]byte ,0,20);_efd :=_cc .Signbit (_cac );_gg :=_cc .Abs (_cac );_ac :=int64 (0);_ggf :=int64 (0);if _ff .IsExponential {for _gg >=10{_ggf ++;_gg /=10;};for _gg < 1{_ggf --;_gg *=10;};}else if _ff ._df {_gg *=100;}else if _ff ._fc {if _ff ._bc ==0{_fed :=_cc .Pow (10,float64 (_ff ._fb ));
_fd ,_ggb :=1.0,1.0;_ =_fd ;for _fde :=1.0;_fde < _fed ;_fde ++{_ ,_fedd :=_cc .Modf (_gg *float64 (_fde ));if _fedd < _ggb {_ggb =_fedd ;_fd =_fde ;if _fedd ==0{break ;};};};_ff ._bc =int64 (_fd );};_ac =int64 (_gg *float64 (_ff ._bc )+0.5);if len (_ff .Whole )> 0&&_ac > _ff ._bc {_ac =int64 (_gg *float64 (_ff ._bc ))%_ff ._bc ;
_gg -=float64 (_ac )/float64 (_ff ._bc );}else {_gg -=float64 (_ac )/float64 (_ff ._bc );if _cc .Abs (_gg )< 1{_dce :=true ;for _ ,_dfe :=range _ff .Whole {if _dfe .Type ==FmtTypeDigitOpt {continue ;};if _dfe .Type ==FmtTypeLiteral &&_dfe .Literal ==' '{continue ;
};_dce =false ;};if _dce {_ff .Whole =nil ;};};};};_gfdb :=1;for _ ,_cde :=range _ff .Fractional {if _cde .Type ==FmtTypeDigit ||_cde .Type ==FmtTypeDigitOpt {_gfdb ++;};};_gg +=5*_cc .Pow10 (-_gfdb );_be ,_acb :=_cc .Modf (_gg );_dd =append (_dd ,_ee (_be ,_cac ,_ff )...);
_dd =append (_dd ,_agf (_acb ,_cac ,_ff )...);_dd =append (_dd ,_gdg (_ggf ,_ff )...);if _ff ._fc {_dd =_dc .AppendInt (_dd ,_ac ,10);_dd =append (_dd ,'/');_dd =_dc .AppendInt (_dd ,_ff ._bc ,10);};if !_ce &&_efd {return "\u002d"+string (_dd );};return string (_dd );
};const _gbe int =-1;const _efdd int =34;

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_gfd :=Parse (f );if len (_gfd )==1{return _cga (v ,_gfd [0],false );}else if len (_gfd )> 1&&v < 0{return _cga (v ,_gfd [1],true );
}else if len (_gfd )> 2&&v ==0{return _cga (v ,_gfd [2],false );};return _cga (v ,_gfd [0],false );};

// FmtType is the type of a format token.
//
//go:generate stringer -type=FmtType
type FmtType byte ;const _e =1e11;const _bfa int =0;

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_fc bool ;_df bool ;_dfa bool ;_gc bool ;_bg bool ;_fa bool ;_bc int64 ;_fb int ;};func IsNumber (data string )(_eag bool ){_afd ,_egcc ,_dgg :=0,0,len (data );
_ggcg :=len (data );_fec ,_aad ,_gaf :=0,0,0;_ =_aad ;_ =_gaf ;_ =_fec ;{_afd =_aeg ;_fec =0;_aad =0;_gaf =0;};{if _egcc ==_dgg {goto _cbb ;};switch _afd {case 0:goto _eca ;case 1:goto _gaae ;case 2:goto _afdb ;case 3:goto _dba ;case 4:goto _dgag ;case 5:goto _cgc ;
case 6:goto _gdc ;case 7:goto _eef ;};goto _febe ;_dae :_aad =_egcc ;_egcc --;{_eag =false ;};goto _gdd ;_bbd :_aad =_egcc ;_egcc --;{_eag =_aad ==len (data );};goto _gdd ;_adgc :_aad =_egcc ;_egcc --;{_eag =_aad ==len (data );};goto _gdd ;_ecf :switch _gaf {case 2:{_egcc =(_aad )-1;
_eag =_aad ==len (data );};case 3:{_egcc =(_aad )-1;_eag =false ;};};goto _gdd ;_gdd :_fec =0;if _egcc ++;_egcc ==_dgg {goto _dbg ;};_eca :_fec =_egcc ;switch data [_egcc ]{case 43:goto _cebe ;case 45:goto _cebe ;};if 48<=data [_egcc ]&&data [_egcc ]<=57{goto _ebg ;
};goto _fbb ;_fbb :if _egcc ++;_egcc ==_dgg {goto _egd ;};_gaae :goto _fbb ;_cebe :if _egcc ++;_egcc ==_dgg {goto _dcce ;};_afdb :if 48<=data [_egcc ]&&data [_egcc ]<=57{goto _ebg ;};goto _fbb ;_ebg :if _egcc ++;_egcc ==_dgg {goto _dfee ;};_dba :if data [_egcc ]==46{goto _febf ;
};if 48<=data [_egcc ]&&data [_egcc ]<=57{goto _ebg ;};goto _fbb ;_febf :if _egcc ++;_egcc ==_dgg {goto _fba ;};_dgag :if 48<=data [_egcc ]&&data [_egcc ]<=57{goto _ebf ;};goto _fbb ;_ebf :if _egcc ++;_egcc ==_dgg {goto _gdca ;};_cgc :if data [_egcc ]==69{goto _bbde ;
};if 48<=data [_egcc ]&&data [_egcc ]<=57{goto _ebf ;};goto _fbb ;_bbde :if _egcc ++;_egcc ==_dgg {goto _bcebc ;};_gdc :switch data [_egcc ]{case 43:goto _dega ;case 45:goto _dega ;};goto _fbb ;_dega :_aad =_egcc +1;_gaf =3;goto _afg ;_eaa :_aad =_egcc +1;
_gaf =2;goto _afg ;_afg :if _egcc ++;_egcc ==_dgg {goto _gea ;};_eef :if 48<=data [_egcc ]&&data [_egcc ]<=57{goto _eaa ;};goto _fbb ;_febe :_dbg :_afd =0;goto _cbb ;_egd :_afd =1;goto _cbb ;_dcce :_afd =2;goto _cbb ;_dfee :_afd =3;goto _cbb ;_fba :_afd =4;
goto _cbb ;_gdca :_afd =5;goto _cbb ;_bcebc :_afd =6;goto _cbb ;_gea :_afd =7;goto _cbb ;_cbb :{};if _egcc ==_ggcg {switch _afd {case 1:goto _dae ;case 2:goto _dae ;case 3:goto _bbd ;case 4:goto _dae ;case 5:goto _adgc ;case 6:goto _dae ;case 7:goto _ecf ;
};};};if _afd ==_gbe {return false ;};return ;};const _a ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";
const _fabb int =34;func _ga (_ebd []byte )[]byte {for _cg :=0;_cg < len (_ebd )/2;_cg ++{_dff :=len (_ebd )-1-_cg ;_ebd [_cg ],_ebd [_dff ]=_ebd [_dff ],_ebd [_cg ];};return _ebd ;};type Lexer struct{_agb Format ;_efea []Format ;};func _agf (_cab ,_bec float64 ,_bac Format )[]byte {if len (_bac .Fractional )==0{return nil ;
};_fcf :=_dc .AppendFloat (nil ,_cab ,'f',-1,64);if len (_fcf )> 2{_fcf =_fcf [2:];}else {_fcf =nil ;};_dcef :=make ([]byte ,0,len (_fcf ));_dcef =append (_dcef ,'.');_ceg :=0;_ab :for _da :=0;_da < len (_bac .Fractional );_da ++{_gab :=_da ;_bf :=_bac .Fractional [_da ];
switch _bf .Type {case FmtTypeDigit :if _gab < len (_fcf ){_dcef =append (_dcef ,_fcf [_gab ]);_ceg ++;}else {_dcef =append (_dcef ,'0');};case FmtTypeDigitOpt :if _gab >=0{_dcef =append (_dcef ,_fcf [_gab ]);_ceg ++;}else {break _ab ;};case FmtTypeLiteral :_dcef =append (_dcef ,_bf .Literal );
default:_b .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_bf );};};return _dcef ;};const (FmtTypeLiteral FmtType =iota ;
FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);

// AddToken adds a format token to the format.
func (_ad *Format )AddToken (t FmtType ,l []byte ){if _ad ._bg {_ad ._bg =false ;return ;};switch t {case FmtTypeDecimal :_ad ._fa =true ;case FmtTypeUnderscore :_ad ._bg =true ;case FmtTypeText :_ad .Whole =append (_ad .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_ad .Whole =append (_ad .Whole ,Token {Type :t ,DateTime :string (l )});
case FmtTypePercent :_ad ._df =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_ef :=range l {if _ad .IsExponential {_ad .Exponent =append (_ad .Exponent ,Token {Type :t ,Literal :_ef });
}else if !_ad ._fa {_ad .Whole =append (_ad .Whole ,Token {Type :t ,Literal :_ef });}else {_ad .Fractional =append (_ad .Fractional ,Token {Type :t ,Literal :_ef });};};case FmtTypeDigitOptThousands :_ad ._gc =true ;case FmtTypeFraction :_gcb :=_c .Split (string (l ),"\u002f");
if len (_gcb )==2{_ad ._fc =true ;_ad ._bc ,_ =_dc .ParseInt (_gcb [1],10,64);for _ ,_gf :=range _gcb [1]{if _gf =='?'||_gf =='0'{_ad ._fb ++;};};};default:_b .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );
};};func _dgc (_gd int64 )int64 {if _gd < 0{return -_gd ;};return _gd ;};func (_dccf *Lexer )Lex (r _db .Reader ){_fecd ,_edb ,_fbd :=0,0,0;_cgg :=-1;_ecaf ,_gbef ,_aada :=0,0,0;_ =_gbef ;_ =_aada ;_cegb :=1;_ =_cegb ;_bdf :=make ([]byte ,4096);_geb :=false ;
for !_geb {_fabe :=0;if _ecaf > 0{_fabe =_edb -_ecaf ;};_edb =0;_ffc ,_aed :=r .Read (_bdf [_fabe :]);if _ffc ==0||_aed !=nil {_geb =true ;};_fbd =_ffc +_fabe ;if _fbd < len (_bdf ){_cgg =_fbd ;};{_fecd =_cff ;_ecaf =0;_gbef =0;_aada =0;};{if _edb ==_fbd {goto _dbgf ;
};switch _fecd {case 34:goto _fedg ;case 35:goto _ddeb ;case 0:goto _efcb ;case 36:goto _fbag ;case 37:goto _cbf ;case 1:goto _daf ;case 2:goto _ccgg ;case 38:goto _gfda ;case 3:goto _bfg ;case 4:goto _ece ;case 39:goto _fgb ;case 5:goto _gdgb ;case 6:goto _efed ;
case 7:goto _ceba ;case 8:goto _faf ;case 40:goto _aegb ;case 9:goto _gfe ;case 41:goto _dgf ;case 10:goto _bfe ;case 42:goto _agfd ;case 11:goto _bfga ;case 43:goto _eaf ;case 44:goto _cege ;case 45:goto _daa ;case 12:goto _dfdd ;case 46:goto _bad ;case 13:goto _agea ;
case 14:goto _eafb ;case 15:goto _fcee ;case 16:goto _fccf ;case 47:goto _gfed ;case 17:goto _dbb ;case 48:goto _gba ;case 18:goto _gff ;case 19:goto _aec ;case 20:goto _gga ;case 49:goto _egf ;case 50:goto _ccb ;case 21:goto _dfb ;case 22:goto _dffe ;
case 23:goto _dbbf ;case 24:goto _acg ;case 25:goto _faag ;case 51:goto _acbb ;case 26:goto _abf ;case 52:goto _feca ;case 53:goto _fbe ;case 54:goto _cbfg ;case 55:goto _ddf ;case 56:goto _gda ;case 57:goto _ccd ;case 27:goto _gdda ;case 28:goto _aedd ;
case 29:goto _egeb ;case 30:goto _eafe ;case 31:goto _eea ;case 58:goto _gdad ;case 32:goto _babc ;case 59:goto _dceb ;case 33:goto _ecd ;case 60:goto _ega ;case 61:goto _ffb ;case 62:goto _cba ;};goto _ebgc ;_ffce :switch _aada {case 2:{_edb =(_gbef )-1;
_dccf ._agb .AddToken (FmtTypeDigit ,nil );};case 3:{_edb =(_gbef )-1;_dccf ._agb .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_edb =(_gbef )-1;};case 8:{_edb =(_gbef )-1;_dccf ._agb .AddToken (FmtTypePercent ,nil );};case 13:{_edb =(_gbef )-1;_dccf ._agb .AddToken (FmtTypeFraction ,_bdf [_ecaf :_gbef ]);
};case 14:{_edb =(_gbef )-1;_dccf ._agb .AddToken (FmtTypeDate ,_bdf [_ecaf :_gbef ]);};case 15:{_edb =(_gbef )-1;_dccf ._agb .AddToken (FmtTypeTime ,_bdf [_ecaf :_gbef ]);};case 16:{_edb =(_gbef )-1;_dccf ._agb .AddToken (FmtTypeTime ,_bdf [_ecaf :_gbef ]);
};case 18:{_edb =(_gbef )-1;};case 20:{_edb =(_gbef )-1;_dccf ._agb .AddToken (FmtTypeLiteral ,_bdf [_ecaf :_gbef ]);};case 21:{_edb =(_gbef )-1;_dccf ._agb .AddToken (FmtTypeLiteral ,_bdf [_ecaf +1:_gbef -1]);};};goto _febd ;_agg :_edb =(_gbef )-1;{_dccf ._agb .AddToken (FmtTypeFraction ,_bdf [_ecaf :_gbef ]);
};goto _febd ;_dde :_edb =(_gbef )-1;{_dccf ._agb .AddToken (FmtTypeDigitOpt ,nil );};goto _febd ;_fbda :_gbef =_edb +1;{_dccf ._agb .AddToken (FmtTypeDigitOptThousands ,nil );};goto _febd ;_eab :_edb =(_gbef )-1;{_dccf ._agb .AddToken (FmtTypePercent ,nil );
};goto _febd ;_befef :_edb =(_gbef )-1;{_dccf ._agb .AddToken (FmtTypeDate ,_bdf [_ecaf :_gbef ]);};goto _febd ;_fcfd :_edb =(_gbef )-1;{_dccf ._agb .AddToken (FmtTypeDigit ,nil );};goto _febd ;_cef :_edb =(_gbef )-1;{_dccf ._agb .AddToken (FmtTypeTime ,_bdf [_ecaf :_gbef ]);
};goto _febd ;_geeg :_edb =(_gbef )-1;{_dccf ._agb .AddToken (FmtTypeLiteral ,_bdf [_ecaf :_gbef ]);};goto _febd ;_age :_gbef =_edb +1;{_dccf ._agb ._dfa =true ;};goto _febd ;_ebfe :_gbef =_edb +1;{_dccf ._agb .AddToken (FmtTypeLiteral ,_bdf [_ecaf :_gbef ]);
};goto _febd ;_bcd :_gbef =_edb +1;{_dccf ._agb .AddToken (FmtTypeDollar ,nil );};goto _febd ;_fda :_gbef =_edb +1;{_dccf ._agb .AddToken (FmtTypeComma ,nil );};goto _febd ;_beb :_gbef =_edb +1;{_dccf ._agb .AddToken (FmtTypeDecimal ,nil );};goto _febd ;
_gafb :_gbef =_edb +1;{_dccf .nextFmt ();};goto _febd ;_cce :_gbef =_edb +1;{_dccf ._agb .AddToken (FmtTypeText ,nil );};goto _febd ;_ede :_gbef =_edb +1;{_dccf ._agb .AddToken (FmtTypeUnderscore ,nil );};goto _febd ;_bca :_gbef =_edb ;_edb --;{_dccf ._agb .AddToken (FmtTypeLiteral ,_bdf [_ecaf :_gbef ]);
};goto _febd ;_cdf :_gbef =_edb ;_edb --;{_dccf ._agb .AddToken (FmtTypeLiteral ,_bdf [_ecaf +1:_gbef -1]);};goto _febd ;_aeb :_gbef =_edb ;_edb --;{_dccf ._agb .AddToken (FmtTypeDigitOpt ,nil );};goto _febd ;_eabc :_gbef =_edb ;_edb --;{_dccf ._agb .AddToken (FmtTypeFraction ,_bdf [_ecaf :_gbef ]);
};goto _febd ;_aae :_gbef =_edb ;_edb --;{_dccf ._agb .AddToken (FmtTypePercent ,nil );};goto _febd ;_eeb :_gbef =_edb ;_edb --;{_dccf ._agb .AddToken (FmtTypeDate ,_bdf [_ecaf :_gbef ]);};goto _febd ;_cae :_gbef =_edb ;_edb --;{_dccf ._agb .AddToken (FmtTypeDigit ,nil );
};goto _febd ;_gag :_gbef =_edb ;_edb --;{_dccf ._agb .AddToken (FmtTypeTime ,_bdf [_ecaf :_gbef ]);};goto _febd ;_acd :_gbef =_edb ;_edb --;{};goto _febd ;_bfad :_gbef =_edb +1;{_dccf ._agb .IsExponential =true ;};goto _febd ;_faa :_gbef =_edb +1;{_dccf ._agb .AddToken (FmtTypeLiteral ,_bdf [_ecaf +1:_gbef ]);
};goto _febd ;_febd :_ecaf =0;if _edb ++;_edb ==_fbd {goto _dfddf ;};_fedg :_ecaf =_edb ;switch _bdf [_edb ]{case 34:goto _aggf ;case 35:goto _ffcg ;case 36:goto _bcd ;case 37:goto _aggc ;case 44:goto _fda ;case 46:goto _beb ;case 47:goto _aegbb ;case 48:goto _badd ;
case 58:goto _dbgb ;case 59:goto _gafb ;case 63:goto _dgadg ;case 64:goto _cce ;case 65:goto _ded ;case 69:goto _edeg ;case 71:goto _dffed ;case 91:goto _dbc ;case 92:goto _ddba ;case 95:goto _ede ;case 100:goto _aegbb ;case 104:goto _dbgb ;case 109:goto _aabd ;
case 115:goto _daff ;case 121:goto _efad ;};if 49<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _dcb ;};goto _ebfe ;_aggf :_gbef =_edb +1;_aada =20;goto _beef ;_beef :if _edb ++;_edb ==_fbd {goto _eafd ;};_ddeb :if _bdf [_edb ]==34{goto _aab ;};goto _bbf ;_bbf :if _edb ++;
_edb ==_fbd {goto _ggad ;};_efcb :if _bdf [_edb ]==34{goto _aab ;};goto _bbf ;_aab :_gbef =_edb +1;_aada =21;goto _gebg ;_gebg :if _edb ++;_edb ==_fbd {goto _egdd ;};_fbag :if _bdf [_edb ]==34{goto _bbf ;};goto _cdf ;_ffcg :_gbef =_edb +1;_aada =3;goto _afga ;
_afga :if _edb ++;_edb ==_fbd {goto _gad ;};_cbf :switch _bdf [_edb ]{case 35:goto _abc ;case 37:goto _abc ;case 44:goto _dggf ;case 47:goto _ggbb ;case 48:goto _abc ;case 63:goto _abc ;};goto _aeb ;_abc :if _edb ++;_edb ==_fbd {goto _egde ;};_daf :switch _bdf [_edb ]{case 35:goto _abc ;
case 37:goto _abc ;case 47:goto _ggbb ;case 48:goto _abc ;case 63:goto _abc ;};goto _ffce ;_ggbb :if _edb ++;_edb ==_fbd {goto _efcd ;};_ccgg :switch _bdf [_edb ]{case 35:goto _cacb ;case 37:goto _gbb ;case 48:goto _dec ;case 63:goto _cacb ;};if 49<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _dfd ;
};goto _ffce ;_cacb :_gbef =_edb +1;goto _fea ;_fea :if _edb ++;_edb ==_fbd {goto _cegc ;};_gfda :switch _bdf [_edb ]{case 35:goto _cacb ;case 37:goto _cacb ;case 44:goto _cacb ;case 46:goto _cacb ;case 48:goto _cacb ;case 63:goto _cacb ;case 65:goto _afb ;
};goto _eabc ;_afb :if _edb ++;_edb ==_fbd {goto _efcf ;};_bfg :switch _bdf [_edb ]{case 47:goto _cbea ;case 77:goto _cdfc ;};goto _agg ;_cbea :if _edb ++;_edb ==_fbd {goto _bcca ;};_ece :if _bdf [_edb ]==80{goto _dea ;};goto _agg ;_dea :_gbef =_edb +1;
goto _ddd ;_ddd :if _edb ++;_edb ==_fbd {goto _bbc ;};_fgb :if _bdf [_edb ]==65{goto _afb ;};goto _eabc ;_cdfc :if _edb ++;_edb ==_fbd {goto _bag ;};_gdgb :if _bdf [_edb ]==47{goto _fad ;};goto _agg ;_fad :if _edb ++;_edb ==_fbd {goto _ecg ;};_efed :if _bdf [_edb ]==80{goto _cced ;
};goto _agg ;_cced :if _edb ++;_edb ==_fbd {goto _cefc ;};_ceba :if _bdf [_edb ]==77{goto _dea ;};goto _agg ;_gbb :if _edb ++;_edb ==_fbd {goto _facd ;};_faf :switch _bdf [_edb ]{case 35:goto _deae ;case 37:goto _fgg ;case 63:goto _deae ;};if 48<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _dag ;
};goto _ffce ;_deae :_gbef =_edb +1;goto _dbgc ;_dbgc :if _edb ++;_edb ==_fbd {goto _dffc ;};_aegb :switch _bdf [_edb ]{case 35:goto _cacb ;case 37:goto _cea ;case 44:goto _cacb ;case 46:goto _cacb ;case 48:goto _cacb ;case 63:goto _cacb ;case 65:goto _afb ;
};goto _eabc ;_cea :if _edb ++;_edb ==_fbd {goto _adgd ;};_gfe :switch _bdf [_edb ]{case 35:goto _adb ;case 44:goto _adb ;case 46:goto _adb ;case 48:goto _adb ;case 63:goto _adb ;};goto _agg ;_adb :_gbef =_edb +1;goto _dceff ;_dceff :if _edb ++;_edb ==_fbd {goto _abe ;
};_dgf :switch _bdf [_edb ]{case 35:goto _adb ;case 44:goto _adb ;case 46:goto _adb ;case 48:goto _adb ;case 63:goto _adb ;case 65:goto _afb ;};goto _eabc ;_fgg :if _edb ++;_edb ==_fbd {goto _eabe ;};_bfe :if _bdf [_edb ]==37{goto _fgg ;};if 48<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _dag ;
};goto _ffce ;_dag :_gbef =_edb +1;_aada =13;goto _eba ;_eba :if _edb ++;_edb ==_fbd {goto _dgb ;};_agfd :switch _bdf [_edb ]{case 35:goto _cacb ;case 37:goto _aaea ;case 44:goto _cacb ;case 46:goto _cacb ;case 48:goto _cee ;case 63:goto _cacb ;case 65:goto _afb ;
};if 49<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _dag ;};goto _eabc ;_aaea :if _edb ++;_edb ==_fbd {goto _edfb ;};_bfga :switch _bdf [_edb ]{case 35:goto _adb ;case 37:goto _fgg ;case 44:goto _adb ;case 46:goto _adb ;case 63:goto _adb ;};if 48<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _dag ;
};goto _agg ;_cee :_gbef =_edb +1;goto _degb ;_degb :if _edb ++;_edb ==_fbd {goto _cgd ;};_eaf :switch _bdf [_edb ]{case 35:goto _cacb ;case 37:goto _cee ;case 44:goto _cacb ;case 46:goto _cacb ;case 48:goto _cee ;case 63:goto _cacb ;case 65:goto _afb ;
};if 49<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _dag ;};goto _eabc ;_dec :_gbef =_edb +1;goto _ffab ;_ffab :if _edb ++;_edb ==_fbd {goto _edagg ;};_cege :switch _bdf [_edb ]{case 35:goto _cacb ;case 37:goto _cee ;case 44:goto _cacb ;case 46:goto _cacb ;case 48:goto _dec ;
case 63:goto _cacb ;case 65:goto _afb ;};if 49<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _dfd ;};goto _eabc ;_dfd :_gbef =_edb +1;goto _edbf ;_edbf :if _edb ++;_edb ==_fbd {goto _fdad ;};_daa :switch _bdf [_edb ]{case 35:goto _cacb ;case 37:goto _dag ;case 44:goto _cacb ;
case 46:goto _cacb ;case 48:goto _dec ;case 63:goto _cacb ;case 65:goto _afb ;};if 49<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _dfd ;};goto _eabc ;_dggf :if _edb ++;_edb ==_fbd {goto _fcab ;};_dfdd :if _bdf [_edb ]==35{goto _fbda ;};goto _dde ;_aggc :_gbef =_edb +1;
_aada =8;goto _daed ;_daed :if _edb ++;_edb ==_fbd {goto _dagg ;};_bad :switch _bdf [_edb ]{case 35:goto _ffg ;case 37:goto _dcec ;case 48:goto _ggfa ;case 63:goto _ffg ;};if 49<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _gbd ;};goto _aae ;_ffg :if _edb ++;_edb ==_fbd {goto _bgcf ;
};_agea :switch _bdf [_edb ]{case 35:goto _ffg ;case 47:goto _ggbb ;case 48:goto _ffg ;case 63:goto _ffg ;};goto _eab ;_dcec :if _edb ++;_edb ==_fbd {goto _bgd ;};_eafb :if _bdf [_edb ]==37{goto _dcec ;};if 48<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _gbd ;
};goto _ffce ;_gbd :if _edb ++;_edb ==_fbd {goto _fdc ;};_fcee :switch _bdf [_edb ]{case 37:goto _dcec ;case 47:goto _ggbb ;};if 48<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _gbd ;};goto _ffce ;_ggfa :if _edb ++;_edb ==_fbd {goto _cbg ;};_fccf :switch _bdf [_edb ]{case 35:goto _ffg ;
case 37:goto _dcec ;case 47:goto _ggbb ;case 48:goto _ggfa ;case 63:goto _ffg ;};if 49<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _gbd ;};goto _eab ;_aegbb :_gbef =_edb +1;goto _gac ;_gac :if _edb ++;_edb ==_fbd {goto _bdg ;};_gfed :switch _bdf [_edb ]{case 47:goto _aegbb ;
case 100:goto _aegbb ;case 109:goto _aegbb ;case 121:goto _caef ;};goto _eeb ;_caef :if _edb ++;_edb ==_fbd {goto _ddda ;};_dbb :if _bdf [_edb ]==121{goto _aegbb ;};goto _befef ;_badd :_gbef =_edb +1;_aada =2;goto _fbad ;_fbad :if _edb ++;_edb ==_fbd {goto _ggcf ;
};_gba :switch _bdf [_edb ]{case 35:goto _abc ;case 37:goto _dad ;case 47:goto _ggbb ;case 48:goto _bcba ;case 63:goto _abc ;};if 49<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _ccf ;};goto _cae ;_dad :if _edb ++;_edb ==_fbd {goto _eede ;};_gff :switch _bdf [_edb ]{case 35:goto _abc ;
case 37:goto _dad ;case 47:goto _ggbb ;case 48:goto _dad ;case 63:goto _abc ;};if 49<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _gbd ;};goto _fcfd ;_bcba :if _edb ++;_edb ==_fbd {goto _bbcc ;};_aec :switch _bdf [_edb ]{case 35:goto _abc ;case 37:goto _dad ;case 47:goto _ggbb ;
case 48:goto _bcba ;case 63:goto _abc ;};if 49<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _ccf ;};goto _fcfd ;_ccf :if _edb ++;_edb ==_fbd {goto _aacc ;};_gga :switch _bdf [_edb ]{case 37:goto _gbd ;case 47:goto _ggbb ;};if 48<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _ccf ;
};goto _ffce ;_dcb :_gbef =_edb +1;_aada =20;goto _dbbb ;_dbbb :if _edb ++;_edb ==_fbd {goto _feac ;};_egf :switch _bdf [_edb ]{case 37:goto _gbd ;case 47:goto _ggbb ;};if 48<=_bdf [_edb ]&&_bdf [_edb ]<=57{goto _ccf ;};goto _bca ;_dbgb :_gbef =_edb +1;
_aada =15;goto _gbbd ;_gbbd :if _edb ++;_edb ==_fbd {goto _beed ;};_ccb :switch _bdf [_edb ]{case 58:goto _dbgb ;case 65:goto _ccfe ;case 104:goto _dbgb ;case 109:goto _dbgb ;case 115:goto _daff ;};goto _gag ;_ccfe :if _edb ++;_edb ==_fbd {goto _bdc ;};
_dfb :switch _bdf [_edb ]{case 47:goto _gbc ;case 77:goto _eaae ;};goto _ffce ;_gbc :if _edb ++;_edb ==_fbd {goto _ffd ;};_dffe :if _bdf [_edb ]==80{goto _dbgb ;};goto _ffce ;_eaae :if _edb ++;_edb ==_fbd {goto _egaa ;};_dbbf :if _bdf [_edb ]==47{goto _dca ;
};goto _ffce ;_dca :if _edb ++;_edb ==_fbd {goto _bbg ;};_acg :if _bdf [_edb ]==80{goto _aaf ;};goto _ffce ;_aaf :if _edb ++;_edb ==_fbd {goto _gge ;};_faag :if _bdf [_edb ]==77{goto _dbgb ;};goto _ffce ;_daff :_gbef =_edb +1;_aada =15;goto _ceaf ;_ceaf :if _edb ++;
_edb ==_fbd {goto _fceed ;};_acbb :switch _bdf [_edb ]{case 46:goto _gdgd ;case 58:goto _dbgb ;case 65:goto _ccfe ;case 104:goto _dbgb ;case 109:goto _dbgb ;case 115:goto _daff ;};goto _gag ;_gdgd :if _edb ++;_edb ==_fbd {goto _cdef ;};_abf :if _bdf [_edb ]==48{goto _gdcb ;
};goto _cef ;_gdcb :_gbef =_edb +1;_aada =15;goto _ddec ;_ddec :if _edb ++;_edb ==_fbd {goto _gef ;};_feca :switch _bdf [_edb ]{case 48:goto _dgce ;case 58:goto _dbgb ;case 65:goto _ccfe ;case 104:goto _dbgb ;case 109:goto _dbgb ;case 115:goto _daff ;};
goto _gag ;_dgce :_gbef =_edb +1;_aada =15;goto _fedb ;_fedb :if _edb ++;_edb ==_fbd {goto _dfbe ;};_fbe :switch _bdf [_edb ]{case 48:goto _dbgb ;case 58:goto _dbgb ;case 65:goto _ccfe ;case 104:goto _dbgb ;case 109:goto _dbgb ;case 115:goto _daff ;};goto _gag ;
_dgadg :_gbef =_edb +1;_aada =5;goto _dee ;_dee :if _edb ++;_edb ==_fbd {goto _aag ;};_cbfg :switch _bdf [_edb ]{case 35:goto _abc ;case 37:goto _abc ;case 47:goto _ggbb ;case 48:goto _abc ;case 63:goto _abc ;};goto _acd ;_ded :_gbef =_edb +1;_aada =20;
goto _fca ;_fca :if _edb ++;_edb ==_fbd {goto _fggd ;};_ddf :switch _bdf [_edb ]{case 47:goto _gbc ;case 77:goto _eaae ;};goto _bca ;_edeg :if _edb ++;_edb ==_fbd {goto _egef ;};_gda :switch _bdf [_edb ]{case 43:goto _bfad ;case 45:goto _bfad ;};goto _bca ;
_dffed :_gbef =_edb +1;goto _aca ;_aca :if _edb ++;_edb ==_fbd {goto _egag ;};_ccd :if _bdf [_edb ]==101{goto _adbb ;};goto _bca ;_adbb :if _edb ++;_edb ==_fbd {goto _dcd ;};_gdda :if _bdf [_edb ]==110{goto _gbaa ;};goto _geeg ;_gbaa :if _edb ++;_edb ==_fbd {goto _fafc ;
};_aedd :if _bdf [_edb ]==101{goto _bgb ;};goto _geeg ;_bgb :if _edb ++;_edb ==_fbd {goto _bfgaa ;};_egeb :if _bdf [_edb ]==114{goto _ddb ;};goto _geeg ;_ddb :if _edb ++;_edb ==_fbd {goto _cfe ;};_eafe :if _bdf [_edb ]==97{goto _gbce ;};goto _geeg ;_gbce :if _edb ++;
_edb ==_fbd {goto _cefg ;};_eea :if _bdf [_edb ]==108{goto _age ;};goto _geeg ;_dbc :_gbef =_edb +1;_aada =20;goto _edc ;_edc :if _edb ++;_edb ==_fbd {goto _ceae ;};_gdad :switch _bdf [_edb ]{case 104:goto _fcd ;case 109:goto _fcd ;case 115:goto _fcd ;
};goto _cfb ;_cfb :if _edb ++;_edb ==_fbd {goto _gfa ;};_babc :if _bdf [_edb ]==93{goto _edcc ;};goto _cfb ;_edcc :_gbef =_edb +1;_aada =18;goto _gfb ;_feaa :_gbef =_edb +1;_aada =16;goto _gfb ;_gfb :if _edb ++;_edb ==_fbd {goto _ddee ;};_dceb :if _bdf [_edb ]==93{goto _edcc ;
};goto _cfb ;_fcd :if _edb ++;_edb ==_fbd {goto _gaaee ;};_ecd :if _bdf [_edb ]==93{goto _feaa ;};goto _cfb ;_ddba :if _edb ++;_edb ==_fbd {goto _dgdg ;};_ega :goto _faa ;_aabd :_gbef =_edb +1;_aada =14;goto _acbd ;_acbd :if _edb ++;_edb ==_fbd {goto _bbdf ;
};_ffb :switch _bdf [_edb ]{case 47:goto _aegbb ;case 58:goto _dbgb ;case 65:goto _ccfe ;case 100:goto _aegbb ;case 104:goto _dbgb ;case 109:goto _aabd ;case 115:goto _daff ;case 121:goto _caef ;};goto _eeb ;_efad :if _edb ++;_edb ==_fbd {goto _bbcd ;};
_cba :if _bdf [_edb ]==121{goto _aegbb ;};goto _bca ;_ebgc :_dfddf :_fecd =34;goto _dbgf ;_eafd :_fecd =35;goto _dbgf ;_ggad :_fecd =0;goto _dbgf ;_egdd :_fecd =36;goto _dbgf ;_gad :_fecd =37;goto _dbgf ;_egde :_fecd =1;goto _dbgf ;_efcd :_fecd =2;goto _dbgf ;
_cegc :_fecd =38;goto _dbgf ;_efcf :_fecd =3;goto _dbgf ;_bcca :_fecd =4;goto _dbgf ;_bbc :_fecd =39;goto _dbgf ;_bag :_fecd =5;goto _dbgf ;_ecg :_fecd =6;goto _dbgf ;_cefc :_fecd =7;goto _dbgf ;_facd :_fecd =8;goto _dbgf ;_dffc :_fecd =40;goto _dbgf ;
_adgd :_fecd =9;goto _dbgf ;_abe :_fecd =41;goto _dbgf ;_eabe :_fecd =10;goto _dbgf ;_dgb :_fecd =42;goto _dbgf ;_edfb :_fecd =11;goto _dbgf ;_cgd :_fecd =43;goto _dbgf ;_edagg :_fecd =44;goto _dbgf ;_fdad :_fecd =45;goto _dbgf ;_fcab :_fecd =12;goto _dbgf ;
_dagg :_fecd =46;goto _dbgf ;_bgcf :_fecd =13;goto _dbgf ;_bgd :_fecd =14;goto _dbgf ;_fdc :_fecd =15;goto _dbgf ;_cbg :_fecd =16;goto _dbgf ;_bdg :_fecd =47;goto _dbgf ;_ddda :_fecd =17;goto _dbgf ;_ggcf :_fecd =48;goto _dbgf ;_eede :_fecd =18;goto _dbgf ;
_bbcc :_fecd =19;goto _dbgf ;_aacc :_fecd =20;goto _dbgf ;_feac :_fecd =49;goto _dbgf ;_beed :_fecd =50;goto _dbgf ;_bdc :_fecd =21;goto _dbgf ;_ffd :_fecd =22;goto _dbgf ;_egaa :_fecd =23;goto _dbgf ;_bbg :_fecd =24;goto _dbgf ;_gge :_fecd =25;goto _dbgf ;
_fceed :_fecd =51;goto _dbgf ;_cdef :_fecd =26;goto _dbgf ;_gef :_fecd =52;goto _dbgf ;_dfbe :_fecd =53;goto _dbgf ;_aag :_fecd =54;goto _dbgf ;_fggd :_fecd =55;goto _dbgf ;_egef :_fecd =56;goto _dbgf ;_egag :_fecd =57;goto _dbgf ;_dcd :_fecd =27;goto _dbgf ;
_fafc :_fecd =28;goto _dbgf ;_bfgaa :_fecd =29;goto _dbgf ;_cfe :_fecd =30;goto _dbgf ;_cefg :_fecd =31;goto _dbgf ;_ceae :_fecd =58;goto _dbgf ;_gfa :_fecd =32;goto _dbgf ;_ddee :_fecd =59;goto _dbgf ;_gaaee :_fecd =33;goto _dbgf ;_dgdg :_fecd =60;goto _dbgf ;
_bbdf :_fecd =61;goto _dbgf ;_bbcd :_fecd =62;goto _dbgf ;_dbgf :{};if _edb ==_cgg {switch _fecd {case 35:goto _bca ;case 0:goto _ffce ;case 36:goto _cdf ;case 37:goto _aeb ;case 1:goto _ffce ;case 2:goto _ffce ;case 38:goto _eabc ;case 3:goto _agg ;case 4:goto _agg ;
case 39:goto _eabc ;case 5:goto _agg ;case 6:goto _agg ;case 7:goto _agg ;case 8:goto _ffce ;case 40:goto _eabc ;case 9:goto _agg ;case 41:goto _eabc ;case 10:goto _ffce ;case 42:goto _eabc ;case 11:goto _agg ;case 43:goto _eabc ;case 44:goto _eabc ;case 45:goto _eabc ;
case 12:goto _dde ;case 46:goto _aae ;case 13:goto _eab ;case 14:goto _ffce ;case 15:goto _ffce ;case 16:goto _eab ;case 47:goto _eeb ;case 17:goto _befef ;case 48:goto _cae ;case 18:goto _fcfd ;case 19:goto _fcfd ;case 20:goto _ffce ;case 49:goto _bca ;
case 50:goto _gag ;case 21:goto _ffce ;case 22:goto _ffce ;case 23:goto _ffce ;case 24:goto _ffce ;case 25:goto _ffce ;case 51:goto _gag ;case 26:goto _cef ;case 52:goto _gag ;case 53:goto _gag ;case 54:goto _acd ;case 55:goto _bca ;case 56:goto _bca ;
case 57:goto _bca ;case 27:goto _geeg ;case 28:goto _geeg ;case 29:goto _geeg ;case 30:goto _geeg ;case 31:goto _geeg ;case 58:goto _bca ;case 32:goto _ffce ;case 59:goto _ffce ;case 33:goto _geeg ;case 60:goto _bca ;case 61:goto _eeb ;case 62:goto _bca ;
};};};if _ecaf > 0{copy (_bdf [0:],_bdf [_ecaf :]);};};_ =_cgg ;if _fecd ==_gbe {_b .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_ag ,_ :=_dc .ParseFloat (v ,64);return Number (_ag ,f );};return String (v ,f );};const _cff int =34;func (_egg *Lexer )nextFmt (){_egg ._efea =append (_egg ._efea ,_egg ._agb );_egg ._agb =Format {}};
func _ee (_cb ,_ccad float64 ,_edag Format )[]byte {if len (_edag .Whole )==0{return nil ;};_gee :=_f .Date (1899,12,30,0,0,0,0,_f .UTC );_bee :=_gee .Add (_f .Duration (_ccad *float64 (24*_f .Hour )));_bee =_ced (_bee );_fdeb :=_dc .AppendFloat (nil ,_cb ,'f',-1,64);
_dga :=make ([]byte ,0,len (_fdeb ));_dgad :=0;_dcc :=1;_dcf :for _eed :=len (_edag .Whole )-1;_eed >=0;_eed --{_def :=len (_fdeb )-1-_dgad ;_bb :=_edag .Whole [_eed ];switch _bb .Type {case FmtTypeDigit :if _def >=0{_dga =append (_dga ,_fdeb [_def ]);
_dgad ++;_dcc =_eed ;}else {_dga =append (_dga ,'0');};case FmtTypeDigitOpt :if _def >=0{_dga =append (_dga ,_fdeb [_def ]);_dgad ++;_dcc =_eed ;}else {for _ae :=_eed ;_ae >=0;_ae --{_eg :=_edag .Whole [_ae ];if _eg .Type ==FmtTypeLiteral {_dga =append (_dga ,_eg .Literal );
};};break _dcf ;};case FmtTypeDollar :for _feg :=_dgad ;_feg < len (_fdeb );_feg ++{_dga =append (_dga ,_fdeb [len (_fdeb )-1-_feg ]);_dgad ++;};_dga =append (_dga ,'$');case FmtTypeComma :if !_edag ._gc {_dga =append (_dga ,',');};case FmtTypeLiteral :_dga =append (_dga ,_bb .Literal );
case FmtTypeDate :_dga =append (_dga ,_ga (_ead (_bee ,_bb .DateTime ))...);case FmtTypeTime :_dga =append (_dga ,_ga (_cbe (_bee ,_ccad ,_bb .DateTime ))...);default:_b .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_bb );
};};_cdb :=_ga (_dga );if _dgad < len (_fdeb )&&(_dgad !=0||_edag ._fa ){_dgade :=len (_fdeb )-_dgad ;_bcb :=make ([]byte ,len (_cdb )+_dgade );copy (_bcb ,_cdb [0:_dcc ]);copy (_bcb [_dcc :],_fdeb [0:]);copy (_bcb [_dcc +_dgade :],_cdb [_dcc :]);_cdb =_bcb ;
};if _edag ._gc {_fab :=_cca .Buffer {};_cbd :=0;for _aga :=len (_cdb )-1;_aga >=0;_aga --{if !(_cdb [_aga ]>='0'&&_cdb [_aga ]<='9'){_cbd ++;}else {break ;};};for _egc :=0;_egc < len (_cdb );_egc ++{_bceb :=(len (_cdb )-_egc -_cbd );if _bceb %3==0&&_bceb !=0&&_egc !=0{_fab .WriteByte (',');
};_fab .WriteByte (_cdb [_egc ]);};_cdb =_fab .Bytes ();};return _cdb ;};var _ca =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};func Parse (s string )[]Format {_dgd :=Lexer {};_dgd .Lex (_c .NewReader (s ));_dgd ._efea =append (_dgd ._efea ,_dgd ._agb );
return _dgd ._efea ;};func _aa (_ccg []byte )[]byte {_ggg :=len (_ccg );_befc :=false ;_bcc :=false ;for _fcc :=len (_ccg )-1;_fcc >=0;_fcc --{if _ccg [_fcc ]=='0'&&!_bcc &&!_befc {_ggg =_fcc ;}else if _ccg [_fcc ]=='.'{_befc =true ;}else {_bcc =true ;
};};if _befc &&_bcc {if _ccg [_ggg -1]=='.'{_ggg --;};return _ccg [0:_ggg ];};return _ccg ;};const _befe int =-1;func _cbe (_efdf _f .Time ,_aff float64 ,_bgc string )[]byte {_fg :=[]byte {};_gaa :=0;for _baf :=0;_baf < len (_bgc );_baf ++{var _bfbg string ;
if _bgc [_baf ]==':'{_bfbg =string (_bgc [_gaa :_baf ]);_gaa =_baf +1;}else if _baf ==len (_bgc )-1{_bfbg =string (_bgc [_gaa :_baf +1]);}else {continue ;};switch _bfbg {case "\u0064":_fg =_efdf .AppendFormat (_fg ,"\u0032");case "\u0068":_fg =_efdf .AppendFormat (_fg ,"\u0033");
case "\u0068\u0068":_fg =_efdf .AppendFormat (_fg ,"\u0031\u0035");case "\u006d":_fg =_efdf .AppendFormat (_fg ,"\u0034");case "\u006d\u006d":_fg =_efdf .AppendFormat (_fg ,"\u0030\u0034");case "\u0073":_fg =_efdf .Round (_f .Second ).AppendFormat (_fg ,"\u0035");
case "\u0073\u002e\u0030":_fg =_efdf .Round (_f .Second /10).AppendFormat (_fg ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_fg =_efdf .Round (_f .Second /100).AppendFormat (_fg ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_fg =_efdf .Round (_f .Second /1000).AppendFormat (_fg ,"\u0035\u002e\u00300\u0030");
case "\u0073\u0073":_fg =_efdf .Round (_f .Second ).AppendFormat (_fg ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_fg =_efdf .Round (_f .Second /10).AppendFormat (_fg ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_fg =_efdf .Round (_f .Second /100).AppendFormat (_fg ,"\u0030\u0035\u002e0\u0030");
case "\u0073\u0073\u002e\u0030\u0030\u0030":_fg =_efdf .Round (_f .Second /1000).AppendFormat (_fg ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_fg =_efdf .AppendFormat (_fg ,"\u0050\u004d");case "\u005b\u0068\u005d":_fg =_dc .AppendInt (_fg ,int64 (_aff *24),10);
case "\u005b\u006d\u005d":_fg =_dc .AppendInt (_fg ,int64 (_aff *24*60),10);case "\u005b\u0073\u005d":_fg =_dc .AppendInt (_fg ,int64 (_aff *24*60*60),10);case "":default:_b .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_bfbg );
};if _bgc [_baf ]==':'{_fg =append (_fg ,':');};};return _fg ;};func _ead (_geea _f .Time ,_fcb string )[]byte {_dcfa :=[]byte {};_ggc :=0;for _dge :=0;_dge < len (_fcb );_dge ++{var _ec string ;if _fcb [_dge ]=='/'{_ec =string (_fcb [_ggc :_dge ]);_ggc =_dge +1;
}else if _dge ==len (_fcb )-1{_ec =string (_fcb [_ggc :_dge +1]);}else {continue ;};switch _ec {case "\u0079\u0079":_dcfa =_geea .AppendFormat (_dcfa ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_dcfa =_geea .AppendFormat (_dcfa ,"\u0032\u0030\u0030\u0036");
case "\u006d":_dcfa =_geea .AppendFormat (_dcfa ,"\u0031");case "\u006d\u006d":_dcfa =_geea .AppendFormat (_dcfa ,"\u0030\u0031");case "\u006d\u006d\u006d":_dcfa =_geea .AppendFormat (_dcfa ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_dcfa =_geea .AppendFormat (_dcfa ,"\u004aa\u006e\u0075\u0061\u0072\u0079");
case "\u006d\u006d\u006dm\u006d":switch _geea .Month (){case _f .January ,_f .July ,_f .June :_dcfa =append (_dcfa ,'J');case _f .February :_dcfa =append (_dcfa ,'M');case _f .March ,_f .May :_dcfa =append (_dcfa ,'M');case _f .April ,_f .August :_dcfa =append (_dcfa ,'A');
case _f .September :_dcfa =append (_dcfa ,'S');case _f .October :_dcfa =append (_dcfa ,'O');case _f .November :_dcfa =append (_dcfa ,'N');case _f .December :_dcfa =append (_dcfa ,'D');};case "\u0064":_dcfa =_geea .AppendFormat (_dcfa ,"\u0032");case "\u0064\u0064":_dcfa =_geea .AppendFormat (_dcfa ,"\u0030\u0032");
case "\u0064\u0064\u0064":_dcfa =_geea .AppendFormat (_dcfa ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_dcfa =_geea .AppendFormat (_dcfa ,"\u004d\u006f\u006e\u0064\u0061\u0079");default:_b .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_ec );
};if _fcb [_dge ]=='/'{_dcfa =append (_dcfa ,'/');};};return _dcfa ;};

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};