//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_ed "bytes";_d "fmt";_da "github.com/unidoc/unioffice/v2/common/logger";_c "io";_cb "math";_bg "strconv";_e "strings";_b "time";);

// AddToken adds a format token to the format.
func (_eef *Format )AddToken (t FmtType ,l []byte ){if _eef ._f {_eef ._f =false ;return ;};switch t {case FmtTypeDecimal :_eef ._bd =true ;case FmtTypeUnderscore :_eef ._f =true ;case FmtTypeText :_eef .Whole =append (_eef .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_eef .Whole =append (_eef .Whole ,Token {Type :t ,DateTime :string (l )});
case FmtTypePercent :_eef ._ge =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_gg :=range l {if _eef .IsExponential {_eef .Exponent =append (_eef .Exponent ,Token {Type :t ,Literal :_gg });
}else if !_eef ._bd {_eef .Whole =append (_eef .Whole ,Token {Type :t ,Literal :_gg });}else {_eef .Fractional =append (_eef .Fractional ,Token {Type :t ,Literal :_gg });};};case FmtTypeDigitOptThousands :_eef ._eec =true ;case FmtTypeFraction :_fa :=_e .Split (string (l ),"\u002f");
if len (_fa )==2{_eef ._ac =true ;_eef ._ebg ,_ =_bg .ParseInt (_fa [1],10,64);for _ ,_dc :=range _fa [1]{if _dc =='?'||_dc =='0'{_eef ._cf ++;};};};default:_da .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );
};};func (_edb *Lexer )nextFmt (){_edb ._dfe =append (_edb ._dfe ,_edb ._ccd );_edb ._ccd =Format {}};const _eb ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";


// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_ac bool ;_ge bool ;_db bool ;_eec bool ;_f bool ;_bd bool ;_ebg int64 ;_cf int ;};func Parse (s string )[]Format {_efa :=Lexer {};_efa .Lex (_e .NewReader (s ));
_efa ._dfe =append (_efa ._dfe ,_efa ._ccd );return _efa ._dfe ;};func _ceae (_def _b .Time ,_cc float64 ,_dbd string )[]byte {_egdg :=[]byte {};_cgg :=0;for _fbf :=0;_fbf < len (_dbd );_fbf ++{var _dae string ;if _dbd [_fbf ]==':'{_dae =string (_dbd [_cgg :_fbf ]);
_cgg =_fbf +1;}else if _fbf ==len (_dbd )-1{_dae =string (_dbd [_cgg :_fbf +1]);}else {continue ;};switch _dae {case "\u0064":_egdg =_def .AppendFormat (_egdg ,"\u0032");case "\u0068":_egdg =_def .AppendFormat (_egdg ,"\u0033");case "\u0068\u0068":_egdg =_def .AppendFormat (_egdg ,"\u0031\u0035");
case "\u006d":_egdg =_def .AppendFormat (_egdg ,"\u0034");case "\u006d\u006d":_egdg =_def .AppendFormat (_egdg ,"\u0030\u0034");case "\u0073":_egdg =_def .Round (_b .Second ).AppendFormat (_egdg ,"\u0035");case "\u0073\u002e\u0030":_egdg =_def .Round (_b .Second /10).AppendFormat (_egdg ,"\u0035\u002e\u0030");
case "\u0073\u002e\u0030\u0030":_egdg =_def .Round (_b .Second /100).AppendFormat (_egdg ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_egdg =_def .Round (_b .Second /1000).AppendFormat (_egdg ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_egdg =_def .Round (_b .Second ).AppendFormat (_egdg ,"\u0030\u0035");
case "\u0073\u0073\u002e\u0030":_egdg =_def .Round (_b .Second /10).AppendFormat (_egdg ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_egdg =_def .Round (_b .Second /100).AppendFormat (_egdg ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_egdg =_def .Round (_b .Second /1000).AppendFormat (_egdg ,"\u0030\u0035\u002e\u0030\u0030\u0030");
case "\u0041\u004d\u002fP\u004d":_egdg =_def .AppendFormat (_egdg ,"\u0050\u004d");case "\u005b\u0068\u005d":_egdg =_bg .AppendInt (_egdg ,int64 (_cc *24),10);case "\u005b\u006d\u005d":_egdg =_bg .AppendInt (_egdg ,int64 (_cc *24*60),10);case "\u005b\u0073\u005d":_egdg =_bg .AppendInt (_egdg ,int64 (_cc *24*60*60),10);
case "":default:_da .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_dae );};if _dbd [_fbf ]==':'{_egdg =append (_egdg ,':');};};return _egdg ;
};func (_g FmtType )String ()string {if _g >=FmtType (len (_ee )-1){return _d .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_g );};return _eb [_ee [_g ]:_ee [_g +1]];};const _bbae int =0;func _cfa (_dea ,_ecb float64 ,_ddce Format )[]byte {if len (_ddce .Whole )==0{return nil ;
};_ddcd :=_b .Date (1899,12,30,0,0,0,0,_b .UTC );_ea :=_ddcd .Add (_b .Duration (_ecb *float64 (24*_b .Hour )));_ea =_adb (_ea );_gf :=_bg .AppendFloat (nil ,_dea ,'f',-1,64);_dee :=make ([]byte ,0,len (_gf ));_gbd :=0;_bgf :=1;_cee :for _geg :=len (_ddce .Whole )-1;
_geg >=0;_geg --{_bge :=len (_gf )-1-_gbd ;_ggd :=_ddce .Whole [_geg ];switch _ggd .Type {case FmtTypeDigit :if _bge >=0{_dee =append (_dee ,_gf [_bge ]);_gbd ++;_bgf =_geg ;}else {_dee =append (_dee ,'0');};case FmtTypeDigitOpt :if _bge >=0{_dee =append (_dee ,_gf [_bge ]);
_gbd ++;_bgf =_geg ;}else {for _cd :=_geg ;_cd >=0;_cd --{_geb :=_ddce .Whole [_cd ];if _geb .Type ==FmtTypeLiteral {_dee =append (_dee ,_geb .Literal );};};break _cee ;};case FmtTypeDollar :for _gfe :=_gbd ;_gfe < len (_gf );_gfe ++{_dee =append (_dee ,_gf [len (_gf )-1-_gfe ]);
_gbd ++;};_dee =append (_dee ,'$');case FmtTypeComma :if !_ddce ._eec {_dee =append (_dee ,',');};case FmtTypeLiteral :_dee =append (_dee ,_ggd .Literal );case FmtTypeDate :_dee =append (_dee ,_dad (_ffc (_ea ,_ggd .DateTime ))...);case FmtTypeTime :_dee =append (_dee ,_dad (_ceae (_ea ,_ecb ,_ggd .DateTime ))...);
default:_da .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_ggd );};};_ggg :=_dad (_dee );if _gbd < len (_gf )&&(_gbd !=0||_ddce ._bd ){_ecd :=len (_gf )-_gbd ;
_ebd :=make ([]byte ,len (_ggg )+_ecd );copy (_ebd ,_ggg [0:_bgf ]);copy (_ebd [_bgf :],_gf [0:]);copy (_ebd [_bgf +_ecd :],_ggg [_bgf :]);_ggg =_ebd ;};if _ddce ._eec {_cdb :=_ed .Buffer {};_fga :=0;for _ca :=len (_ggg )-1;_ca >=0;_ca --{if !(_ggg [_ca ]>='0'&&_ggg [_ca ]<='9'){_fga ++;
}else {break ;};};for _gfa :=0;_gfa < len (_ggg );_gfa ++{_abd :=(len (_ggg )-_gfa -_fga );if _abd %3==0&&_abd !=0&&_gfa !=0{_cdb .WriteByte (',');};_cdb .WriteByte (_ggg [_gfa ]);};_ggg =_cdb .Bytes ();};return _ggg ;};const _dadg int =34;type Lexer struct{_ccd Format ;
_dfe []Format ;};const _cge int =34;const _bde int =0;

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _cb .Abs (v )>=_ba ||_cb .Abs (v )<=_bb &&v !=0{return _adee (v );};_cec :=make ([]byte ,0,15);_cec =_bg .AppendFloat (_cec ,v ,'f',-1,64);if len (_cec )> 11{_ade :=_cec [11]-'0';if _ade >=5&&_ade <=9{_cec [10]++;
_cec =_cec [0:11];_cec =_edfa (_cec );};_cec =_cec [0:11];}else if len (_cec )==11{if _cec [len (_cec )-1]=='9'{_cec [len (_cec )-1]++;_cec =_edfa (_cec );};};_cec =_ded (_cec );return string (_cec );};func IsNumber (data string )(_gegd bool ){_gcad ,_afb ,_daf :=0,0,len (data );
_gffb :=len (data );_bbbf ,_daa ,_ceag :=0,0,0;_ =_daa ;_ =_ceag ;_ =_bbbf ;{_gcad =_bde ;_bbbf =0;_daa =0;_ceag =0;};{if _afb ==_daf {goto _ag ;};switch _gcad {case 0:goto _acb ;case 1:goto _deb ;case 2:goto _gba ;case 3:goto _gbaf ;case 4:goto _dedg ;
case 5:goto _dbdb ;case 6:goto _fcb ;case 7:goto _ggc ;};goto _bgg ;_eag :_daa =_afb ;_afb --;{_gegd =false ;};goto _cab ;_eaf :_daa =_afb ;_afb --;{_gegd =_daa ==len (data );};goto _cab ;_ffcd :_daa =_afb ;_afb --;{_gegd =_daa ==len (data );};goto _cab ;
_cde :switch _ceag {case 2:{_afb =(_daa )-1;_gegd =_daa ==len (data );};case 3:{_afb =(_daa )-1;_gegd =false ;};};goto _cab ;_cab :_bbbf =0;if _afb ++;_afb ==_daf {goto _bea ;};_acb :_bbbf =_afb ;switch data [_afb ]{case 43:goto _efg ;case 45:goto _efg ;
};if 48<=data [_afb ]&&data [_afb ]<=57{goto _abc ;};goto _acbf ;_acbf :if _afb ++;_afb ==_daf {goto _dgf ;};_deb :goto _acbf ;_efg :if _afb ++;_afb ==_daf {goto _caab ;};_gba :if 48<=data [_afb ]&&data [_afb ]<=57{goto _abc ;};goto _acbf ;_abc :if _afb ++;
_afb ==_daf {goto _beag ;};_gbaf :if data [_afb ]==46{goto _aec ;};if 48<=data [_afb ]&&data [_afb ]<=57{goto _abc ;};goto _acbf ;_aec :if _afb ++;_afb ==_daf {goto _fda ;};_dedg :if 48<=data [_afb ]&&data [_afb ]<=57{goto _gda ;};goto _acbf ;_gda :if _afb ++;
_afb ==_daf {goto _caf ;};_dbdb :if data [_afb ]==69{goto _egb ;};if 48<=data [_afb ]&&data [_afb ]<=57{goto _gda ;};goto _acbf ;_egb :if _afb ++;_afb ==_daf {goto _cfac ;};_fcb :switch data [_afb ]{case 43:goto _edd ;case 45:goto _edd ;};goto _acbf ;_edd :_daa =_afb +1;
_ceag =3;goto _dfb ;_gege :_daa =_afb +1;_ceag =2;goto _dfb ;_dfb :if _afb ++;_afb ==_daf {goto _caad ;};_ggc :if 48<=data [_afb ]&&data [_afb ]<=57{goto _gege ;};goto _acbf ;_bgg :_bea :_gcad =0;goto _ag ;_dgf :_gcad =1;goto _ag ;_caab :_gcad =2;goto _ag ;
_beag :_gcad =3;goto _ag ;_fda :_gcad =4;goto _ag ;_caf :_gcad =5;goto _ag ;_cfac :_gcad =6;goto _ag ;_caad :_gcad =7;goto _ag ;_ag :{};if _afb ==_gffb {switch _gcad {case 1:goto _eag ;case 2:goto _eag ;case 3:goto _eaf ;case 4:goto _eag ;case 5:goto _ffcd ;
case 6:goto _eag ;case 7:goto _cde ;};};};if _gcad ==_ccdc {return false ;};return ;};

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_fe :=Parse (f );if len (_fe )==1{return _dcb (v ,_fe [0],false );}else if len (_fe )> 1&&v < 0{return _dcb (v ,_fe [1],true );
}else if len (_fe )> 2&&v ==0{return _dcb (v ,_fe [2],false );};return _dcb (v ,_fe [0],false );};const _gee int =-1;func _dcb (_cea float64 ,_ff Format ,_be bool )string {if _ff ._db {return NumberGeneric (_cea );};_ffe :=make ([]byte ,0,20);_gb :=_cb .Signbit (_cea );
_ec :=_cb .Abs (_cea );_dbf :=int64 (0);_fg :=int64 (0);if _ff .IsExponential {for _ec >=10{_fg ++;_ec /=10;};for _ec < 1{_fg --;_ec *=10;};}else if _ff ._ge {_ec *=100;}else if _ff ._ac {if _ff ._ebg ==0{_ab :=_cb .Pow (10,float64 (_ff ._cf ));_bc ,_de :=1.0,1.0;
_ =_bc ;for _ddc :=1.0;_ddc < _ab ;_ddc ++{_ ,_dg :=_cb .Modf (_ec *float64 (_ddc ));if _dg < _de {_de =_dg ;_bc =_ddc ;if _dg ==0{break ;};};};_ff ._ebg =int64 (_bc );};_dbf =int64 (_ec *float64 (_ff ._ebg )+0.5);if len (_ff .Whole )> 0&&_dbf > _ff ._ebg {_dbf =int64 (_ec *float64 (_ff ._ebg ))%_ff ._ebg ;
_ec -=float64 (_dbf )/float64 (_ff ._ebg );}else {_ec -=float64 (_dbf )/float64 (_ff ._ebg );if _cb .Abs (_ec )< 1{_beb :=true ;for _ ,_aeb :=range _ff .Whole {if _aeb .Type ==FmtTypeDigitOpt {continue ;};if _aeb .Type ==FmtTypeLiteral &&_aeb .Literal ==' '{continue ;
};_beb =false ;};if _beb {_ff .Whole =nil ;};};};};_ef :=1;for _ ,_deg :=range _ff .Fractional {if _deg .Type ==FmtTypeDigit ||_deg .Type ==FmtTypeDigitOpt {_ef ++;};};_ec +=5*_cb .Pow10 (-_ef );_fge ,_afa :=_cb .Modf (_ec );_ffe =append (_ffe ,_cfa (_fge ,_cea ,_ff )...);
_ffe =append (_ffe ,_df (_afa ,_cea ,_ff )...);_ffe =append (_ffe ,_cbf (_fg ,_ff )...);if _ff ._ac {_ffe =_bg .AppendInt (_ffe ,_dbf ,10);_ffe =append (_ffe ,'/');_ffe =_bg .AppendInt (_ffe ,_ff ._ebg ,10);};if !_be &&_gb {return "\u002d"+string (_ffe );
};return string (_ffe );};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_ae ,_ :=_bg .ParseFloat (v ,64);return Number (_ae ,f );};return String (v ,f );};func _adb (_eege _b .Time )_b .Time {_eege =_eege .UTC ();return _b .Date (_eege .Year (),_eege .Month (),_eege .Day (),_eege .Hour (),_eege .Minute (),_eege .Second (),_eege .Nanosecond (),_b .Local );
};func _cbf (_faf int64 ,_cdc Format )[]byte {if !_cdc .IsExponential ||len (_cdc .Exponent )==0{return nil ;};_bba :=_bg .AppendInt (nil ,_eea (_faf ),10);_egd :=make ([]byte ,0,len (_bba )+2);_egd =append (_egd ,'E');if _faf >=0{_egd =append (_egd ,'+');
}else {_egd =append (_egd ,'-');_faf *=-1;};_caa :=0;_gd :for _baf :=len (_cdc .Exponent )-1;_baf >=0;_baf --{_ceaa :=len (_bba )-1-_caa ;_bgc :=_cdc .Exponent [_baf ];switch _bgc .Type {case FmtTypeDigit :if _ceaa >=0{_egd =append (_egd ,_bba [_ceaa ]);
_caa ++;}else {_egd =append (_egd ,'0');};case FmtTypeDigitOpt :if _ceaa >=0{_egd =append (_egd ,_bba [_ceaa ]);_caa ++;}else {for _gff :=_baf ;_gff >=0;_gff --{_abb :=_cdc .Exponent [_gff ];if _abb .Type ==FmtTypeLiteral {_egd =append (_egd ,_abb .Literal );
};};break _gd ;};case FmtTypeLiteral :_egd =append (_egd ,_bgc .Literal );default:_da .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_bgc );
};};if _caa < len (_bba ){_egd =append (_egd ,_bba [len (_bba )-_caa -1:_caa -1]...);};_dad (_egd [2:]);return _egd ;};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;
FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_af :=Parse (f );var _ad Format ;if len (_af )==1{_ad =_af [0];}else if len (_af )==4{_ad =_af [3];};_bad :=false ;for _ ,_dce :=range _ad .Whole {if _dce .Type ==FmtTypeText {_bad =true ;};};if !_bad {return v ;
};_aff :=_ed .Buffer {};for _ ,_cba :=range _ad .Whole {switch _cba .Type {case FmtTypeLiteral :_aff .WriteByte (_cba .Literal );case FmtTypeText :_aff .WriteString (v );};};return _aff .String ();};func _eea (_cfaa int64 )int64 {if _cfaa < 0{return -_cfaa ;
};return _cfaa ;};var _ee =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};const _fcc int =0;func _df (_eda ,_fea float64 ,_fd Format )[]byte {if len (_fd .Fractional )==0{return nil ;};_dac :=_bg .AppendFloat (nil ,_eda ,'f',-1,64);if len (_dac )> 2{_dac =_dac [2:];
}else {_dac =nil ;};_bga :=make ([]byte ,0,len (_dac ));_bga =append (_bga ,'.');_acg :=0;_gfd :for _gbb :=0;_gbb < len (_fd .Fractional );_gbb ++{_gfaa :=_gbb ;_egf :=_fd .Fractional [_gbb ];switch _egf .Type {case FmtTypeDigit :if _gfaa < len (_dac ){_bga =append (_bga ,_dac [_gfaa ]);
_acg ++;}else {_bga =append (_bga ,'0');};case FmtTypeDigitOpt :if _gfaa >=0{_bga =append (_bga ,_dac [_gfaa ]);_acg ++;}else {break _gfd ;};case FmtTypeLiteral :_bga =append (_bga ,_egf .Literal );default:_da .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_egf );
};};return _bga ;};const _bb =1e-10;func _ffc (_feee _b .Time ,_ebf string )[]byte {_adg :=[]byte {};_adf :=0;for _fc :=0;_fc < len (_ebf );_fc ++{var _bbb string ;if _ebf [_fc ]=='/'{_bbb =string (_ebf [_adf :_fc ]);_adf =_fc +1;}else if _fc ==len (_ebf )-1{_bbb =string (_ebf [_adf :_fc +1]);
}else {continue ;};switch _bbb {case "\u0079\u0079":_adg =_feee .AppendFormat (_adg ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_adg =_feee .AppendFormat (_adg ,"\u0032\u0030\u0030\u0036");case "\u006d":_adg =_feee .AppendFormat (_adg ,"\u0031");case "\u006d\u006d":_adg =_feee .AppendFormat (_adg ,"\u0030\u0031");
case "\u006d\u006d\u006d":_adg =_feee .AppendFormat (_adg ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_adg =_feee .AppendFormat (_adg ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _feee .Month (){case _b .January ,_b .July ,_b .June :_adg =append (_adg ,'J');
case _b .February :_adg =append (_adg ,'M');case _b .March ,_b .May :_adg =append (_adg ,'M');case _b .April ,_b .August :_adg =append (_adg ,'A');case _b .September :_adg =append (_adg ,'S');case _b .October :_adg =append (_adg ,'O');case _b .November :_adg =append (_adg ,'N');
case _b .December :_adg =append (_adg ,'D');};case "\u0064":_adg =_feee .AppendFormat (_adg ,"\u0032");case "\u0064\u0064":_adg =_feee .AppendFormat (_adg ,"\u0030\u0032");case "\u0064\u0064\u0064":_adg =_feee .AppendFormat (_adg ,"\u004d\u006f\u006e");
case "\u0064\u0064\u0064\u0064":_adg =_feee .AppendFormat (_adg ,"\u004d\u006f\u006e\u0064\u0061\u0079");default:_da .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_bbb );
};if _ebf [_fc ]=='/'{_adg =append (_adg ,'/');};};return _adg ;};func (_fab *Lexer )Lex (r _c .Reader ){_bcb ,_eeb ,_bggg :=0,0,0;_gcd :=-1;_cfb ,_eff ,_bcg :=0,0,0;_ =_eff ;_ =_bcg ;_gga :=1;_ =_gga ;_dec :=make ([]byte ,4096);_eebg :=false ;for !_eebg {_geef :=0;
if _cfb > 0{_geef =_eeb -_cfb ;};_eeb =0;_cfd ,_cdf :=r .Read (_dec [_geef :]);if _cfd ==0||_cdf !=nil {_eebg =true ;};_bggg =_cfd +_geef ;if _bggg < len (_dec ){_gcd =_bggg ;};{_bcb =_dadg ;_cfb =0;_eff =0;_bcg =0;};{if _eeb ==_bggg {goto _gbbe ;};switch _bcb {case 34:goto _dab ;
case 35:goto _gega ;case 0:goto _bac ;case 36:goto _bag ;case 37:goto _bf ;case 1:goto _gce ;case 2:goto _dafc ;case 38:goto _ccg ;case 3:goto _gegf ;case 4:goto _ggdf ;case 39:goto _fag ;case 5:goto _cfe ;case 6:goto _dde ;case 7:goto _edg ;case 8:goto _gec ;
case 40:goto _fac ;case 9:goto _fgab ;case 41:goto _fba ;case 10:goto _degf ;case 42:goto _cbd ;case 11:goto _adec ;case 43:goto _gfff ;case 44:goto _abaa ;case 45:goto _gdg ;case 12:goto _ecdc ;case 46:goto _edgf ;case 13:goto _efff ;case 14:goto _bgge ;
case 15:goto _gfg ;case 16:goto _cfcd ;case 47:goto _cdga ;case 17:goto _dca ;case 48:goto _aef ;case 18:goto _dddc ;case 19:goto _abeg ;case 20:goto _aed ;case 49:goto _gdff ;case 50:goto _dddg ;case 21:goto _eac ;case 22:goto _bebd ;case 23:goto _aga ;
case 24:goto _feac ;case 25:goto _cca ;case 51:goto _dcee ;case 26:goto _fde ;case 52:goto _aab ;case 53:goto _dgg ;case 54:goto _bbg ;case 55:goto _gfed ;case 56:goto _bgcf ;case 57:goto _eefg ;case 27:goto _fad ;case 28:goto _fcec ;case 29:goto _fccgd ;
case 30:goto _ccc ;case 31:goto _egce ;case 58:goto _acf ;case 32:goto _gaf ;case 59:goto _feed ;case 33:goto _ccdb ;case 60:goto _ebdd ;case 61:goto _bcc ;case 62:goto _ece ;};goto _ddec ;_egc :switch _bcg {case 2:{_eeb =(_eff )-1;_fab ._ccd .AddToken (FmtTypeDigit ,nil );
};case 3:{_eeb =(_eff )-1;_fab ._ccd .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_eeb =(_eff )-1;};case 8:{_eeb =(_eff )-1;_fab ._ccd .AddToken (FmtTypePercent ,nil );};case 13:{_eeb =(_eff )-1;_fab ._ccd .AddToken (FmtTypeFraction ,_dec [_cfb :_eff ]);
};case 14:{_eeb =(_eff )-1;_fab ._ccd .AddToken (FmtTypeDate ,_dec [_cfb :_eff ]);};case 15:{_eeb =(_eff )-1;_fab ._ccd .AddToken (FmtTypeTime ,_dec [_cfb :_eff ]);};case 16:{_eeb =(_eff )-1;_fab ._ccd .AddToken (FmtTypeTime ,_dec [_cfb :_eff ]);};case 18:{_eeb =(_eff )-1;
};case 20:{_eeb =(_eff )-1;_fab ._ccd .AddToken (FmtTypeLiteral ,_dec [_cfb :_eff ]);};case 21:{_eeb =(_eff )-1;_fab ._ccd .AddToken (FmtTypeLiteral ,_dec [_cfb +1:_eff -1]);};};goto _cgdd ;_eebd :_eeb =(_eff )-1;{_fab ._ccd .AddToken (FmtTypeFraction ,_dec [_cfb :_eff ]);
};goto _cgdd ;_cgee :_eeb =(_eff )-1;{_fab ._ccd .AddToken (FmtTypeDigitOpt ,nil );};goto _cgdd ;_fcg :_eff =_eeb +1;{_fab ._ccd .AddToken (FmtTypeDigitOptThousands ,nil );};goto _cgdd ;_ccdd :_eeb =(_eff )-1;{_fab ._ccd .AddToken (FmtTypePercent ,nil );
};goto _cgdd ;_abe :_eeb =(_eff )-1;{_fab ._ccd .AddToken (FmtTypeDate ,_dec [_cfb :_eff ]);};goto _cgdd ;_egbb :_eeb =(_eff )-1;{_fab ._ccd .AddToken (FmtTypeDigit ,nil );};goto _cgdd ;_dcf :_eeb =(_eff )-1;{_fab ._ccd .AddToken (FmtTypeTime ,_dec [_cfb :_eff ]);
};goto _cgdd ;_acge :_eeb =(_eff )-1;{_fab ._ccd .AddToken (FmtTypeLiteral ,_dec [_cfb :_eff ]);};goto _cgdd ;_ecf :_eff =_eeb +1;{_fab ._ccd ._db =true ;};goto _cgdd ;_badg :_eff =_eeb +1;{_fab ._ccd .AddToken (FmtTypeLiteral ,_dec [_cfb :_eff ]);};goto _cgdd ;
_ebda :_eff =_eeb +1;{_fab ._ccd .AddToken (FmtTypeDollar ,nil );};goto _cgdd ;_ceb :_eff =_eeb +1;{_fab ._ccd .AddToken (FmtTypeComma ,nil );};goto _cgdd ;_cae :_eff =_eeb +1;{_fab ._ccd .AddToken (FmtTypeDecimal ,nil );};goto _cgdd ;_cga :_eff =_eeb +1;
{_fab .nextFmt ();};goto _cgdd ;_caae :_eff =_eeb +1;{_fab ._ccd .AddToken (FmtTypeText ,nil );};goto _cgdd ;_bdd :_eff =_eeb +1;{_fab ._ccd .AddToken (FmtTypeUnderscore ,nil );};goto _cgdd ;_fce :_eff =_eeb ;_eeb --;{_fab ._ccd .AddToken (FmtTypeLiteral ,_dec [_cfb :_eff ]);
};goto _cgdd ;_fbd :_eff =_eeb ;_eeb --;{_fab ._ccd .AddToken (FmtTypeLiteral ,_dec [_cfb +1:_eff -1]);};goto _cgdd ;_efc :_eff =_eeb ;_eeb --;{_fab ._ccd .AddToken (FmtTypeDigitOpt ,nil );};goto _cgdd ;_bed :_eff =_eeb ;_eeb --;{_fab ._ccd .AddToken (FmtTypeFraction ,_dec [_cfb :_eff ]);
};goto _cgdd ;_efd :_eff =_eeb ;_eeb --;{_fab ._ccd .AddToken (FmtTypePercent ,nil );};goto _cgdd ;_dcd :_eff =_eeb ;_eeb --;{_fab ._ccd .AddToken (FmtTypeDate ,_dec [_cfb :_eff ]);};goto _cgdd ;_fggf :_eff =_eeb ;_eeb --;{_fab ._ccd .AddToken (FmtTypeDigit ,nil );
};goto _cgdd ;_dga :_eff =_eeb ;_eeb --;{_fab ._ccd .AddToken (FmtTypeTime ,_dec [_cfb :_eff ]);};goto _cgdd ;_aegc :_eff =_eeb ;_eeb --;{};goto _cgdd ;_bbe :_eff =_eeb +1;{_fab ._ccd .IsExponential =true ;};goto _cgdd ;_bgce :_eff =_eeb +1;{_fab ._ccd .AddToken (FmtTypeLiteral ,_dec [_cfb +1:_eff ]);
};goto _cgdd ;_cgdd :_cfb =0;if _eeb ++;_eeb ==_bggg {goto _agee ;};_dab :_cfb =_eeb ;switch _dec [_eeb ]{case 34:goto _fae ;case 35:goto _fca ;case 36:goto _ebda ;case 37:goto _dag ;case 44:goto _ceb ;case 46:goto _cae ;case 47:goto _cdg ;case 48:goto _gbad ;
case 58:goto _ebe ;case 59:goto _cga ;case 63:goto _deaa ;case 64:goto _caae ;case 65:goto _fdee ;case 69:goto _ggcg ;case 71:goto _bgggc ;case 91:goto _ced ;case 92:goto _fdd ;case 95:goto _bdd ;case 100:goto _cdg ;case 104:goto _ebe ;case 109:goto _gcag ;
case 115:goto _agae ;case 121:goto _defg ;};if 49<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _aae ;};goto _badg ;_fae :_eff =_eeb +1;_bcg =20;goto _ebgd ;_ebgd :if _eeb ++;_eeb ==_bggg {goto _ddbg ;};_gega :if _dec [_eeb ]==34{goto _dba ;};goto _gcb ;_gcb :if _eeb ++;
_eeb ==_bggg {goto _ggdfd ;};_bac :if _dec [_eeb ]==34{goto _dba ;};goto _gcb ;_dba :_eff =_eeb +1;_bcg =21;goto _fgb ;_fgb :if _eeb ++;_eeb ==_bggg {goto _ffdce ;};_bag :if _dec [_eeb ]==34{goto _gcb ;};goto _fbd ;_fca :_eff =_eeb +1;_bcg =3;goto _fabd ;
_fabd :if _eeb ++;_eeb ==_bggg {goto _feec ;};_bf :switch _dec [_eeb ]{case 35:goto _egg ;case 37:goto _egg ;case 44:goto _eed ;case 47:goto _aac ;case 48:goto _egg ;case 63:goto _egg ;};goto _efc ;_egg :if _eeb ++;_eeb ==_bggg {goto _dceg ;};_gce :switch _dec [_eeb ]{case 35:goto _egg ;
case 37:goto _egg ;case 47:goto _aac ;case 48:goto _egg ;case 63:goto _egg ;};goto _egc ;_aac :if _eeb ++;_eeb ==_bggg {goto _gced ;};_dafc :switch _dec [_eeb ]{case 35:goto _gdf ;case 37:goto _bgb ;case 48:goto _fcf ;case 63:goto _gdf ;};if 49<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _ggaa ;
};goto _egc ;_gdf :_eff =_eeb +1;goto _ffb ;_ffb :if _eeb ++;_eeb ==_bggg {goto _eega ;};_ccg :switch _dec [_eeb ]{case 35:goto _gdf ;case 37:goto _gdf ;case 44:goto _gdf ;case 46:goto _gdf ;case 48:goto _gdf ;case 63:goto _gdf ;case 65:goto _feef ;};goto _bed ;
_feef :if _eeb ++;_eeb ==_bggg {goto _cgac ;};_gegf :switch _dec [_eeb ]{case 47:goto _deae ;case 77:goto _efcg ;};goto _eebd ;_deae :if _eeb ++;_eeb ==_bggg {goto _acfd ;};_ggdf :if _dec [_eeb ]==80{goto _fccg ;};goto _eebd ;_fccg :_eff =_eeb +1;goto _bfa ;
_bfa :if _eeb ++;_eeb ==_bggg {goto _efgf ;};_fag :if _dec [_eeb ]==65{goto _feef ;};goto _bed ;_efcg :if _eeb ++;_eeb ==_bggg {goto _gffa ;};_cfe :if _dec [_eeb ]==47{goto _dcbc ;};goto _eebd ;_dcbc :if _eeb ++;_eeb ==_bggg {goto _cgf ;};_dde :if _dec [_eeb ]==80{goto _ffdc ;
};goto _eebd ;_ffdc :if _eeb ++;_eeb ==_bggg {goto _bgcfg ;};_edg :if _dec [_eeb ]==77{goto _fccg ;};goto _eebd ;_bgb :if _eeb ++;_eeb ==_bggg {goto _efdc ;};_gec :switch _dec [_eeb ]{case 35:goto _dcc ;case 37:goto _afg ;case 63:goto _dcc ;};if 48<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _agf ;
};goto _egc ;_dcc :_eff =_eeb +1;goto _aegf ;_aegf :if _eeb ++;_eeb ==_bggg {goto _affb ;};_fac :switch _dec [_eeb ]{case 35:goto _gdf ;case 37:goto _bddd ;case 44:goto _gdf ;case 46:goto _gdf ;case 48:goto _gdf ;case 63:goto _gdf ;case 65:goto _feef ;
};goto _bed ;_bddd :if _eeb ++;_eeb ==_bggg {goto _dbfd ;};_fgab :switch _dec [_eeb ]{case 35:goto _gffg ;case 44:goto _gffg ;case 46:goto _gffg ;case 48:goto _gffg ;case 63:goto _gffg ;};goto _eebd ;_gffg :_eff =_eeb +1;goto _bggf ;_bggf :if _eeb ++;_eeb ==_bggg {goto _eedf ;
};_fba :switch _dec [_eeb ]{case 35:goto _gffg ;case 44:goto _gffg ;case 46:goto _gffg ;case 48:goto _gffg ;case 63:goto _gffg ;case 65:goto _feef ;};goto _bed ;_afg :if _eeb ++;_eeb ==_bggg {goto _fed ;};_degf :if _dec [_eeb ]==37{goto _afg ;};if 48<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _agf ;
};goto _egc ;_agf :_eff =_eeb +1;_bcg =13;goto _bagb ;_bagb :if _eeb ++;_eeb ==_bggg {goto _dceed ;};_cbd :switch _dec [_eeb ]{case 35:goto _gdf ;case 37:goto _ffee ;case 44:goto _gdf ;case 46:goto _gdf ;case 48:goto _ga ;case 63:goto _gdf ;case 65:goto _feef ;
};if 49<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _agf ;};goto _bed ;_ffee :if _eeb ++;_eeb ==_bggg {goto _afbc ;};_adec :switch _dec [_eeb ]{case 35:goto _gffg ;case 37:goto _afg ;case 44:goto _gffg ;case 46:goto _gffg ;case 63:goto _gffg ;};if 48<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _agf ;
};goto _eebd ;_ga :_eff =_eeb +1;goto _aba ;_aba :if _eeb ++;_eeb ==_bggg {goto _cecb ;};_gfff :switch _dec [_eeb ]{case 35:goto _gdf ;case 37:goto _ga ;case 44:goto _gdf ;case 46:goto _gdf ;case 48:goto _ga ;case 63:goto _gdf ;case 65:goto _feef ;};if 49<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _agf ;
};goto _bed ;_fcf :_eff =_eeb +1;goto _cgeea ;_cgeea :if _eeb ++;_eeb ==_bggg {goto _fcfb ;};_abaa :switch _dec [_eeb ]{case 35:goto _gdf ;case 37:goto _ga ;case 44:goto _gdf ;case 46:goto _gdf ;case 48:goto _fcf ;case 63:goto _gdf ;case 65:goto _feef ;
};if 49<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _ggaa ;};goto _bed ;_ggaa :_eff =_eeb +1;goto _gdd ;_gdd :if _eeb ++;_eeb ==_bggg {goto _ggge ;};_gdg :switch _dec [_eeb ]{case 35:goto _gdf ;case 37:goto _agf ;case 44:goto _gdf ;case 46:goto _gdf ;case 48:goto _fcf ;
case 63:goto _gdf ;case 65:goto _feef ;};if 49<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _ggaa ;};goto _bed ;_eed :if _eeb ++;_eeb ==_bggg {goto _facb ;};_ecdc :if _dec [_eeb ]==35{goto _fcg ;};goto _cgee ;_dag :_eff =_eeb +1;_bcg =8;goto _eefa ;_eefa :if _eeb ++;
_eeb ==_bggg {goto _ccca ;};_edgf :switch _dec [_eeb ]{case 35:goto _ede ;case 37:goto _gggb ;case 48:goto _bda ;case 63:goto _ede ;};if 49<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _aaf ;};goto _efd ;_ede :if _eeb ++;_eeb ==_bggg {goto _agg ;};_efff :switch _dec [_eeb ]{case 35:goto _ede ;
case 47:goto _aac ;case 48:goto _ede ;case 63:goto _ede ;};goto _ccdd ;_gggb :if _eeb ++;_eeb ==_bggg {goto _faa ;};_bgge :if _dec [_eeb ]==37{goto _gggb ;};if 48<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _aaf ;};goto _egc ;_aaf :if _eeb ++;_eeb ==_bggg {goto _gfab ;
};_gfg :switch _dec [_eeb ]{case 37:goto _gggb ;case 47:goto _aac ;};if 48<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _aaf ;};goto _egc ;_bda :if _eeb ++;_eeb ==_bggg {goto _aad ;};_cfcd :switch _dec [_eeb ]{case 35:goto _ede ;case 37:goto _gggb ;case 47:goto _aac ;
case 48:goto _bda ;case 63:goto _ede ;};if 49<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _aaf ;};goto _ccdd ;_cdg :_eff =_eeb +1;goto _bcga ;_bcga :if _eeb ++;_eeb ==_bggg {goto _ddecf ;};_cdga :switch _dec [_eeb ]{case 47:goto _cdg ;case 100:goto _cdg ;case 109:goto _cdg ;
case 121:goto _age ;};goto _dcd ;_age :if _eeb ++;_eeb ==_bggg {goto _gfb ;};_dca :if _dec [_eeb ]==121{goto _cdg ;};goto _abe ;_gbad :_eff =_eeb +1;_bcg =2;goto _eagg ;_eagg :if _eeb ++;_eeb ==_bggg {goto _efge ;};_aef :switch _dec [_eeb ]{case 35:goto _egg ;
case 37:goto _gab ;case 47:goto _aac ;case 48:goto _bgee ;case 63:goto _egg ;};if 49<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _dge ;};goto _fggf ;_gab :if _eeb ++;_eeb ==_bggg {goto _ffed ;};_dddc :switch _dec [_eeb ]{case 35:goto _egg ;case 37:goto _gab ;
case 47:goto _aac ;case 48:goto _gab ;case 63:goto _egg ;};if 49<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _aaf ;};goto _egbb ;_bgee :if _eeb ++;_eeb ==_bggg {goto _cggf ;};_abeg :switch _dec [_eeb ]{case 35:goto _egg ;case 37:goto _gab ;case 47:goto _aac ;
case 48:goto _bgee ;case 63:goto _egg ;};if 49<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _dge ;};goto _egbb ;_dge :if _eeb ++;_eeb ==_bggg {goto _cag ;};_aed :switch _dec [_eeb ]{case 37:goto _aaf ;case 47:goto _aac ;};if 48<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _dge ;
};goto _egc ;_aae :_eff =_eeb +1;_bcg =20;goto _gcf ;_gcf :if _eeb ++;_eeb ==_bggg {goto _fgea ;};_gdff :switch _dec [_eeb ]{case 37:goto _aaf ;case 47:goto _aac ;};if 48<=_dec [_eeb ]&&_dec [_eeb ]<=57{goto _dge ;};goto _fce ;_ebe :_eff =_eeb +1;_bcg =15;
goto _ebc ;_ebc :if _eeb ++;_eeb ==_bggg {goto _cdbea ;};_dddg :switch _dec [_eeb ]{case 58:goto _ebe ;case 65:goto _bgdce ;case 104:goto _ebe ;case 109:goto _ebe ;case 115:goto _agae ;};goto _dga ;_bgdce :if _eeb ++;_eeb ==_bggg {goto _gceb ;};_eac :switch _dec [_eeb ]{case 47:goto _abcg ;
case 77:goto _edda ;};goto _egc ;_abcg :if _eeb ++;_eeb ==_bggg {goto _ecc ;};_bebd :if _dec [_eeb ]==80{goto _ebe ;};goto _egc ;_edda :if _eeb ++;_eeb ==_bggg {goto _dfbe ;};_aga :if _dec [_eeb ]==47{goto _ebfb ;};goto _egc ;_ebfb :if _eeb ++;_eeb ==_bggg {goto _efcd ;
};_feac :if _dec [_eeb ]==80{goto _cdbe ;};goto _egc ;_cdbe :if _eeb ++;_eeb ==_bggg {goto _effb ;};_cca :if _dec [_eeb ]==77{goto _ebe ;};goto _egc ;_agae :_eff =_eeb +1;_bcg =15;goto _caabe ;_caabe :if _eeb ++;_eeb ==_bggg {goto _eafb ;};_dcee :switch _dec [_eeb ]{case 46:goto _acgg ;
case 58:goto _ebe ;case 65:goto _bgdce ;case 104:goto _ebe ;case 109:goto _ebe ;case 115:goto _agae ;};goto _dga ;_acgg :if _eeb ++;_eeb ==_bggg {goto _gbf ;};_fde :if _dec [_eeb ]==48{goto _gfc ;};goto _dcf ;_gfc :_eff =_eeb +1;_bcg =15;goto _ggag ;_ggag :if _eeb ++;
_eeb ==_bggg {goto _acd ;};_aab :switch _dec [_eeb ]{case 48:goto _bdb ;case 58:goto _ebe ;case 65:goto _bgdce ;case 104:goto _ebe ;case 109:goto _ebe ;case 115:goto _agae ;};goto _dga ;_bdb :_eff =_eeb +1;_bcg =15;goto _cfcg ;_cfcg :if _eeb ++;_eeb ==_bggg {goto _cbc ;
};_dgg :switch _dec [_eeb ]{case 48:goto _ebe ;case 58:goto _ebe ;case 65:goto _bgdce ;case 104:goto _ebe ;case 109:goto _ebe ;case 115:goto _agae ;};goto _dga ;_deaa :_eff =_eeb +1;_bcg =5;goto _agd ;_agd :if _eeb ++;_eeb ==_bggg {goto _fbdb ;};_bbg :switch _dec [_eeb ]{case 35:goto _egg ;
case 37:goto _egg ;case 47:goto _aac ;case 48:goto _egg ;case 63:goto _egg ;};goto _aegc ;_fdee :_eff =_eeb +1;_bcg =20;goto _efb ;_efb :if _eeb ++;_eeb ==_bggg {goto _fdf ;};_gfed :switch _dec [_eeb ]{case 47:goto _abcg ;case 77:goto _edda ;};goto _fce ;
_ggcg :if _eeb ++;_eeb ==_bggg {goto _egbe ;};_bgcf :switch _dec [_eeb ]{case 43:goto _bbe ;case 45:goto _bbe ;};goto _fce ;_bgggc :_eff =_eeb +1;goto _aea ;_aea :if _eeb ++;_eeb ==_bggg {goto _dcdg ;};_eefg :if _dec [_eeb ]==101{goto _bcgf ;};goto _fce ;
_bcgf :if _eeb ++;_eeb ==_bggg {goto _gea ;};_fad :if _dec [_eeb ]==110{goto _dfd ;};goto _acge ;_dfd :if _eeb ++;_eeb ==_bggg {goto _efdg ;};_fcec :if _dec [_eeb ]==101{goto _fbb ;};goto _acge ;_fbb :if _eeb ++;_eeb ==_bggg {goto _cbfb ;};_fccgd :if _dec [_eeb ]==114{goto _dgc ;
};goto _acge ;_dgc :if _eeb ++;_eeb ==_bggg {goto _dfc ;};_ccc :if _dec [_eeb ]==97{goto _fgae ;};goto _acge ;_fgae :if _eeb ++;_eeb ==_bggg {goto _gbe ;};_egce :if _dec [_eeb ]==108{goto _ecf ;};goto _acge ;_ced :_eff =_eeb +1;_bcg =20;goto _gbg ;_gbg :if _eeb ++;
_eeb ==_bggg {goto _egbf ;};_acf :switch _dec [_eeb ]{case 104:goto _feg ;case 109:goto _feg ;case 115:goto _feg ;};goto _gcea ;_gcea :if _eeb ++;_eeb ==_bggg {goto _feda ;};_gaf :if _dec [_eeb ]==93{goto _acbg ;};goto _gcea ;_acbg :_eff =_eeb +1;_bcg =18;
goto _badc ;_bfaf :_eff =_eeb +1;_bcg =16;goto _badc ;_badc :if _eeb ++;_eeb ==_bggg {goto _adeb ;};_feed :if _dec [_eeb ]==93{goto _acbg ;};goto _gcea ;_feg :if _eeb ++;_eeb ==_bggg {goto _adgc ;};_ccdb :if _dec [_eeb ]==93{goto _bfaf ;};goto _gcea ;_fdd :if _eeb ++;
_eeb ==_bggg {goto _eaa ;};_ebdd :goto _bgce ;_gcag :_eff =_eeb +1;_bcg =14;goto _ged ;_ged :if _eeb ++;_eeb ==_bggg {goto _bcf ;};_bcc :switch _dec [_eeb ]{case 47:goto _cdg ;case 58:goto _ebe ;case 65:goto _bgdce ;case 100:goto _cdg ;case 104:goto _ebe ;
case 109:goto _gcag ;case 115:goto _agae ;case 121:goto _age ;};goto _dcd ;_defg :if _eeb ++;_eeb ==_bggg {goto _bfc ;};_ece :if _dec [_eeb ]==121{goto _cdg ;};goto _fce ;_ddec :_agee :_bcb =34;goto _gbbe ;_ddbg :_bcb =35;goto _gbbe ;_ggdfd :_bcb =0;goto _gbbe ;
_ffdce :_bcb =36;goto _gbbe ;_feec :_bcb =37;goto _gbbe ;_dceg :_bcb =1;goto _gbbe ;_gced :_bcb =2;goto _gbbe ;_eega :_bcb =38;goto _gbbe ;_cgac :_bcb =3;goto _gbbe ;_acfd :_bcb =4;goto _gbbe ;_efgf :_bcb =39;goto _gbbe ;_gffa :_bcb =5;goto _gbbe ;_cgf :_bcb =6;
goto _gbbe ;_bgcfg :_bcb =7;goto _gbbe ;_efdc :_bcb =8;goto _gbbe ;_affb :_bcb =40;goto _gbbe ;_dbfd :_bcb =9;goto _gbbe ;_eedf :_bcb =41;goto _gbbe ;_fed :_bcb =10;goto _gbbe ;_dceed :_bcb =42;goto _gbbe ;_afbc :_bcb =11;goto _gbbe ;_cecb :_bcb =43;goto _gbbe ;
_fcfb :_bcb =44;goto _gbbe ;_ggge :_bcb =45;goto _gbbe ;_facb :_bcb =12;goto _gbbe ;_ccca :_bcb =46;goto _gbbe ;_agg :_bcb =13;goto _gbbe ;_faa :_bcb =14;goto _gbbe ;_gfab :_bcb =15;goto _gbbe ;_aad :_bcb =16;goto _gbbe ;_ddecf :_bcb =47;goto _gbbe ;_gfb :_bcb =17;
goto _gbbe ;_efge :_bcb =48;goto _gbbe ;_ffed :_bcb =18;goto _gbbe ;_cggf :_bcb =19;goto _gbbe ;_cag :_bcb =20;goto _gbbe ;_fgea :_bcb =49;goto _gbbe ;_cdbea :_bcb =50;goto _gbbe ;_gceb :_bcb =21;goto _gbbe ;_ecc :_bcb =22;goto _gbbe ;_dfbe :_bcb =23;goto _gbbe ;
_efcd :_bcb =24;goto _gbbe ;_effb :_bcb =25;goto _gbbe ;_eafb :_bcb =51;goto _gbbe ;_gbf :_bcb =26;goto _gbbe ;_acd :_bcb =52;goto _gbbe ;_cbc :_bcb =53;goto _gbbe ;_fbdb :_bcb =54;goto _gbbe ;_fdf :_bcb =55;goto _gbbe ;_egbe :_bcb =56;goto _gbbe ;_dcdg :_bcb =57;
goto _gbbe ;_gea :_bcb =27;goto _gbbe ;_efdg :_bcb =28;goto _gbbe ;_cbfb :_bcb =29;goto _gbbe ;_dfc :_bcb =30;goto _gbbe ;_gbe :_bcb =31;goto _gbbe ;_egbf :_bcb =58;goto _gbbe ;_feda :_bcb =32;goto _gbbe ;_adeb :_bcb =59;goto _gbbe ;_adgc :_bcb =33;goto _gbbe ;
_eaa :_bcb =60;goto _gbbe ;_bcf :_bcb =61;goto _gbbe ;_bfc :_bcb =62;goto _gbbe ;_gbbe :{};if _eeb ==_gcd {switch _bcb {case 35:goto _fce ;case 0:goto _egc ;case 36:goto _fbd ;case 37:goto _efc ;case 1:goto _egc ;case 2:goto _egc ;case 38:goto _bed ;case 3:goto _eebd ;
case 4:goto _eebd ;case 39:goto _bed ;case 5:goto _eebd ;case 6:goto _eebd ;case 7:goto _eebd ;case 8:goto _egc ;case 40:goto _bed ;case 9:goto _eebd ;case 41:goto _bed ;case 10:goto _egc ;case 42:goto _bed ;case 11:goto _eebd ;case 43:goto _bed ;case 44:goto _bed ;
case 45:goto _bed ;case 12:goto _cgee ;case 46:goto _efd ;case 13:goto _ccdd ;case 14:goto _egc ;case 15:goto _egc ;case 16:goto _ccdd ;case 47:goto _dcd ;case 17:goto _abe ;case 48:goto _fggf ;case 18:goto _egbb ;case 19:goto _egbb ;case 20:goto _egc ;
case 49:goto _fce ;case 50:goto _dga ;case 21:goto _egc ;case 22:goto _egc ;case 23:goto _egc ;case 24:goto _egc ;case 25:goto _egc ;case 51:goto _dga ;case 26:goto _dcf ;case 52:goto _dga ;case 53:goto _dga ;case 54:goto _aegc ;case 55:goto _fce ;case 56:goto _fce ;
case 57:goto _fce ;case 27:goto _acge ;case 28:goto _acge ;case 29:goto _acge ;case 30:goto _acge ;case 31:goto _acge ;case 58:goto _fce ;case 32:goto _egc ;case 59:goto _egc ;case 33:goto _acge ;case 60:goto _fce ;case 61:goto _dcd ;case 62:goto _fce ;
};};};if _cfb > 0{copy (_dec [0:],_dec [_cfb :]);};};_ =_gcd ;if _bcb ==_ccdc {_da .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};func _adee (_fbe float64 )string {_fee :=_bg .FormatFloat (_fbe ,'E',-1,64);
_acgd :=_bg .FormatFloat (_fbe ,'E',5,64);if len (_fee )< len (_acgd ){return _bg .FormatFloat (_fbe ,'E',2,64);};return _acgd ;};

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};func _dad (_eeg []byte )[]byte {for _ebga :=0;_ebga < len (_eeg )/2;_ebga ++{_ega :=len (_eeg )-1-_ebga ;_eeg [_ebga ],_eeg [_ega ]=_eeg [_ega ],_eeg [_ebga ];};return _eeg ;};const _ddd int =34;


// FmtType is the type of a format token.
//
//go:generate stringer -type=FmtType
type FmtType byte ;func _edfa (_gfef []byte )[]byte {for _beg :=len (_gfef )-1;_beg > 0;_beg --{if _gfef [_beg ]=='9'+1{_gfef [_beg ]='0';if _gfef [_beg -1]=='.'{_beg --;};_gfef [_beg -1]++;};};if _gfef [0]=='9'+1{_gfef [0]='0';copy (_gfef [1:],_gfef [0:]);
_gfef [0]='1';};return _gfef ;};const _ccdc int =-1;const _ba =1e11;func _ded (_aa []byte )[]byte {_gca :=len (_aa );_cfc :=false ;_ffd :=false ;for _edag :=len (_aa )-1;_edag >=0;_edag --{if _aa [_edag ]=='0'&&!_ffd &&!_cfc {_gca =_edag ;}else if _aa [_edag ]=='.'{_cfc =true ;
}else {_ffd =true ;};};if _cfc &&_ffd {if _aa [_gca -1]=='.'{_gca --;};return _aa [0:_gca ];};return _aa ;};