//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_g "bytes";_ca "fmt";_e "github.com/unidoc/unioffice/common/logger";_b "io";_ag "math";_a "strconv";_f "strings";_cb "time";);type Lexer struct{_ccg Format ;_cde []Format ;};const _d =1e11;func _bee (_ge _cb .Time ,_dc string )[]byte {_cd :=[]byte {};
_cda :=0;for _cdc :=0;_cdc < len (_dc );_cdc ++{var _aade string ;if _dc [_cdc ]=='/'{_aade =string (_dc [_cda :_cdc ]);_cda =_cdc +1;}else if _cdc ==len (_dc )-1{_aade =string (_dc [_cda :_cdc +1]);}else {continue ;};switch _aade {case "\u0079\u0079":_cd =_ge .AppendFormat (_cd ,"\u0030\u0036");
case "\u0079\u0079\u0079\u0079":_cd =_ge .AppendFormat (_cd ,"\u0032\u0030\u0030\u0036");case "\u006d":_cd =_ge .AppendFormat (_cd ,"\u0031");case "\u006d\u006d":_cd =_ge .AppendFormat (_cd ,"\u0030\u0031");case "\u006d\u006d\u006d":_cd =_ge .AppendFormat (_cd ,"\u004a\u0061\u006e");
case "\u006d\u006d\u006d\u006d":_cd =_ge .AppendFormat (_cd ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _ge .Month (){case _cb .January ,_cb .July ,_cb .June :_cd =append (_cd ,'J');case _cb .February :_cd =append (_cd ,'M');
case _cb .March ,_cb .May :_cd =append (_cd ,'M');case _cb .April ,_cb .August :_cd =append (_cd ,'A');case _cb .September :_cd =append (_cd ,'S');case _cb .October :_cd =append (_cd ,'O');case _cb .November :_cd =append (_cd ,'N');case _cb .December :_cd =append (_cd ,'D');
};case "\u0064":_cd =_ge .AppendFormat (_cd ,"\u0032");case "\u0064\u0064":_cd =_ge .AppendFormat (_cd ,"\u0030\u0032");case "\u0064\u0064\u0064":_cd =_ge .AppendFormat (_cd ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_cd =_ge .AppendFormat (_cd ,"\u004d\u006f\u006e\u0064\u0061\u0079");
default:_e .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_aade );};if _dc [_cdc ]=='/'{_cd =append (_cd ,'/');};};return _cd ;};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_bf bool ;_bg bool ;_ac bool ;_fb bool ;_ace bool ;_bd bool ;_df int64 ;_fc int ;};func Parse (s string )[]Format {_eegd :=Lexer {};_eegd .Lex (_f .NewReader (s ));
_eegd ._cde =append (_eegd ._cde ,_eegd ._ccg );return _eegd ._cde ;};func _aced (_dfc _cb .Time ,_aecc float64 ,_fdg string )[]byte {_gbf :=[]byte {};_fdgg :=0;for _ccb :=0;_ccb < len (_fdg );_ccb ++{var _fcde string ;if _fdg [_ccb ]==':'{_fcde =string (_fdg [_fdgg :_ccb ]);
_fdgg =_ccb +1;}else if _ccb ==len (_fdg )-1{_fcde =string (_fdg [_fdgg :_ccb +1]);}else {continue ;};switch _fcde {case "\u0064":_gbf =_dfc .AppendFormat (_gbf ,"\u0032");case "\u0068":_gbf =_dfc .AppendFormat (_gbf ,"\u0033");case "\u0068\u0068":_gbf =_dfc .AppendFormat (_gbf ,"\u0031\u0035");
case "\u006d":_gbf =_dfc .AppendFormat (_gbf ,"\u0034");case "\u006d\u006d":_gbf =_dfc .AppendFormat (_gbf ,"\u0030\u0034");case "\u0073":_gbf =_dfc .Round (_cb .Second ).AppendFormat (_gbf ,"\u0035");case "\u0073\u002e\u0030":_gbf =_dfc .Round (_cb .Second /10).AppendFormat (_gbf ,"\u0035\u002e\u0030");
case "\u0073\u002e\u0030\u0030":_gbf =_dfc .Round (_cb .Second /100).AppendFormat (_gbf ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_gbf =_dfc .Round (_cb .Second /1000).AppendFormat (_gbf ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_gbf =_dfc .Round (_cb .Second ).AppendFormat (_gbf ,"\u0030\u0035");
case "\u0073\u0073\u002e\u0030":_gbf =_dfc .Round (_cb .Second /10).AppendFormat (_gbf ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_gbf =_dfc .Round (_cb .Second /100).AppendFormat (_gbf ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_gbf =_dfc .Round (_cb .Second /1000).AppendFormat (_gbf ,"\u0030\u0035\u002e\u0030\u0030\u0030");
case "\u0041\u004d\u002fP\u004d":_gbf =_dfc .AppendFormat (_gbf ,"\u0050\u004d");case "\u005b\u0068\u005d":_gbf =_a .AppendInt (_gbf ,int64 (_aecc *24),10);case "\u005b\u006d\u005d":_gbf =_a .AppendInt (_gbf ,int64 (_aecc *24*60),10);case "\u005b\u0073\u005d":_gbf =_a .AppendInt (_gbf ,int64 (_aecc *24*60*60),10);
case "":default:_e .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_fcde );};if _fdg [_ccb ]==':'{_gbf =append (_gbf ,':');};};return _gbf ;
};const _fafb int =0;

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_dbf :=Parse (f );if len (_dbf )==1{return _ae (v ,_dbf [0],false );}else if len (_dbf )> 1&&v < 0{return _ae (v ,_dbf [1],true );
}else if len (_dbf )> 2&&v ==0{return _ae (v ,_dbf [2],false );};return _ae (v ,_dbf [0],false );};func _ae (_ff float64 ,_ga Format ,_fd bool )string {if _ga ._ac {return NumberGeneric (_ff );};_dfa :=make ([]byte ,0,20);_cce :=_ag .Signbit (_ff );_gd :=_ag .Abs (_ff );
_ccd :=int64 (0);_gad :=int64 (0);if _ga .IsExponential {for _gd >=10{_gad ++;_gd /=10;};for _gd < 1{_gad --;_gd *=10;};}else if _ga ._bg {_gd *=100;}else if _ga ._bf {if _ga ._df ==0{_acg :=_ag .Pow (10,float64 (_ga ._fc ));_gc ,_cg :=1.0,1.0;_ =_gc ;
for _ffb :=1.0;_ffb < _acg ;_ffb ++{_ ,_eba :=_ag .Modf (_gd *float64 (_ffb ));if _eba < _cg {_cg =_eba ;_gc =_ffb ;if _eba ==0{break ;};};};_ga ._df =int64 (_gc );};_ccd =int64 (_gd *float64 (_ga ._df )+0.5);if len (_ga .Whole )> 0&&_ccd > _ga ._df {_ccd =int64 (_gd *float64 (_ga ._df ))%_ga ._df ;
_gd -=float64 (_ccd )/float64 (_ga ._df );}else {_gd -=float64 (_ccd )/float64 (_ga ._df );if _ag .Abs (_gd )< 1{_acc :=true ;for _ ,_fe :=range _ga .Whole {if _fe .Type ==FmtTypeDigitOpt {continue ;};if _fe .Type ==FmtTypeLiteral &&_fe .Literal ==' '{continue ;
};_acc =false ;};if _acc {_ga .Whole =nil ;};};};};_aad :=1;for _ ,_aag :=range _ga .Fractional {if _aag .Type ==FmtTypeDigit ||_aag .Type ==FmtTypeDigitOpt {_aad ++;};};_gd +=5*_ag .Pow10 (-_aad );_bda ,_cbg :=_ag .Modf (_gd );_dfa =append (_dfa ,_fdd (_bda ,_ff ,_ga )...);
_dfa =append (_dfa ,_abd (_cbg ,_ff ,_ga )...);_dfa =append (_dfa ,_fbc (_gad ,_ga )...);if _ga ._bf {_dfa =_a .AppendInt (_dfa ,_ccd ,10);_dfa =append (_dfa ,'/');_dfa =_a .AppendInt (_dfa ,_ga ._df ,10);};if !_fd &&_cce {return "\u002d"+string (_dfa );
};return string (_dfa );};func _fdd (_gadb ,_bb float64 ,_gf Format )[]byte {if len (_gf .Whole )==0{return nil ;};_bfg :=_cb .Date (1899,12,30,0,0,0,0,_cb .UTC );_gb :=_bfg .Add (_cb .Duration (_bb *float64 (24*_cb .Hour )));_gb =_edag (_gb );_gfa :=_a .AppendFloat (nil ,_gadb ,'f',-1,64);
_aaa :=make ([]byte ,0,len (_gfa ));_ebd :=0;_agc :=1;_add :for _cbd :=len (_gf .Whole )-1;_cbd >=0;_cbd --{_ffe :=len (_gfa )-1-_ebd ;_dfg :=_gf .Whole [_cbd ];switch _dfg .Type {case FmtTypeDigit :if _ffe >=0{_aaa =append (_aaa ,_gfa [_ffe ]);_ebd ++;
_agc =_cbd ;}else {_aaa =append (_aaa ,'0');};case FmtTypeDigitOpt :if _ffe >=0{_aaa =append (_aaa ,_gfa [_ffe ]);_ebd ++;_agc =_cbd ;}else {for _ec :=_cbd ;_ec >=0;_ec --{_efe :=_gf .Whole [_ec ];if _efe .Type ==FmtTypeLiteral {_aaa =append (_aaa ,_efe .Literal );
};};break _add ;};case FmtTypeDollar :for _aaac :=_ebd ;_aaac < len (_gfa );_aaac ++{_aaa =append (_aaa ,_gfa [len (_gfa )-1-_aaac ]);_ebd ++;};_aaa =append (_aaa ,'$');case FmtTypeComma :if !_gf ._fb {_aaa =append (_aaa ,',');};case FmtTypeLiteral :_aaa =append (_aaa ,_dfg .Literal );
case FmtTypeDate :_aaa =append (_aaa ,_ad (_bee (_gb ,_dfg .DateTime ))...);case FmtTypeTime :_aaa =append (_aaa ,_ad (_aced (_gb ,_bb ,_dfg .DateTime ))...);default:_e .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_dfg );
};};_caf :=_ad (_aaa );if _ebd < len (_gfa )&&(_ebd !=0||_gf ._bd ){_ccab :=len (_gfa )-_ebd ;_ecg :=make ([]byte ,len (_caf )+_ccab );copy (_ecg ,_caf [0:_agc ]);copy (_ecg [_agc :],_gfa [0:]);copy (_ecg [_agc +_ccab :],_caf [_agc :]);_caf =_ecg ;};if _gf ._fb {_ccc :=_g .Buffer {};
_afc :=0;for _gce :=len (_caf )-1;_gce >=0;_gce --{if !(_caf [_gce ]>='0'&&_caf [_gce ]<='9'){_afc ++;}else {break ;};};for _gcd :=0;_gcd < len (_caf );_gcd ++{_ab :=(len (_caf )-_gcd -_afc );if _ab %3==0&&_ab !=0&&_gcd !=0{_ccc .WriteByte (',');};_ccc .WriteByte (_caf [_gcd ]);
};_caf =_ccc .Bytes ();};return _caf ;};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;
FmtTypeText ;);

// FmtType is the type of a format token.
//
//go:generate stringer -type=FmtType
type FmtType byte ;const _acec int =-1;const _gba int =-1;

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_eb :=Parse (f );var _aa Format ;if len (_eb )==1{_aa =_eb [0];}else if len (_eb )==4{_aa =_eb [3];};_acb :=false ;for _ ,_dg :=range _aa .Whole {if _dg .Type ==FmtTypeText {_acb =true ;};};if !_acb {return v ;};
_bde :=_g .Buffer {};for _ ,_dbc :=range _aa .Whole {switch _dbc .Type {case FmtTypeLiteral :_bde .WriteByte (_dbc .Literal );case FmtTypeText :_bde .WriteString (v );};};return _bde .String ();};func _deb (_bea int64 )int64 {if _bea < 0{return -_bea ;
};return _bea ;};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _ag .Abs (v )>=_d ||_ag .Abs (v )<=_db &&v !=0{return _cga (v );};_acf :=make ([]byte ,0,15);_acf =_a .AppendFloat (_acf ,v ,'f',-1,64);if len (_acf )> 11{_fff :=_acf [11]-'0';if _fff >=5&&_fff <=9{_acf [10]++;
_acf =_acf [0:11];_acf =_cebc (_acf );};_acf =_acf [0:11];}else if len (_acf )==11{if _acf [len (_acf )-1]=='9'{_acf [len (_acf )-1]++;_acf =_cebc (_acf );};};_acf =_gcc (_acf );return string (_acf );};func _ad (_eed []byte )[]byte {for _faf :=0;_faf < len (_eed )/2;
_faf ++{_ef :=len (_eed )-1-_faf ;_eed [_faf ],_eed [_ef ]=_eed [_ef ],_eed [_faf ];};return _eed ;};func _cebc (_dgg []byte )[]byte {for _gg :=len (_dgg )-1;_gg > 0;_gg --{if _dgg [_gg ]=='9'+1{_dgg [_gg ]='0';if _dgg [_gg -1]=='.'{_gg --;};_dgg [_gg -1]++;
};};if _dgg [0]=='9'+1{_dgg [0]='0';copy (_dgg [1:],_dgg [0:]);_dgg [0]='1';};return _dgg ;};func IsNumber (data string )(_ceg bool ){_eg ,_cace ,_fddd :=0,0,len (data );_eeg :=len (data );_deg ,_bdg ,_cgc :=0,0,0;_ =_bdg ;_ =_cgc ;_ =_deg ;{_eg =_bfe ;
_deg =0;_bdg =0;_cgc =0;};{if _cace ==_fddd {goto _gcdd ;};switch _eg {case 0:goto _ddd ;case 1:goto _dcg ;case 2:goto _aab ;case 3:goto _fcc ;case 4:goto _cgfc ;case 5:goto _cfb ;case 6:goto _ccec ;case 7:goto _ddb ;};goto _bc ;_dfgc :_bdg =_cace ;_cace --;
{_ceg =false ;};goto _afd ;_feb :_bdg =_cace ;_cace --;{_ceg =_bdg ==len (data );};goto _afd ;_dge :_bdg =_cace ;_cace --;{_ceg =_bdg ==len (data );};goto _afd ;_cbb :switch _cgc {case 2:{_cace =(_bdg )-1;_ceg =_bdg ==len (data );};case 3:{_cace =(_bdg )-1;
_ceg =false ;};};goto _afd ;_afd :_deg =0;if _cace ++;_cace ==_fddd {goto _ded ;};_ddd :_deg =_cace ;switch data [_cace ]{case 43:goto _fac ;case 45:goto _fac ;};if 48<=data [_cace ]&&data [_cace ]<=57{goto _eca ;};goto _agg ;_agg :if _cace ++;_cace ==_fddd {goto _agf ;
};_dcg :goto _agg ;_fac :if _cace ++;_cace ==_fddd {goto _fad ;};_aab :if 48<=data [_cace ]&&data [_cace ]<=57{goto _eca ;};goto _agg ;_eca :if _cace ++;_cace ==_fddd {goto _eec ;};_fcc :if data [_cace ]==46{goto _bdd ;};if 48<=data [_cace ]&&data [_cace ]<=57{goto _eca ;
};goto _agg ;_bdd :if _cace ++;_cace ==_fddd {goto _bgd ;};_cgfc :if 48<=data [_cace ]&&data [_cace ]<=57{goto _fbe ;};goto _agg ;_fbe :if _cace ++;_cace ==_fddd {goto _bfgf ;};_cfb :if data [_cace ]==69{goto _fdfe ;};if 48<=data [_cace ]&&data [_cace ]<=57{goto _fbe ;
};goto _agg ;_fdfe :if _cace ++;_cace ==_fddd {goto _gggf ;};_ccec :switch data [_cace ]{case 43:goto _ggg ;case 45:goto _ggg ;};goto _agg ;_ggg :_bdg =_cace +1;_cgc =3;goto _bbc ;_cfe :_bdg =_cace +1;_cgc =2;goto _bbc ;_bbc :if _cace ++;_cace ==_fddd {goto _cdg ;
};_ddb :if 48<=data [_cace ]&&data [_cace ]<=57{goto _cfe ;};goto _agg ;_bc :_ded :_eg =0;goto _gcdd ;_agf :_eg =1;goto _gcdd ;_fad :_eg =2;goto _gcdd ;_eec :_eg =3;goto _gcdd ;_bgd :_eg =4;goto _gcdd ;_bfgf :_eg =5;goto _gcdd ;_gggf :_eg =6;goto _gcdd ;
_cdg :_eg =7;goto _gcdd ;_gcdd :{};if _cace ==_eeg {switch _eg {case 1:goto _dfgc ;case 2:goto _dfgc ;case 3:goto _feb ;case 4:goto _dfgc ;case 5:goto _dge ;case 6:goto _dfgc ;case 7:goto _cbb ;};};};if _eg ==_acec {return false ;};return ;};const _ffd int =0;
var _cac =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};

// AddToken adds a format token to the format.
func (_dd *Format )AddToken (t FmtType ,l []byte ){if _dd ._ace {_dd ._ace =false ;return ;};switch t {case FmtTypeDecimal :_dd ._bd =true ;case FmtTypeUnderscore :_dd ._ace =true ;case FmtTypeText :_dd .Whole =append (_dd .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_dd .Whole =append (_dd .Whole ,Token {Type :t ,DateTime :string (l )});
case FmtTypePercent :_dd ._bg =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_fa :=range l {if _dd .IsExponential {_dd .Exponent =append (_dd .Exponent ,Token {Type :t ,Literal :_fa });
}else if !_dd ._bd {_dd .Whole =append (_dd .Whole ,Token {Type :t ,Literal :_fa });}else {_dd .Fractional =append (_dd .Fractional ,Token {Type :t ,Literal :_fa });};};case FmtTypeDigitOptThousands :_dd ._fb =true ;case FmtTypeFraction :_ee :=_f .Split (string (l ),"\u002f");
if len (_ee )==2{_dd ._bf =true ;_dd ._df ,_ =_a .ParseInt (_ee [1],10,64);for _ ,_de :=range _ee [1]{if _de =='?'||_de =='0'{_dd ._fc ++;};};};default:_e .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );
};};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_aca ,_ :=_a .ParseFloat (v ,64);return Number (_aca ,f );};return String (v ,f );};func _abd (_fab ,_ccae float64 ,_ccef Format )[]byte {if len (_ccef .Fractional )==0{return nil ;};_cgf :=_a .AppendFloat (nil ,_fab ,'f',-1,64);
if len (_cgf )> 2{_cgf =_cgf [2:];}else {_cgf =nil ;};_fge :=make ([]byte ,0,len (_cgf ));_fge =append (_fge ,'.');_bdf :=0;_bba :for _aec :=0;_aec < len (_ccef .Fractional );_aec ++{_beg :=_aec ;_fcd :=_ccef .Fractional [_aec ];switch _fcd .Type {case FmtTypeDigit :if _beg < len (_cgf ){_fge =append (_fge ,_cgf [_beg ]);
_bdf ++;}else {_fge =append (_fge ,'0');};case FmtTypeDigitOpt :if _beg >=0{_fge =append (_fge ,_cgf [_beg ]);_bdf ++;}else {break _bba ;};case FmtTypeLiteral :_fge =append (_fge ,_fcd .Literal );default:_e .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_fcd );
};};return _fge ;};const _aaf int =34;func _fbc (_edg int64 ,_cf Format )[]byte {if !_cf .IsExponential ||len (_cf .Exponent )==0{return nil ;};_abe :=_a .AppendInt (nil ,_deb (_edg ),10);_aea :=make ([]byte ,0,len (_abe )+2);_aea =append (_aea ,'E');if _edg >=0{_aea =append (_aea ,'+');
}else {_aea =append (_aea ,'-');_edg *=-1;};_gcdg :=0;_ced :for _ffg :=len (_cf .Exponent )-1;_ffg >=0;_ffg --{_agd :=len (_abe )-1-_gcdg ;_dde :=_cf .Exponent [_ffg ];switch _dde .Type {case FmtTypeDigit :if _agd >=0{_aea =append (_aea ,_abe [_agd ]);
_gcdg ++;}else {_aea =append (_aea ,'0');};case FmtTypeDigitOpt :if _agd >=0{_aea =append (_aea ,_abe [_agd ]);_gcdg ++;}else {for _fdb :=_ffg ;_fdb >=0;_fdb --{_abb :=_cf .Exponent [_fdb ];if _abb .Type ==FmtTypeLiteral {_aea =append (_aea ,_abb .Literal );
};};break _ced ;};case FmtTypeLiteral :_aea =append (_aea ,_dde .Literal );default:_e .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_dde );
};};if _gcdg < len (_abe ){_aea =append (_aea ,_abe [len (_abe )-_gcdg -1:_gcdg -1]...);};_ad (_aea [2:]);return _aea ;};func _edag (_ebdc _cb .Time )_cb .Time {_ebdc =_ebdc .UTC ();return _cb .Date (_ebdc .Year (),_ebdc .Month (),_ebdc .Day (),_ebdc .Hour (),_ebdc .Minute (),_ebdc .Second (),_ebdc .Nanosecond (),_cb .Local );
};const _ed ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";
func _cga (_fde float64 )string {_fdf :=_a .FormatFloat (_fde ,'E',-1,64);_bbd :=_a .FormatFloat (_fde ,'E',5,64);if len (_fdf )< len (_bbd ){return _a .FormatFloat (_fde ,'E',2,64);};return _bbd ;};const _bed int =34;const _bfe int =0;func (_cbe *Lexer )Lex (r _b .Reader ){_daf ,_gcf ,_dfe :=0,0,0;
_fgec :=-1;_cge ,_fee ,_efg :=0,0,0;_ =_fee ;_ =_efg ;_bbe :=1;_ =_bbe ;_gef :=make ([]byte ,4096);_bdb :=false ;for !_bdb {_fbd :=0;if _cge > 0{_fbd =_gcf -_cge ;};_gcf =0;_aeg ,_cbf :=r .Read (_gef [_fbd :]);if _aeg ==0||_cbf !=nil {_bdb =true ;};_dfe =_aeg +_fbd ;
if _dfe < len (_gef ){_fgec =_dfe ;};{_daf =_aaf ;_cge =0;_fee =0;_efg =0;};{if _gcf ==_dfe {goto _abae ;};switch _daf {case 34:goto _gab ;case 35:goto _degd ;case 0:goto _dddc ;case 36:goto _bca ;case 37:goto _bbee ;case 1:goto _dgb ;case 2:goto _ade ;
case 38:goto _aba ;case 3:goto _acedf ;case 4:goto _cdb ;case 39:goto _fdeb ;case 5:goto _dab ;case 6:goto _gcbc ;case 7:goto _dfea ;case 8:goto _bfb ;case 40:goto _bbf ;case 9:goto _bdgg ;case 41:goto _faa ;case 10:goto _adea ;case 42:goto _fcf ;case 11:goto _dgf ;
case 43:goto _ebb ;case 44:goto _ebdf ;case 45:goto _bga ;case 12:goto _gfg ;case 46:goto _ada ;case 13:goto _ffda ;case 14:goto _gac ;case 15:goto _fce ;case 16:goto _dcba ;case 47:goto _eaec ;case 17:goto _cfg ;case 48:goto _cfbe ;case 18:goto _ccbd ;
case 19:goto _faad ;case 20:goto _caff ;case 49:goto _ba ;case 50:goto _gfge ;case 21:goto _gff ;case 22:goto _ddg ;case 23:goto _dfac ;case 24:goto _geb ;case 25:goto _bede ;case 51:goto _cff ;case 26:goto _cdf ;case 52:goto _bce ;case 53:goto _dga ;case 54:goto _dca ;
case 55:goto _gbg ;case 56:goto _fda ;case 57:goto _dcde ;case 27:goto _dabc ;case 28:goto _ggfcd ;case 29:goto _baa ;case 30:goto _fbg ;case 31:goto _gfgb ;case 58:goto _fcdc ;case 32:goto _efgc ;case 59:goto _cdga ;case 33:goto _bfcg ;case 60:goto _afb ;
case 61:goto _efeb ;case 62:goto _dac ;};goto _adde ;_cgeb :switch _efg {case 2:{_gcf =(_fee )-1;_cbe ._ccg .AddToken (FmtTypeDigit ,nil );};case 3:{_gcf =(_fee )-1;_cbe ._ccg .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_gcf =(_fee )-1;};case 8:{_gcf =(_fee )-1;
_cbe ._ccg .AddToken (FmtTypePercent ,nil );};case 13:{_gcf =(_fee )-1;_cbe ._ccg .AddToken (FmtTypeFraction ,_gef [_cge :_fee ]);};case 14:{_gcf =(_fee )-1;_cbe ._ccg .AddToken (FmtTypeDate ,_gef [_cge :_fee ]);};case 15:{_gcf =(_fee )-1;_cbe ._ccg .AddToken (FmtTypeTime ,_gef [_cge :_fee ]);
};case 16:{_gcf =(_fee )-1;_cbe ._ccg .AddToken (FmtTypeTime ,_gef [_cge :_fee ]);};case 18:{_gcf =(_fee )-1;};case 20:{_gcf =(_fee )-1;_cbe ._ccg .AddToken (FmtTypeLiteral ,_gef [_cge :_fee ]);};case 21:{_gcf =(_fee )-1;_cbe ._ccg .AddToken (FmtTypeLiteral ,_gef [_cge +1:_fee -1]);
};};goto _acac ;_ddc :_gcf =(_fee )-1;{_cbe ._ccg .AddToken (FmtTypeFraction ,_gef [_cge :_fee ]);};goto _acac ;_dfce :_gcf =(_fee )-1;{_cbe ._ccg .AddToken (FmtTypeDigitOpt ,nil );};goto _acac ;_dcb :_fee =_gcf +1;{_cbe ._ccg .AddToken (FmtTypeDigitOptThousands ,nil );
};goto _acac ;_ege :_gcf =(_fee )-1;{_cbe ._ccg .AddToken (FmtTypePercent ,nil );};goto _acac ;_bfgfg :_gcf =(_fee )-1;{_cbe ._ccg .AddToken (FmtTypeDate ,_gef [_cge :_fee ]);};goto _acac ;_cgfg :_gcf =(_fee )-1;{_cbe ._ccg .AddToken (FmtTypeDigit ,nil );
};goto _acac ;_gfc :_gcf =(_fee )-1;{_cbe ._ccg .AddToken (FmtTypeTime ,_gef [_cge :_fee ]);};goto _acac ;_ggf :_gcf =(_fee )-1;{_cbe ._ccg .AddToken (FmtTypeLiteral ,_gef [_cge :_fee ]);};goto _acac ;_cdgb :_fee =_gcf +1;{_cbe ._ccg ._ac =true ;};goto _acac ;
_ecd :_fee =_gcf +1;{_cbe ._ccg .AddToken (FmtTypeLiteral ,_gef [_cge :_fee ]);};goto _acac ;_ggfa :_fee =_gcf +1;{_cbe ._ccg .AddToken (FmtTypeDollar ,nil );};goto _acac ;_ebe :_fee =_gcf +1;{_cbe ._ccg .AddToken (FmtTypeComma ,nil );};goto _acac ;_ega :_fee =_gcf +1;
{_cbe ._ccg .AddToken (FmtTypeDecimal ,nil );};goto _acac ;_gcb :_fee =_gcf +1;{_cbe .nextFmt ();};goto _acac ;_dcgb :_fee =_gcf +1;{_cbe ._ccg .AddToken (FmtTypeText ,nil );};goto _acac ;_gbc :_fee =_gcf +1;{_cbe ._ccg .AddToken (FmtTypeUnderscore ,nil );
};goto _acac ;_gfae :_fee =_gcf ;_gcf --;{_cbe ._ccg .AddToken (FmtTypeLiteral ,_gef [_cge :_fee ]);};goto _acac ;_afcc :_fee =_gcf ;_gcf --;{_cbe ._ccg .AddToken (FmtTypeLiteral ,_gef [_cge +1:_fee -1]);};goto _acac ;_gbe :_fee =_gcf ;_gcf --;{_cbe ._ccg .AddToken (FmtTypeDigitOpt ,nil );
};goto _acac ;_bgde :_fee =_gcf ;_gcf --;{_cbe ._ccg .AddToken (FmtTypeFraction ,_gef [_cge :_fee ]);};goto _acac ;_gcea :_fee =_gcf ;_gcf --;{_cbe ._ccg .AddToken (FmtTypePercent ,nil );};goto _acac ;_ebdd :_fee =_gcf ;_gcf --;{_cbe ._ccg .AddToken (FmtTypeDate ,_gef [_cge :_fee ]);
};goto _acac ;_egef :_fee =_gcf ;_gcf --;{_cbe ._ccg .AddToken (FmtTypeDigit ,nil );};goto _acac ;_dfga :_fee =_gcf ;_gcf --;{_cbe ._ccg .AddToken (FmtTypeTime ,_gef [_cge :_fee ]);};goto _acac ;_egd :_fee =_gcf ;_gcf --;{};goto _acac ;_dgc :_fee =_gcf +1;
{_cbe ._ccg .IsExponential =true ;};goto _acac ;_dcd :_fee =_gcf +1;{_cbe ._ccg .AddToken (FmtTypeLiteral ,_gef [_cge +1:_fee ]);};goto _acac ;_acac :_cge =0;if _gcf ++;_gcf ==_dfe {goto _gbd ;};_gab :_cge =_gcf ;switch _gef [_gcf ]{case 34:goto _bega ;
case 35:goto _aeb ;case 36:goto _ggfa ;case 37:goto _gfaec ;case 44:goto _ebe ;case 46:goto _ega ;case 47:goto _eefa ;case 48:goto _bcg ;case 58:goto _bgad ;case 59:goto _gcb ;case 63:goto _bdc ;case 64:goto _dcgb ;case 65:goto _cdfg ;case 69:goto _fgd ;
case 71:goto _dce ;case 91:goto _edd ;case 92:goto _fea ;case 95:goto _gbc ;case 100:goto _eefa ;case 104:goto _bgad ;case 109:goto _bgdb ;case 115:goto _feg ;case 121:goto _fbed ;};if 49<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _egec ;};goto _ecd ;_bega :_fee =_gcf +1;
_efg =20;goto _aed ;_aed :if _gcf ++;_gcf ==_dfe {goto _aabc ;};_degd :if _gef [_gcf ]==34{goto _fbec ;};goto _fed ;_fed :if _gcf ++;_gcf ==_dfe {goto _dcec ;};_dddc :if _gef [_gcf ]==34{goto _fbec ;};goto _fed ;_fbec :_fee =_gcf +1;_efg =21;goto _debb ;
_debb :if _gcf ++;_gcf ==_dfe {goto _abf ;};_bca :if _gef [_gcf ]==34{goto _fed ;};goto _afcc ;_aeb :_fee =_gcf +1;_efg =3;goto _ged ;_ged :if _gcf ++;_gcf ==_dfe {goto _ede ;};_bbee :switch _gef [_gcf ]{case 35:goto _cdgg ;case 37:goto _cdgg ;case 44:goto _gea ;
case 47:goto _eef ;case 48:goto _cdgg ;case 63:goto _cdgg ;};goto _gbe ;_cdgg :if _gcf ++;_gcf ==_dfe {goto _dag ;};_dgb :switch _gef [_gcf ]{case 35:goto _cdgg ;case 37:goto _cdgg ;case 47:goto _eef ;case 48:goto _cdgg ;case 63:goto _cdgg ;};goto _cgeb ;
_eef :if _gcf ++;_gcf ==_dfe {goto _bfae ;};_ade :switch _gef [_gcf ]{case 35:goto _bdad ;case 37:goto _eefd ;case 48:goto _debea ;case 63:goto _bdad ;};if 49<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _ecdg ;};goto _cgeb ;_bdad :_fee =_gcf +1;goto _ebg ;_ebg :if _gcf ++;
_gcf ==_dfe {goto _bgeb ;};_aba :switch _gef [_gcf ]{case 35:goto _bdad ;case 37:goto _bdad ;case 44:goto _bdad ;case 46:goto _bdad ;case 48:goto _bdad ;case 63:goto _bdad ;case 65:goto _bge ;};goto _bgde ;_bge :if _gcf ++;_gcf ==_dfe {goto _cbdg ;};_acedf :switch _gef [_gcf ]{case 47:goto _adb ;
case 77:goto _cegg ;};goto _ddc ;_adb :if _gcf ++;_gcf ==_dfe {goto _gfe ;};_cdb :if _gef [_gcf ]==80{goto _fae ;};goto _ddc ;_fae :_fee =_gcf +1;goto _fef ;_fef :if _gcf ++;_gcf ==_dfe {goto _ebeb ;};_fdeb :if _gef [_gcf ]==65{goto _bge ;};goto _bgde ;
_cegg :if _gcf ++;_gcf ==_dfe {goto _fbgf ;};_dab :if _gef [_gcf ]==47{goto _cbee ;};goto _ddc ;_cbee :if _gcf ++;_gcf ==_dfe {goto _bfee ;};_gcbc :if _gef [_gcf ]==80{goto _dea ;};goto _ddc ;_dea :if _gcf ++;_gcf ==_dfe {goto _egad ;};_dfea :if _gef [_gcf ]==77{goto _fae ;
};goto _ddc ;_eefd :if _gcf ++;_gcf ==_dfe {goto _eda ;};_bfb :switch _gef [_gcf ]{case 35:goto _aae ;case 37:goto _egab ;case 63:goto _aae ;};if 48<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _gga ;};goto _cgeb ;_aae :_fee =_gcf +1;goto _ggfc ;_ggfc :if _gcf ++;
_gcf ==_dfe {goto _cdbd ;};_bbf :switch _gef [_gcf ]{case 35:goto _bdad ;case 37:goto _gdf ;case 44:goto _bdad ;case 46:goto _bdad ;case 48:goto _bdad ;case 63:goto _bdad ;case 65:goto _bge ;};goto _bgde ;_gdf :if _gcf ++;_gcf ==_dfe {goto _bgf ;};_bdgg :switch _gef [_gcf ]{case 35:goto _ggb ;
case 44:goto _ggb ;case 46:goto _ggb ;case 48:goto _ggb ;case 63:goto _ggb ;};goto _ddc ;_ggb :_fee =_gcf +1;goto _bcb ;_bcb :if _gcf ++;_gcf ==_dfe {goto _ecb ;};_faa :switch _gef [_gcf ]{case 35:goto _ggb ;case 44:goto _ggb ;case 46:goto _ggb ;case 48:goto _ggb ;
case 63:goto _ggb ;case 65:goto _bge ;};goto _bgde ;_egab :if _gcf ++;_gcf ==_dfe {goto _cfeee ;};_adea :if _gef [_gcf ]==37{goto _egab ;};if 48<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _gga ;};goto _cgeb ;_gga :_fee =_gcf +1;_efg =13;goto _eff ;_eff :if _gcf ++;
_gcf ==_dfe {goto _dfag ;};_fcf :switch _gef [_gcf ]{case 35:goto _bdad ;case 37:goto _dggb ;case 44:goto _bdad ;case 46:goto _bdad ;case 48:goto _debe ;case 63:goto _bdad ;case 65:goto _bge ;};if 49<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _gga ;};goto _bgde ;
_dggb :if _gcf ++;_gcf ==_dfe {goto _afdg ;};_dgf :switch _gef [_gcf ]{case 35:goto _ggb ;case 37:goto _egab ;case 44:goto _ggb ;case 46:goto _ggb ;case 63:goto _ggb ;};if 48<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _gga ;};goto _ddc ;_debe :_fee =_gcf +1;
goto _cgfe ;_cgfe :if _gcf ++;_gcf ==_dfe {goto _cdfa ;};_ebb :switch _gef [_gcf ]{case 35:goto _bdad ;case 37:goto _debe ;case 44:goto _bdad ;case 46:goto _bdad ;case 48:goto _debe ;case 63:goto _bdad ;case 65:goto _bge ;};if 49<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _gga ;
};goto _bgde ;_debea :_fee =_gcf +1;goto _dbd ;_dbd :if _gcf ++;_gcf ==_dfe {goto _gdfe ;};_ebdf :switch _gef [_gcf ]{case 35:goto _bdad ;case 37:goto _debe ;case 44:goto _bdad ;case 46:goto _bdad ;case 48:goto _debea ;case 63:goto _bdad ;case 65:goto _bge ;
};if 49<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _ecdg ;};goto _bgde ;_ecdg :_fee =_gcf +1;goto _bdbb ;_bdbb :if _gcf ++;_gcf ==_dfe {goto _cgag ;};_bga :switch _gef [_gcf ]{case 35:goto _bdad ;case 37:goto _gga ;case 44:goto _bdad ;case 46:goto _bdad ;case 48:goto _debea ;
case 63:goto _bdad ;case 65:goto _bge ;};if 49<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _ecdg ;};goto _bgde ;_gea :if _gcf ++;_gcf ==_dfe {goto _bad ;};_gfg :if _gef [_gcf ]==35{goto _dcb ;};goto _dfce ;_gfaec :_fee =_gcf +1;_efg =8;goto _cacc ;_cacc :if _gcf ++;
_gcf ==_dfe {goto _ddcc ;};_ada :switch _gef [_gcf ]{case 35:goto _adee ;case 37:goto _bec ;case 48:goto _dgea ;case 63:goto _adee ;};if 49<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _beea ;};goto _gcea ;_adee :if _gcf ++;_gcf ==_dfe {goto _cgfge ;};_ffda :switch _gef [_gcf ]{case 35:goto _adee ;
case 47:goto _eef ;case 48:goto _adee ;case 63:goto _adee ;};goto _ege ;_bec :if _gcf ++;_gcf ==_dfe {goto _cee ;};_gac :if _gef [_gcf ]==37{goto _bec ;};if 48<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _beea ;};goto _cgeb ;_beea :if _gcf ++;_gcf ==_dfe {goto _gec ;
};_fce :switch _gef [_gcf ]{case 37:goto _bec ;case 47:goto _eef ;};if 48<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _beea ;};goto _cgeb ;_dgea :if _gcf ++;_gcf ==_dfe {goto _gde ;};_dcba :switch _gef [_gcf ]{case 35:goto _adee ;case 37:goto _bec ;case 47:goto _eef ;
case 48:goto _dgea ;case 63:goto _adee ;};if 49<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _beea ;};goto _ege ;_eefa :_fee =_gcf +1;goto _bfa ;_bfa :if _gcf ++;_gcf ==_dfe {goto _efebd ;};_eaec :switch _gef [_gcf ]{case 47:goto _eefa ;case 100:goto _eefa ;case 109:goto _eefa ;
case 121:goto _dfd ;};goto _ebdd ;_dfd :if _gcf ++;_gcf ==_dfe {goto _cec ;};_cfg :if _gef [_gcf ]==121{goto _eefa ;};goto _bfgfg ;_bcg :_fee =_gcf +1;_efg =2;goto _aedc ;_aedc :if _gcf ++;_gcf ==_dfe {goto _fag ;};_cfbe :switch _gef [_gcf ]{case 35:goto _cdgg ;
case 37:goto _cdge ;case 47:goto _eef ;case 48:goto _ebaa ;case 63:goto _cdgg ;};if 49<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _efd ;};goto _egef ;_cdge :if _gcf ++;_gcf ==_dfe {goto _bfac ;};_ccbd :switch _gef [_gcf ]{case 35:goto _cdgg ;case 37:goto _cdge ;
case 47:goto _eef ;case 48:goto _cdge ;case 63:goto _cdgg ;};if 49<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _beea ;};goto _cgfg ;_ebaa :if _gcf ++;_gcf ==_dfe {goto _dda ;};_faad :switch _gef [_gcf ]{case 35:goto _cdgg ;case 37:goto _cdge ;case 47:goto _eef ;
case 48:goto _ebaa ;case 63:goto _cdgg ;};if 49<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _efd ;};goto _cgfg ;_efd :if _gcf ++;_gcf ==_dfe {goto _ebf ;};_caff :switch _gef [_gcf ]{case 37:goto _beea ;case 47:goto _eef ;};if 48<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _efd ;
};goto _cgeb ;_egec :_fee =_gcf +1;_efg =20;goto _eeb ;_eeb :if _gcf ++;_gcf ==_dfe {goto _gdfg ;};_ba :switch _gef [_gcf ]{case 37:goto _beea ;case 47:goto _eef ;};if 48<=_gef [_gcf ]&&_gef [_gcf ]<=57{goto _efd ;};goto _gfae ;_bgad :_fee =_gcf +1;_efg =15;
goto _bfga ;_bfga :if _gcf ++;_gcf ==_dfe {goto _dbg ;};_gfge :switch _gef [_gcf ]{case 58:goto _bgad ;case 65:goto _ddba ;case 104:goto _bgad ;case 109:goto _bgad ;case 115:goto _feg ;};goto _dfga ;_ddba :if _gcf ++;_gcf ==_dfe {goto _cdcd ;};_gff :switch _gef [_gcf ]{case 47:goto _ebdg ;
case 77:goto _dcdc ;};goto _cgeb ;_ebdg :if _gcf ++;_gcf ==_dfe {goto _bbb ;};_ddg :if _gef [_gcf ]==80{goto _bgad ;};goto _cgeb ;_dcdc :if _gcf ++;_gcf ==_dfe {goto _fddg ;};_dfac :if _gef [_gcf ]==47{goto _aff ;};goto _cgeb ;_aff :if _gcf ++;_gcf ==_dfe {goto _cgea ;
};_geb :if _gef [_gcf ]==80{goto _cbbd ;};goto _cgeb ;_cbbd :if _gcf ++;_gcf ==_dfe {goto _aeaf ;};_bede :if _gef [_gcf ]==77{goto _bgad ;};goto _cgeb ;_feg :_fee =_gcf +1;_efg =15;goto _bdbd ;_bdbd :if _gcf ++;_gcf ==_dfe {goto _dgaa ;};_cff :switch _gef [_gcf ]{case 46:goto _ecf ;
case 58:goto _bgad ;case 65:goto _ddba ;case 104:goto _bgad ;case 109:goto _bgad ;case 115:goto _feg ;};goto _dfga ;_ecf :if _gcf ++;_gcf ==_dfe {goto _eecc ;};_cdf :if _gef [_gcf ]==48{goto _eee ;};goto _gfc ;_eee :_fee =_gcf +1;_efg =15;goto _dafa ;_dafa :if _gcf ++;
_gcf ==_dfe {goto _egf ;};_bce :switch _gef [_gcf ]{case 48:goto _gcef ;case 58:goto _bgad ;case 65:goto _ddba ;case 104:goto _bgad ;case 109:goto _bgad ;case 115:goto _feg ;};goto _dfga ;_gcef :_fee =_gcf +1;_efg =15;goto _geg ;_geg :if _gcf ++;_gcf ==_dfe {goto _bced ;
};_dga :switch _gef [_gcf ]{case 48:goto _bgad ;case 58:goto _bgad ;case 65:goto _ddba ;case 104:goto _bgad ;case 109:goto _bgad ;case 115:goto _feg ;};goto _dfga ;_bdc :_fee =_gcf +1;_efg =5;goto _gafa ;_gafa :if _gcf ++;_gcf ==_dfe {goto _gfeb ;};_dca :switch _gef [_gcf ]{case 35:goto _cdgg ;
case 37:goto _cdgg ;case 47:goto _eef ;case 48:goto _cdgg ;case 63:goto _cdgg ;};goto _egd ;_cdfg :_fee =_gcf +1;_efg =20;goto _cbeg ;_cbeg :if _gcf ++;_gcf ==_dfe {goto _adeb ;};_gbg :switch _gef [_gcf ]{case 47:goto _ebdg ;case 77:goto _dcdc ;};goto _gfae ;
_fgd :if _gcf ++;_gcf ==_dfe {goto _cgac ;};_fda :switch _gef [_gcf ]{case 43:goto _dgc ;case 45:goto _dgc ;};goto _gfae ;_dce :_fee =_gcf +1;goto _faec ;_faec :if _gcf ++;_gcf ==_dfe {goto _cfeg ;};_dcde :if _gef [_gcf ]==101{goto _bfca ;};goto _gfae ;
_bfca :if _gcf ++;_gcf ==_dfe {goto _ecbg ;};_dabc :if _gef [_gcf ]==110{goto _ffbb ;};goto _ggf ;_ffbb :if _gcf ++;_gcf ==_dfe {goto _ccaa ;};_ggfcd :if _gef [_gcf ]==101{goto _gaca ;};goto _ggf ;_gaca :if _gcf ++;_gcf ==_dfe {goto _eea ;};_baa :if _gef [_gcf ]==114{goto _aada ;
};goto _ggf ;_aada :if _gcf ++;_gcf ==_dfe {goto _dfb ;};_fbg :if _gef [_gcf ]==97{goto _bdbf ;};goto _ggf ;_bdbf :if _gcf ++;_gcf ==_dfe {goto _efef ;};_gfgb :if _gef [_gcf ]==108{goto _cdgb ;};goto _ggf ;_edd :_fee =_gcf +1;_efg =20;goto _deba ;_deba :if _gcf ++;
_gcf ==_dfe {goto _eaa ;};_fcdc :switch _gef [_gcf ]{case 104:goto _efa ;case 109:goto _efa ;case 115:goto _efa ;};goto _cacf ;_cacf :if _gcf ++;_gcf ==_dfe {goto _dgbd ;};_efgc :if _gef [_gcf ]==93{goto _aeab ;};goto _cacf ;_aeab :_fee =_gcf +1;_efg =18;
goto _cfba ;_beag :_fee =_gcf +1;_efg =16;goto _cfba ;_cfba :if _gcf ++;_gcf ==_dfe {goto _egdb ;};_cdga :if _gef [_gcf ]==93{goto _aeab ;};goto _cacf ;_efa :if _gcf ++;_gcf ==_dfe {goto _fffa ;};_bfcg :if _gef [_gcf ]==93{goto _beag ;};goto _cacf ;_fea :if _gcf ++;
_gcf ==_dfe {goto _cad ;};_afb :goto _dcd ;_bgdb :_fee =_gcf +1;_efg =14;goto _addf ;_addf :if _gcf ++;_gcf ==_dfe {goto _added ;};_efeb :switch _gef [_gcf ]{case 47:goto _eefa ;case 58:goto _bgad ;case 65:goto _ddba ;case 100:goto _eefa ;case 104:goto _bgad ;
case 109:goto _bgdb ;case 115:goto _feg ;case 121:goto _dfd ;};goto _ebdd ;_fbed :if _gcf ++;_gcf ==_dfe {goto _gfd ;};_dac :if _gef [_gcf ]==121{goto _eefa ;};goto _gfae ;_adde :_gbd :_daf =34;goto _abae ;_aabc :_daf =35;goto _abae ;_dcec :_daf =0;goto _abae ;
_abf :_daf =36;goto _abae ;_ede :_daf =37;goto _abae ;_dag :_daf =1;goto _abae ;_bfae :_daf =2;goto _abae ;_bgeb :_daf =38;goto _abae ;_cbdg :_daf =3;goto _abae ;_gfe :_daf =4;goto _abae ;_ebeb :_daf =39;goto _abae ;_fbgf :_daf =5;goto _abae ;_bfee :_daf =6;
goto _abae ;_egad :_daf =7;goto _abae ;_eda :_daf =8;goto _abae ;_cdbd :_daf =40;goto _abae ;_bgf :_daf =9;goto _abae ;_ecb :_daf =41;goto _abae ;_cfeee :_daf =10;goto _abae ;_dfag :_daf =42;goto _abae ;_afdg :_daf =11;goto _abae ;_cdfa :_daf =43;goto _abae ;
_gdfe :_daf =44;goto _abae ;_cgag :_daf =45;goto _abae ;_bad :_daf =12;goto _abae ;_ddcc :_daf =46;goto _abae ;_cgfge :_daf =13;goto _abae ;_cee :_daf =14;goto _abae ;_gec :_daf =15;goto _abae ;_gde :_daf =16;goto _abae ;_efebd :_daf =47;goto _abae ;_cec :_daf =17;
goto _abae ;_fag :_daf =48;goto _abae ;_bfac :_daf =18;goto _abae ;_dda :_daf =19;goto _abae ;_ebf :_daf =20;goto _abae ;_gdfg :_daf =49;goto _abae ;_dbg :_daf =50;goto _abae ;_cdcd :_daf =21;goto _abae ;_bbb :_daf =22;goto _abae ;_fddg :_daf =23;goto _abae ;
_cgea :_daf =24;goto _abae ;_aeaf :_daf =25;goto _abae ;_dgaa :_daf =51;goto _abae ;_eecc :_daf =26;goto _abae ;_egf :_daf =52;goto _abae ;_bced :_daf =53;goto _abae ;_gfeb :_daf =54;goto _abae ;_adeb :_daf =55;goto _abae ;_cgac :_daf =56;goto _abae ;_cfeg :_daf =57;
goto _abae ;_ecbg :_daf =27;goto _abae ;_ccaa :_daf =28;goto _abae ;_eea :_daf =29;goto _abae ;_dfb :_daf =30;goto _abae ;_efef :_daf =31;goto _abae ;_eaa :_daf =58;goto _abae ;_dgbd :_daf =32;goto _abae ;_egdb :_daf =59;goto _abae ;_fffa :_daf =33;goto _abae ;
_cad :_daf =60;goto _abae ;_added :_daf =61;goto _abae ;_gfd :_daf =62;goto _abae ;_abae :{};if _gcf ==_fgec {switch _daf {case 35:goto _gfae ;case 0:goto _cgeb ;case 36:goto _afcc ;case 37:goto _gbe ;case 1:goto _cgeb ;case 2:goto _cgeb ;case 38:goto _bgde ;
case 3:goto _ddc ;case 4:goto _ddc ;case 39:goto _bgde ;case 5:goto _ddc ;case 6:goto _ddc ;case 7:goto _ddc ;case 8:goto _cgeb ;case 40:goto _bgde ;case 9:goto _ddc ;case 41:goto _bgde ;case 10:goto _cgeb ;case 42:goto _bgde ;case 11:goto _ddc ;case 43:goto _bgde ;
case 44:goto _bgde ;case 45:goto _bgde ;case 12:goto _dfce ;case 46:goto _gcea ;case 13:goto _ege ;case 14:goto _cgeb ;case 15:goto _cgeb ;case 16:goto _ege ;case 47:goto _ebdd ;case 17:goto _bfgfg ;case 48:goto _egef ;case 18:goto _cgfg ;case 19:goto _cgfg ;
case 20:goto _cgeb ;case 49:goto _gfae ;case 50:goto _dfga ;case 21:goto _cgeb ;case 22:goto _cgeb ;case 23:goto _cgeb ;case 24:goto _cgeb ;case 25:goto _cgeb ;case 51:goto _dfga ;case 26:goto _gfc ;case 52:goto _dfga ;case 53:goto _dfga ;case 54:goto _egd ;
case 55:goto _gfae ;case 56:goto _gfae ;case 57:goto _gfae ;case 27:goto _ggf ;case 28:goto _ggf ;case 29:goto _ggf ;case 30:goto _ggf ;case 31:goto _ggf ;case 58:goto _gfae ;case 32:goto _cgeb ;case 59:goto _cgeb ;case 33:goto _ggf ;case 60:goto _gfae ;
case 61:goto _ebdd ;case 62:goto _gfae ;};};};if _cge > 0{copy (_gef [0:],_gef [_cge :]);};};_ =_fgec ;if _daf ==_acec {_e .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};const _db =1e-10;func _gcc (_ea []byte )[]byte {_dff :=len (_ea );
_dbb :=false ;_eae :=false ;for _gaf :=len (_ea )-1;_gaf >=0;_gaf --{if _ea [_gaf ]=='0'&&!_eae &&!_dbb {_dff =_gaf ;}else if _ea [_gaf ]=='.'{_dbb =true ;}else {_eae =true ;};};if _dbb &&_eae {if _ea [_dff -1]=='.'{_dff --;};return _ea [0:_dff ];};return _ea ;
};func (_be FmtType )String ()string {if _be >=FmtType (len (_cac )-1){return _ca .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_be );};return _ed [_cac [_be ]:_cac [_be +1]];};func (_fbcd *Lexer )nextFmt (){_fbcd ._cde =append (_fbcd ._cde ,_fbcd ._ccg );
_fbcd ._ccg =Format {}};const _edc int =34;

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};