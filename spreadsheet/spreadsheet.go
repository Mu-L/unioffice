//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_cf "archive/zip";_cc "bytes";_fg "errors";_ddg "fmt";_d "github.com/unidoc/unioffice";_ab "github.com/unidoc/unioffice/chart";_fa "github.com/unidoc/unioffice/color";_aga "github.com/unidoc/unioffice/common";_b "github.com/unidoc/unioffice/common/logger";
_bg "github.com/unidoc/unioffice/common/tempstorage";_fd "github.com/unidoc/unioffice/internal/license";_dg "github.com/unidoc/unioffice/measurement";_eed "github.com/unidoc/unioffice/schema/soo/dml";_dc "github.com/unidoc/unioffice/schema/soo/dml/chart";
_be "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing";_abd "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_gb "github.com/unidoc/unioffice/schema/soo/sml";_ee "github.com/unidoc/unioffice/spreadsheet/format";_ce "github.com/unidoc/unioffice/spreadsheet/formula";
_ag "github.com/unidoc/unioffice/spreadsheet/reference";_cfd "github.com/unidoc/unioffice/spreadsheet/update";_ed "github.com/unidoc/unioffice/vmldrawing";_ecd "github.com/unidoc/unioffice/zippkg";_ff "image";_dd "image/jpeg";_fb "io";_fe "math";_ec "math/big";
_db "os";_c "path";_e "path/filepath";_cce "reflect";_ac "regexp";_a "sort";_g "strconv";_ef "strings";_af "time";);

// X returns the inner wrapped XML type.
func (_aeab DataValidation )X ()*_gb .CT_DataValidation {return _aeab ._daca };

// SetType sets the type of the rule.
func (_acba ConditionalFormattingRule )SetType (t _gb .ST_CfType ){_acba ._cbf .TypeAttr =t };

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_beb *_gb .CT_Col };

// X returns the inner wrapped XML type.
func (_ega Font )X ()*_gb .CT_Font {return _ega ._aag };

// Wrapped returns true if the cell will wrap text.
func (_cab CellStyle )Wrapped ()bool {if _cab ._gag .Alignment ==nil {return false ;};if _cab ._gag .Alignment .WrapTextAttr ==nil {return false ;};return *_cab ._gag .Alignment .WrapTextAttr ;};

// Operator returns the operator for the rule
func (_dagf ConditionalFormattingRule )Operator ()_gb .ST_ConditionalFormattingOperator {return _dagf ._cbf .OperatorAttr ;};

// AddCellStyle creates a new empty cell style.
func (_bga StyleSheet )AddCellStyle ()CellStyle {_acdf :=_gb .NewCT_Xf ();return CellStyle {_bga ._agdc ,_acdf ,_bga ._geeec .CellXfs };};func _fdd (_dbcc string )bool {_dbcc =_ef .Replace (_dbcc ,"\u0024","",-1);if _efbc :=_cecd .FindStringSubmatch (_ef .ToLower (_dbcc ));
len (_efbc )> 2{_dggd :=_efbc [1];_edff ,_gdf :=_g .Atoi (_efbc [2]);if _gdf !=nil {return false ;};return _edff <=1048576&&_dggd <="\u007a\u007a";};return false ;};

// ClearAutoFilter removes the autofilters from the sheet.
func (_ebac *Sheet )ClearAutoFilter (){_ebac ._ecbe .AutoFilter =nil ;_bdcb :="\u0027"+_ebac .Name ()+"\u0027\u0021";for _ ,_ecfa :=range _ebac ._gaca .DefinedNames (){if _ecfa .Name ()==_cgbf {if _ef .HasPrefix (_ecfa .Content (),_bdcb ){_ebac ._gaca .RemoveDefinedName (_ecfa );
break ;};};};};

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_cdbc Drawing )AddImage (img _aga .ImageRef ,at AnchorType )Anchor {_gddf :=0;for _acd ,_abce :=range _cdbc ._edd .Images {if _abce ==img {_gddf =_acd +1;break ;};};var _gbbf string ;for _fbgb ,_dfeb :=range _cdbc ._edd ._fcadf {if _dfeb ==_cdbc ._agda {_egfa :=_ddg .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_gddf ,img .Format ());
_dec :=_cdbc ._edd ._egbg [_fbgb ].AddRelationship (_egfa ,_d .ImageType );_gbbf =_dec .ID ();break ;};};var _gdabd Anchor ;var _fce *_be .CT_Picture ;switch at {case AnchorTypeAbsolute :_cgfc :=_gadd ();_cdbc ._agda .EG_Anchor =append (_cdbc ._agda .EG_Anchor ,&_be .EG_Anchor {AbsoluteAnchor :_cgfc });
_cgfc .Choice =&_be .EG_ObjectChoicesChoice {};_cgfc .Choice .Pic =_be .NewCT_Picture ();_cgfc .Pos .XAttr .ST_CoordinateUnqualified =_d .Int64 (0);_cgfc .Pos .YAttr .ST_CoordinateUnqualified =_d .Int64 (0);_fce =_cgfc .Choice .Pic ;_gdabd =AbsoluteAnchor {_cgfc };
case AnchorTypeOneCell :_dggf :=_aceb ();_cdbc ._agda .EG_Anchor =append (_cdbc ._agda .EG_Anchor ,&_be .EG_Anchor {OneCellAnchor :_dggf });_dggf .Choice =&_be .EG_ObjectChoicesChoice {};_dggf .Choice .Pic =_be .NewCT_Picture ();_fce =_dggf .Choice .Pic ;
_gdabd =OneCellAnchor {_dggf };case AnchorTypeTwoCell :_cecc :=_gceg ();_cdbc ._agda .EG_Anchor =append (_cdbc ._agda .EG_Anchor ,&_be .EG_Anchor {TwoCellAnchor :_cecc });_cecc .Choice =&_be .EG_ObjectChoicesChoice {};_cecc .Choice .Pic =_be .NewCT_Picture ();
_fce =_cecc .Choice .Pic ;_gdabd =TwoCellAnchor {_cecc };};_fce .NvPicPr .CNvPr .IdAttr =uint32 (len (_cdbc ._agda .EG_Anchor ));_fce .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_fce .BlipFill .Blip =_eed .NewCT_Blip ();_fce .BlipFill .Blip .EmbedAttr =_d .String (_gbbf );
_fce .BlipFill .Stretch =_eed .NewCT_StretchInfoProperties ();_fce .SpPr =_eed .NewCT_ShapeProperties ();_fce .SpPr .Xfrm =_eed .NewCT_Transform2D ();_fce .SpPr .Xfrm .Off =_eed .NewCT_Point2D ();_fce .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_d .Int64 (0);
_fce .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_d .Int64 (0);_fce .SpPr .Xfrm .Ext =_eed .NewCT_PositiveSize2D ();_fce .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_dg .Pixel72 )/_dg .EMU );_fce .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_dg .Pixel72 )/_dg .EMU );
_fce .SpPr .PrstGeom =_eed .NewCT_PresetGeometry2D ();_fce .SpPr .PrstGeom .PrstAttr =_eed .ST_ShapeTypeRect ;_fce .SpPr .Ln =_eed .NewCT_LineProperties ();_fce .SpPr .Ln .NoFill =_eed .NewCT_NoFillProperties ();return _gdabd ;};

// Priority returns the rule priority
func (_abcd ConditionalFormattingRule )Priority ()int32 {return _abcd ._cbf .PriorityAttr };func (_gade PatternFill )SetBgColor (c _fa .Color ){_gade ._fcb .BgColor =_gb .NewCT_Color ();_gade ._fcb .BgColor .RgbAttr =c .AsRGBAString ();};

// Col returns the column of the cell marker.
func (_gbc CellMarker )Col ()int32 {return _gbc ._gbef .Col };

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_bag *evalContext )LastRow (col string )int {_ccb :=_bag ._efeg ;_fccc :=int (_ag .ColumnToIndex (col ));_eada :=1;for _ ,_fbd :=range _ccb ._ecbe .SheetData .Row {if _fbd .RAttr !=nil {_bce :=Row {_ccb ._gaca ,_ccb ,_fbd };_gega :=len (_bce .Cells ());
if _gega > _fccc {_eada =int (_bce .RowNumber ());};};};return _eada ;};

// SetFormat sets the number format code.
func (_gaad NumberFormat )SetFormat (f string ){_gaad ._dfce .FormatCodeAttr =f };func (_cbc *Sheet )updateAfterRemove (_dggc uint32 ,_fefbe _cfd .UpdateAction )error {_eafa :=_cbc .Name ();_ccfe :=&_cfd .UpdateQuery {UpdateType :_fefbe ,ColumnIdx :_dggc ,SheetToUpdate :_eafa };
for _ ,_cadb :=range _cbc ._gaca .Sheets (){_ccfe .UpdateCurrentSheet =_eafa ==_cadb .Name ();for _ ,_gaggd :=range _cadb .Rows (){for _ ,_ggcac :=range _gaggd .Cells (){if _ggcac .X ().F !=nil {_aceae :=_ggcac .X ().F .Content ;_fccb :=_ce .ParseString (_aceae );
if _fccb ==nil {_ggcac .SetError ("\u0023\u0052\u0045F\u0021");}else {_agdad :=_fccb .Update (_ccfe );_ggcac .X ().F .Content =_ddg .Sprintf ("\u003d\u0025\u0073",_agdad .String ());};};};};};return nil ;};

// SetBorder applies a border to a cell style avoiding redundancy. The function checks if the given border
// already exists in the saved borders. If found, the existing border is reused; otherwise,
// the new border is added to the saved borders collection. The border is then applied to the cell style,
// affecting all styles that reference it by index.
func (_gbae CellStyle )SetBorder (b Border ){_gef :=b ._cga .Border ;for _ ,_bca :=range _gef {if _cce .DeepEqual (_bca ,b ._eb ){b ._eb =_bca ;_gbae ._gag .BorderIdAttr =_d .Uint32 (b .Index ());_gbae ._gag .ApplyBorderAttr =_d .Bool (true );return ;};
};b ._cga .Border =append (b ._cga .Border ,b ._eb );b ._cga .CountAttr =_d .Uint32 (uint32 (len (b ._cga .Border )));_gbae ._gag .BorderIdAttr =_d .Uint32 (b .Index ());_gbae ._gag .ApplyBorderAttr =_d .Bool (true );};func (_bee *Sheet )removeColumnFromMergedCells (_bebf uint32 )error {if _bee ._ecbe .MergeCells ==nil ||_bee ._ecbe .MergeCells .MergeCell ==nil {return nil ;
};_efd :=[]*_gb .CT_MergeCell {};for _ ,_bafd :=range _bee .MergedCells (){_egga :=_cdgcc (_bafd .Reference (),_bebf ,true );if _egga !=""{_bafd .SetReference (_egga );_efd =append (_efd ,_bafd .X ());};};_bee ._ecbe .MergeCells .MergeCell =_efd ;return nil ;
};

// TopLeft returns the top-left corner of the anchored object.
func (_aaab OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_aaab ._cdffe .From }};func (_aaded PatternFill )ClearFgColor (){_aaded ._fcb .FgColor =nil };

// Comments is the container for comments for a single sheet.
type Comments struct{_dfa *Workbook ;_ccae *_gb .Comments ;};

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_abgg *Sheet )AddRow ()Row {_fgba :=uint32 (0);_cfeg :=uint32 (len (_abgg ._ecbe .SheetData .Row ));if _cfeg > 0&&_abgg ._ecbe .SheetData .Row [_cfeg -1].RAttr !=nil &&*_abgg ._ecbe .SheetData .Row [_cfeg -1].RAttr ==_cfeg {return _abgg .addNumberedRowFast (_cfeg +1);
};for _ ,_effca :=range _abgg ._ecbe .SheetData .Row {if _effca .RAttr !=nil &&*_effca .RAttr > _fgba {_fgba =*_effca .RAttr ;};};return _abgg .AddNumberedRow (_fgba +1);};

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_cagd *Sheet )RemoveMergedCell (mc MergedCell ){for _gcab ,_bba :=range _cagd ._ecbe .MergeCells .MergeCell {if _bba ==mc .X (){copy (_cagd ._ecbe .MergeCells .MergeCell [_gcab :],_cagd ._ecbe .MergeCells .MergeCell [_gcab +1:]);_cagd ._ecbe .MergeCells .MergeCell [len (_cagd ._ecbe .MergeCells .MergeCell )-1]=nil ;
_cagd ._ecbe .MergeCells .MergeCell =_cagd ._ecbe .MergeCells .MergeCell [:len (_cagd ._ecbe .MergeCells .MergeCell )-1];};};};

// LockObject controls the locking of the sheet objects.
func (_ggde SheetProtection )LockObject (b bool ){if !b {_ggde ._ecc .ObjectsAttr =nil ;}else {_ggde ._ecc .ObjectsAttr =_d .Bool (true );};};

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_aaf CellStyle )SetHorizontalAlignment (a _gb .ST_HorizontalAlignment ){if _aaf ._gag .Alignment ==nil {_aaf ._gag .Alignment =_gb .NewCT_CellAlignment ();};_aaf ._gag .Alignment .HorizontalAttr =a ;_aaf ._gag .ApplyAlignmentAttr =_d .Bool (true );
};

// X returns the inner wrapped XML type.
func (_bcg Column )X ()*_gb .CT_Col {return _bcg ._beb };

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_dgb Cell )Reference ()string {if _dgb ._aba .RAttr !=nil {return *_dgb ._aba .RAttr ;};return "";};func (_cea Fills )X ()*_gb .CT_Fills {return _cea ._cdfg };

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_ecg Cell )SetStyleIndex (idx uint32 ){_ecg ._aba .SAttr =_d .Uint32 (idx )};

// X returns the inner wrapped XML type.
func (_fcbbe *Workbook )X ()*_gb .Workbook {return _fcbbe ._fdea };

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_dgc Cell )GetFormattedValue ()string {_cca :=_dgc .getFormat ();switch _dgc ._aba .TAttr {case _gb .ST_CellTypeB :_ffg ,_ :=_dgc .GetValueAsBool ();if _ffg {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _gb .ST_CellTypeN :_dbe ,_ :=_dgc .GetValueAsNumber ();
return _ee .Number (_dbe ,_cca );case _gb .ST_CellTypeE :if _dgc ._aba .V !=nil {return *_dgc ._aba .V ;};return "";case _gb .ST_CellTypeS ,_gb .ST_CellTypeInlineStr :return _ee .String (_dgc .GetString (),_cca );case _gb .ST_CellTypeStr :_cba :=_dgc .GetString ();
if _ee .IsNumber (_cba ){_dbb ,_ :=_g .ParseFloat (_cba ,64);return _ee .Number (_dbb ,_cca );};return _ee .String (_cba ,_cca );case _gb .ST_CellTypeUnset :fallthrough;default:_efca ,_ :=_dgc .GetRawValue ();if len (_efca )==0{return "";};_cdf ,_adc :=_dgc .GetValueAsNumber ();
if _adc ==nil {return _ee .Number (_cdf ,_cca );};return _ee .String (_efca ,_cca );};};const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);

// SetDateWithStyle sets a date with the default date style applied.
func (_dfg Cell )SetDateWithStyle (d _af .Time ){_dfg .SetDate (d );for _ ,_edeb :=range _dfg ._bf .StyleSheet .CellStyles (){if _edeb .HasNumberFormat ()&&_edeb .NumberFormat ()==uint32 (StandardFormatDate ){_dfg .SetStyle (_edeb );return ;};};_daa :=_dfg ._bf .StyleSheet .AddCellStyle ();
_daa .SetNumberFormatStandard (StandardFormatDate );_dfg .SetStyle (_daa );};

// SetMaxLength sets the maximum bar length in percent.
func (_fgc DataBarScale )SetMaxLength (l uint32 ){_fgc ._gbg .MaxLengthAttr =_d .Uint32 (l )};

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_bdc Cell )GetString ()string {switch _bdc ._aba .TAttr {case _gb .ST_CellTypeInlineStr :if _bdc ._aba .Is !=nil &&_bdc ._aba .Is .T !=nil {return *_bdc ._aba .Is .T ;};if _bdc ._aba .V !=nil {return *_bdc ._aba .V ;};case _gb .ST_CellTypeS :if _bdc ._aba .V ==nil {return "";
};_edef ,_geac :=_g .Atoi (*_bdc ._aba .V );if _geac !=nil {return "";};_cef ,_geac :=_bdc ._bf .SharedStrings .GetString (_edef );if _geac !=nil {return "";};return _cef ;};if _bdc ._aba .V ==nil {return "";};return *_bdc ._aba .V ;};

// X returns the inner XML entity for a stylesheet.
func (_affdg StyleSheet )X ()*_gb .StyleSheet {return _affdg ._geeec };func (_fabe DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_fabe .clear ();_fabe ._daca .TypeAttr =_gb .ST_DataValidationType (t );_fabe ._daca .OperatorAttr =_gb .ST_DataValidationOperator (op );
return DataValidationCompare {_fabe ._daca };};

// Sheets returns the sheets from the workbook.
func (_dfff *Workbook )Sheets ()[]Sheet {_cefe :=[]Sheet {};for _gfgd ,_efac :=range _dfff ._cgcb {_ccgac :=_dfff ._fdea .Sheets .Sheet [_gfgd ];_degd :=Sheet {_dfff ,_ccgac ,_efac };_cefe =append (_cefe ,_degd );};return _cefe ;};

// SetRowOffset sets the row offset of the top-left anchor.
func (_dde OneCellAnchor )SetRowOffset (m _dg .Distance ){_dde .TopLeft ().SetRowOffset (m )};

// IsSheetLocked returns whether the sheet is locked.
func (_bccg SheetProtection )IsSheetLocked ()bool {return _bccg ._ecc .SheetAttr !=nil &&*_bccg ._ecc .SheetAttr ;};

// IsError returns true if the cell is an error type cell.
func (_egc Cell )IsError ()bool {return _egc ._aba .TAttr ==_gb .ST_CellTypeE };

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_ebc ConditionalFormattingRule )SetIcons ()IconScale {_ebc .clear ();_ebc .SetType (_gb .ST_CfTypeIconSet );_ebc ._cbf .IconSet =_gb .NewCT_IconSet ();_daddg :=IconScale {_ebc ._cbf .IconSet };_daddg .SetIcons (_gb .ST_IconSetType3TrafficLights1 );
return _daddg ;};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_gbfa Row )RowNumber ()uint32 {if _gbfa ._fagb .RAttr !=nil {return *_gbfa ._fagb .RAttr ;};return 0;};const (DVCompareOpEqual =DVCompareOp (_gb .ST_DataValidationOperatorEqual );DVCompareOpBetween =DVCompareOp (_gb .ST_DataValidationOperatorBetween );
DVCompareOpNotBetween =DVCompareOp (_gb .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_gb .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_gb .ST_DataValidationOperatorGreaterThan );DVCompareOpGreaterEqual =DVCompareOp (_gb .ST_DataValidationOperatorGreaterThanOrEqual );
DVCompareOpLess =DVCompareOp (_gb .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_gb .ST_DataValidationOperatorLessThanOrEqual ););

// GetFilename returns the filename of the context's workbook.
func (_abfc *evalContext )GetFilename ()string {return _abfc ._efeg ._gaca .GetFilename ()};

// IsEmpty returns true if the cell is empty.
func (_acf Cell )IsEmpty ()bool {return _acf ._aba .TAttr ==_gb .ST_CellTypeUnset &&_acf ._aba .V ==nil &&_acf ._aba .F ==nil ;};type PatternFill struct{_fcb *_gb .CT_PatternFill ;_cbef *_gb .CT_Fill ;};

// Content returns the content of the defined range (the range in most cases)/
func (_bgb DefinedName )Content ()string {return _bgb ._bdce .Content };

// SetWidth sets the width of the anchored object.
func (_fdc AbsoluteAnchor )SetWidth (w _dg .Distance ){_fdc ._abf .Ext .CxAttr =int64 (w /_dg .EMU )};

// Row returns the row of the cell marker.
func (_cfb CellMarker )Row ()int32 {return _cfb ._gbef .Row };

// Index returns the index of the border for use with a cell style.
func (_gfa Border )Index ()uint32 {for _ea ,_cd :=range _gfa ._cga .Border {if _cd ==_gfa ._eb {return uint32 (_ea );};};return 0;};

// AddFont creates a new empty Font style.
func (_adeb StyleSheet )AddFont ()Font {_afcf :=_gb .NewCT_Font ();return Font {_afcf ,_adeb ._geeec }};

// HasFormula returns true if the cell contains formula.
func (_ccga *evalContext )HasFormula (cellRef string )bool {return _ccga ._efeg .Cell (cellRef ).HasFormula ();};func (_fge DataValidationCompare )SetValue2 (v string ){_fge ._ceec .Formula2 =&v };

// SetAllowBlank controls if blank values are accepted.
func (_ceg DataValidation )SetAllowBlank (b bool ){if !b {_ceg ._daca .AllowBlankAttr =nil ;}else {_ceg ._daca .AllowBlankAttr =_d .Bool (true );};};func (_adbc StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));
};for _ ,_dcad :=range _adbc ._geeec .NumFmts .NumFmt {if _dcad .NumFmtIdAttr ==id {return NumberFormat {_adbc ._agdc ,_dcad };};};return NumberFormat {};};

// X returns the inner wrapped XML type.
func (_ffc Sheet )X ()*_gb .Worksheet {return _ffc ._ecbe };

// GetDrawing return the worksheet drawing and its relationships if exists.
func (_aecd *Sheet )GetDrawing ()(*_be .WsDr ,_aga .Relationships ){if _ffecf :=_aecd ._ecbe .Drawing ;_ffecf !=nil {_fecc :=0;for _ ,_fbad :=range _aecd ._gaca ._cgcb {if _gaag :=_fbad .Drawing ;_gaag !=nil {if _fbad ==_aecd ._ecbe {return _aecd ._gaca ._fcadf [_fecc ],_aecd ._gaca ._egbg [_fecc ];
};_fecc ++;};};};return nil ,_aga .Relationships {};};func (_acee Font )Index ()uint32 {for _gefb ,_fbe :=range _acee ._aec .Fonts .Font {if _acee ._aag ==_fbe {return uint32 (_gefb );};};return 0;};

// SetLocked sets cell locked or not.
func (_bdbd *evalContext )SetLocked (cellRef string ,locked bool ){_bdbd ._efeg .Cell (cellRef ).setLocked (locked );};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_gbbg *Sheet )ClearSheetViews (){_gbbg ._ecbe .SheetViews =nil };var _ffce =_d .AbsoluteFilename (_d .DocTypeSpreadsheet ,_d .SharedStringsType ,0);var _cecd *_ac .Regexp =_ac .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");


// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_cdffe *_be .CT_OneCellAnchor };

// SetColOffset sets the column offset of the two cell anchor.
func (_bbca TwoCellAnchor )SetColOffset (m _dg .Distance ){_fbcf :=m -_bbca .TopLeft ().ColOffset ();_bbca .TopLeft ().SetColOffset (m );_bbca .BottomRight ().SetColOffset (_bbca .BottomRight ().ColOffset ()+_fbcf );};const _efga ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";


// Text returns text from the workbook as one string separated with line breaks.
func (_fgag *WorkbookText )Text ()string {_eae :=_cc .NewBuffer ([]byte {});for _ ,_efg :=range _fgag .Sheets {_eae .WriteString (_efg .Text ());};return _eae .String ();};

// X returns the inner wrapped XML type.
func (_ffgc DataBarScale )X ()*_gb .CT_DataBar {return _ffgc ._gbg };

// SetHidden marks the defined name as hidden.
func (_afgb DefinedName )SetHidden (b bool ){_afgb ._bdce .HiddenAttr =_d .Bool (b )};var (_cabae =[...]uint8 {0,21,46,61,76,91};_cgee =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_debc =[...]uint8 {0,16,32,48,64};_bdaab =[...]uint8 {0,16,32,48,64,80};
);

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_eabba SheetView )SetState (st _gb .ST_PaneState ){_eabba .ensurePane ();_eabba ._gcad .Pane .StateAttr =st ;};func (_gcfgc Sheet )IsValid ()bool {return _gcfgc ._ecbe !=nil };

// IsNumber returns true if the cell is a number type cell.
func (_fcc Cell )IsNumber ()bool {switch _fcc ._aba .TAttr {case _gb .ST_CellTypeN :return true ;case _gb .ST_CellTypeS ,_gb .ST_CellTypeB :return false ;};return _fcc ._aba .V !=nil &&_ee .IsNumber (*_fcc ._aba .V );};

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_ecbb *Sheet )SetFrozen (firstRow ,firstCol bool ){_ecbb ._ecbe .SheetViews =nil ;_fad :=_ecbb .AddView ();_fad .SetState (_gb .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_fad .SetYSplit (1);_fad .SetXSplit (1);_fad .SetTopLeft ("\u0042\u0032");
case firstRow :_fad .SetYSplit (1);_fad .SetTopLeft ("\u0041\u0032");case firstCol :_fad .SetXSplit (1);_fad .SetTopLeft ("\u0042\u0031");};};

// CellStyles returns the list of defined cell styles
func (_fdce StyleSheet )CellStyles ()[]CellStyle {_ffaf :=[]CellStyle {};for _ ,_dadc :=range _fdce ._geeec .CellXfs .Xf {_ffaf =append (_ffaf ,CellStyle {_fdce ._agdc ,_dadc ,_fdce ._geeec .CellXfs });};return _ffaf ;};

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_bda Cell )GetValueAsTime ()(_af .Time ,error ){if _bda ._aba .TAttr !=_gb .ST_CellTypeUnset {return _af .Time {},_fg .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");
};if _bda ._aba .V ==nil {return _af .Time {},_fg .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_fbce ,_ ,_gae :=_ec .ParseFloat (*_bda ._aba .V ,10,128,_ec .ToNearestEven );if _gae !=nil {return _af .Time {},_gae ;
};_bec :=new (_ec .Float );_bec .SetUint64 (uint64 (24*_af .Hour ));_fbce .Mul (_fbce ,_bec );_dbc ,_ :=_fbce .Uint64 ();_edf :=_bda ._bf .Epoch ().Add (_af .Duration (_dbc ));return _ccgb (_edf ),nil ;};

// X returns the inner wrapped XML type.
func (_cfcd SharedStrings )X ()*_gb .Sst {return _cfcd ._dfaab };

// StandardFormat is a standard ECMA 376 number format.
//
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;func (_agag Font )SetColor (c _fa .Color ){_addc :=_gb .NewCT_Color ();_gbbfe :="\u0066\u0066"+*c .AsRGBString ();_addc .RgbAttr =&_gbbfe ;_agag ._aag .Color =[]*_gb .CT_Color {_addc };};type Fill struct{_fdca *_gb .CT_Fill ;
_cdg *_gb .CT_Fills ;};

// SetTopLeft sets the top left visible cell after the split.
func (_fdbe SheetView )SetTopLeft (cellRef string ){_fdbe .ensurePane ();_fdbe ._gcad .Pane .TopLeftCellAttr =&cellRef ;};

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_eadfg Sheet )Validate ()error {_cfgf :=[]func ()error {_eadfg .validateRowCellNumbers ,_eadfg .validateMergedCells ,_eadfg .validateSheetNames };for _ ,_gdcg :=range _cfgf {if _cfee :=_gdcg ();_cfee !=nil {return _cfee ;};};if _ceda :=_eadfg ._ecbe .Validate ();
_ceda !=nil {return _ceda ;};return _eadfg ._ecbe .Validate ();};

// ClearBorder clears any border configuration from the cell style.
func (_cdce CellStyle )ClearBorder (){_cdce ._gag .BorderIdAttr =nil ;_cdce ._gag .ApplyBorderAttr =nil };

// X returns the inner wrapped XML type.
func (_ebea Drawing )X ()*_be .WsDr {return _ebea ._agda };var _gbaa =_d .RelativeFilename (_d .DocTypeSpreadsheet ,_d .OfficeDocumentType ,_d .SharedStringsType ,0);

// IsStructureLocked returns whether the workbook structure is locked.
func (_fcgb WorkbookProtection )IsStructureLocked ()bool {return _fcgb ._dfbd .LockStructureAttr !=nil &&*_fcgb ._dfbd .LockStructureAttr ;};

// IsBool returns true if the cell is a boolean type cell.
func (_agg Cell )IsBool ()bool {return _agg ._aba .TAttr ==_gb .ST_CellTypeB };

// Name returns the sheet name
func (_agec Sheet )Name ()string {return _agec ._bfaa .NameAttr };

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_fddd *Sheet )ClearCachedFormulaResults (){for _ ,_ebag :=range _fddd .Rows (){for _ ,_eeaa :=range _ebag .Cells (){if _eeaa .X ().F !=nil {_eeaa .X ().V =nil ;};};};};

// SetPasswordHash sets the password hash to the input.
func (_gfge SheetProtection )SetPasswordHash (pwHash string ){_gfge ._ecc .PasswordAttr =_d .String (pwHash );};

// SheetCount returns the number of sheets in the workbook.
func (_fdda Workbook )SheetCount ()int {return len (_fdda ._cgcb )};

// MoveTo moves the top-left of the anchored object.
func (_ddef OneCellAnchor )MoveTo (col ,row int32 ){_ddef .TopLeft ().SetCol (col );_ddef .TopLeft ().SetRow (row );};

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_gad CellStyle )SetVerticalAlignment (a _gb .ST_VerticalAlignment ){if _gad ._gag .Alignment ==nil {_gad ._gag .Alignment =_gb .NewCT_CellAlignment ();};_gad ._gag .ApplyAlignmentAttr =_d .Bool (true );_gad ._gag .Alignment .VerticalAttr =a ;};

// Workbook returns sheet's parent workbook.
func (_abbb *Sheet )Workbook ()*Workbook {return _abbb ._gaca };

// IsHidden returns whether the row is hidden or not.
func (_edfc Row )IsHidden ()bool {return _edfc ._fagb .HiddenAttr !=nil &&*_edfc ._fagb .HiddenAttr };

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_bfae *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_afea :=range _bfae .Sheets (){if _afea .Name ()==name {return _afea ,nil ;};};return Sheet {},ErrorNotFound ;};var _fgbde =[...]uint8 {0,18,37};

// GetChartByTargetId returns the array of workbook crt.ChartSpace.
func (_dcb *Workbook )GetChartByTargetId (targetAttr string )*_dc .ChartSpace {return _dcb ._ggfe [targetAttr ];};

// Reference returns the table reference (the cells within the table)
func (_dgbdg Table )Reference ()string {return _dgbdg ._ddefc .RefAttr };

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_adca *evalContext )LastColumn (rowFrom ,rowTo int )string {_gaaa :=_adca ._efeg ;_cgaf :=1;for _bedg :=rowFrom ;_bedg <=rowTo ;_bedg ++{_bacg :=len (_gaaa .Row (uint32 (_bedg )).Cells ());if _bacg > _cgaf {_cgaf =_bacg ;};};return _ag .IndexToColumn (uint32 (_cgaf -1));
};

// SetProtectedAndHidden sets protected and hidden for given cellStyle
func (_aac CellStyle )SetProtection (protected bool ,hidden bool ){_aac ._gag .Protection =&_gb .CT_CellProtection {LockedAttr :&protected ,HiddenAttr :&hidden };};

// SetHidden hides or unhides the row
func (_gdac Row )SetHidden (hidden bool ){if !hidden {_gdac ._fagb .HiddenAttr =nil ;}else {_gdac ._fagb .HiddenAttr =_d .Bool (true );};};

// SetYSplit sets the row split point
func (_gfce SheetView )SetYSplit (v float64 ){_gfce .ensurePane ();_gfce ._gcad .Pane .YSplitAttr =_d .Float64 (v );};

// SetInlineString adds a string inline instead of in the shared strings table.
func (_ede Cell )SetInlineString (s string ){_ede .clearValue ();_ede ._aba .Is =_gb .NewCT_Rst ();_ede ._aba .Is .T =_d .String (s );_ede ._aba .TAttr =_gb .ST_CellTypeInlineStr ;};

// GetWidth returns a worksheet's column width.
func (_bdae *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_aefb :=range _bdae ._efeg .X ().Cols [0].Col {if int (_aefb .MinAttr )<=colIdx &&colIdx <=int (_aefb .MaxAttr ){return float64 (int (*_aefb .WidthAttr ));};};return 0;};

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_gga PatternFill )SetFgColor (c _fa .Color ){_gga ._fcb .FgColor =_gb .NewCT_Color ();_gga ._fcb .FgColor .RgbAttr =c .AsRGBAString ();};

// SetWidthCells is a no-op.
func (_gc AbsoluteAnchor )SetWidthCells (int32 ){};

// MergedCells returns the merged cell regions within the sheet.
func (_aegb *Sheet )MergedCells ()[]MergedCell {if _aegb ._ecbe .MergeCells ==nil {return nil ;};_agedf :=[]MergedCell {};for _ ,_fgga :=range _aegb ._ecbe .MergeCells .MergeCell {_agedf =append (_agedf ,MergedCell {_aegb ._gaca ,_aegb ,_fgga });};return _agedf ;
};

// Type returns the type of anchor
func (_cfg OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };func (_de Cell )getFormat ()string {if _de ._aba .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_baaf :=*_de ._aba .SAttr ;_feg :=_de ._bf .StyleSheet .GetCellStyle (_baaf );
_afa :=_de ._bf .StyleSheet .GetNumberFormat (_feg .NumberFormat ());return _afa .GetFormat ();};

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_gbg *_gb .CT_DataBar };func NewFills ()Fills {return Fills {_gb .NewCT_Fills ()}};

// GetValueAsNumber retrieves the cell's value as a number
func (_gba Cell )GetValueAsNumber ()(float64 ,error ){if _gba ._aba .V ==nil &&_gba ._aba .Is ==nil {return 0,nil ;};if _gba ._aba .TAttr ==_gb .ST_CellTypeS ||!_ee .IsNumber (*_gba ._aba .V ){return _fe .NaN (),_fg .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");
};return _g .ParseFloat (*_gba ._aba .V ,64);};

// GetEpoch returns a workbook's time epoch.
func (_cged *evalContext )GetEpoch ()_af .Time {return _cged ._efeg ._gaca .Epoch ()};

// SetXSplit sets the column split point
func (_dfd SheetView )SetXSplit (v float64 ){_dfd .ensurePane ();_dfd ._gcad .Pane .XSplitAttr =_d .Float64 (v );};

// Type returns the type of the rule
func (_bcfe ConditionalFormattingRule )Type ()_gb .ST_CfType {return _bcfe ._cbf .TypeAttr };

// SetColor sets teh color of the databar.
func (_gbbc DataBarScale )SetColor (c _fa .Color ){_gbbc ._gbg .Color =_gb .NewCT_Color ();_gbbc ._gbg .Color .RgbAttr =c .AsRGBAString ();};

// Comments returns the list of comments for this sheet
func (_gcg Comments )Comments ()[]Comment {_fecg :=[]Comment {};for _ ,_bcc :=range _gcg ._ccae .CommentList .Comment {_fecg =append (_fecg ,Comment {_gcg ._dfa ,_bcc ,_gcg ._ccae });};return _fecg ;};

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_acgg Cell )SetDate (d _af .Time ){_acgg .clearValue ();d =_efb (d );_dcca :=_acgg ._bf .Epoch ();if d .Before (_dcca ){_b .Log .Debug ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");
return ;};_abc :=d .Sub (_dcca );_gea :=new (_ec .Float );_gfe :=new (_ec .Float );_gfe .SetPrec (128);_gfe .SetUint64 (uint64 (_abc ));_fbc :=new (_ec .Float );_fbc .SetUint64 (24*60*60*1e9);_gea .Quo (_gfe ,_fbc );_gbdg ,_ :=_gea .Uint64 ();_acgg ._aba .V =_d .Stringf ("\u0025\u0064",_gbdg );
};

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_gfg ConditionalFormattingRule )SetDataBar ()DataBarScale {_gfg .clear ();_gfg .SetType (_gb .ST_CfTypeDataBar );_gfg ._cbf .DataBar =_gb .NewCT_DataBar ();_bdca :=DataBarScale {_gfg ._cbf .DataBar };_bdca .SetShowValue (true );_bdca .SetMinLength (10);
_bdca .SetMaxLength (90);return _bdca ;};

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_aaaf NumberFormat )ID ()uint32 {return _aaaf ._dfce .NumFmtIdAttr };func (_fcad *Sheet )addNumberedRowFast (_agfd uint32 )Row {_fcbb :=_gb .NewCT_Row ();_fcbb .RAttr =_d .Uint32 (_agfd );_fcad ._ecbe .SheetData .Row =append (_fcad ._ecbe .SheetData .Row ,_fcbb );
return Row {_fcad ._gaca ,_fcad ,_fcbb };};

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_baeg *evalContext )GetLabelPrefix (cellRef string )string {return _baeg ._efeg .Cell (cellRef ).getLabelPrefix ();};

// HasFormula returns true if the cell has an asoociated formula.
func (_afdc Cell )HasFormula ()bool {return _afdc ._aba .F !=nil };

// X returns the inner wrapped XML type.
func (_cgf Comment )X ()*_gb .CT_Comment {return _cgf ._geg };

// SetItalic causes the text to be displayed in italic.
func (_bgcg RichTextRun )SetItalic (b bool ){_bgcg .ensureRpr ();_bgcg ._bffe .RPr .I =_gb .NewCT_BooleanProperty ();_bgcg ._bffe .RPr .I .ValAttr =_d .Bool (b );};

// SetOperator sets the operator for the rule.
func (_abg ConditionalFormattingRule )SetOperator (t _gb .ST_ConditionalFormattingOperator ){_abg ._cbf .OperatorAttr =t ;};

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_baad *Sheet )Cell (cellRef string )Cell {_fde ,_gfbg :=_ag .ParseCellReference (cellRef );if _gfbg !=nil {_b .Log .Debug ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_gfbg );
return _baad .AddRow ().AddCell ();};return _baad .Row (_fde .RowIdx ).Cell (_fde .Column );};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_bdce *_gb .CT_DefinedName };var _aaff =false ;func (_aaca Sheet )validateMergedCells ()error {_ecf :=map[uint64 ]struct{}{};for _ ,_fbea :=range _aaca .MergedCells (){_agfg ,_ggfb ,_dgad :=_ag .ParseRangeReference (_fbea .Reference ());
if _dgad !=nil {return _ddg .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_aaca .Name (),_fbea .Reference ());
};for _ccea :=_agfg .RowIdx ;_ccea <=_ggfb .RowIdx ;_ccea ++{for _eegd :=_agfg .ColumnIdx ;_eegd <=_ggfb .ColumnIdx ;_eegd ++{_decf :=uint64 (_ccea )<<32|uint64 (_eegd );if _ ,_dfede :=_ecf [_decf ];_dfede {return _ddg .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_aaca .Name ());
};_ecf [_decf ]=struct{}{};};};};return nil ;};func (_gbb Comments )getOrCreateAuthor (_faa string )uint32 {for _cee ,_adf :=range _gbb ._ccae .Authors .Author {if _adf ==_faa {return uint32 (_cee );};};_cgd :=uint32 (len (_gbb ._ccae .Authors .Author ));
_gbb ._ccae .Authors .Author =append (_gbb ._ccae .Authors .Author ,_faa );return _cgd ;};

// Sheet is a single sheet within a workbook.
type Sheet struct{_gaca *Workbook ;_bfaa *_gb .CT_Sheet ;_ecbe *_gb .Worksheet ;};

// SetMinLength sets the minimum bar length in percent.
func (_cgfd DataBarScale )SetMinLength (l uint32 ){_cgfd ._gbg .MinLengthAttr =_d .Uint32 (l )};

// CellStyle is a formatting style for a cell. CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_bae *Workbook ;_gag *_gb .CT_Xf ;_ddf *_gb .CT_CellXfs ;};

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_agbe *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_agba :=-1;for _dgee ,_bbdg :=range _agbe .Sheets (){if name ==_bbdg .Name (){_agba =_dgee ;break ;};};if _agba ==-1{return Sheet {},ErrorNotFound ;};return _agbe .CopySheet (_agba ,copiedSheetName );
};func (_bgg DataValidation )SetList ()DataValidationList {_bgg .clear ();_bgg ._daca .TypeAttr =_gb .ST_DataValidationTypeList ;_bgg ._daca .OperatorAttr =_gb .ST_DataValidationOperatorEqual ;return DataValidationList {_bgg ._daca };};func (_bcf CellStyle )SetShrinkToFit (b bool ){if _bcf ._gag .Alignment ==nil {_bcf ._gag .Alignment =_gb .NewCT_CellAlignment ();
};_bcf ._gag .ApplyAlignmentAttr =_d .Bool (true );if !b {_bcf ._gag .Alignment .ShrinkToFitAttr =nil ;}else {_bcf ._gag .Alignment .ShrinkToFitAttr =_d .Bool (b );};};

// MaxColumnIdx returns the max used column of the sheet.
func (_ceac Sheet )MaxColumnIdx ()uint32 {_acga :=uint32 (0);for _ ,_adbg :=range _ceac .Rows (){_adbb :=_adbg ._fagb .C ;if len (_adbb )> 0{_gcbb :=_adbb [len (_adbb )-1];_ebg ,_ :=_ag .ParseCellReference (*_gcbb .RAttr );if _acga < _ebg .ColumnIdx {_acga =_ebg .ColumnIdx ;
};};};return _acga ;};

// Index returns the index of the differential style.
func (_gdbg DifferentialStyle )Index ()uint32 {for _ccf ,_aadg :=range _gdbg ._eda .Dxf {if _gdbg ._bbb ==_aadg {return uint32 (_ccf );};};return 0;};

// CellMarker represents a cell position
type CellMarker struct{_gbef *_be .CT_Marker };

// X returns the inner wrapped XML type.
func (_ggbg ColorScale )X ()*_gb .CT_ColorScale {return _ggbg ._eca };

// Name returns the name of the defined name.
func (_aeef DefinedName )Name ()string {return _aeef ._bdce .NameAttr };

// SetUnderline controls if the run is underlined.
func (_ade RichTextRun )SetUnderline (u _gb .ST_UnderlineValues ){_ade .ensureRpr ();_ade ._bffe .RPr .U =_gb .NewCT_UnderlineProperty ();_ade ._bffe .RPr .U .ValAttr =u ;};

// SetHidden controls the visibility of a column.
func (_eeaf Column )SetHidden (b bool ){if !b {_eeaf ._beb .HiddenAttr =nil ;}else {_eeaf ._beb .HiddenAttr =_d .Bool (true );};};func (_ffd Font )SetSize (size float64 ){_ffd ._aag .Sz =[]*_gb .CT_FontSize {{ValAttr :size }}};func (_gcaf *Sheet )slideCellsLeft (_gdbd []*_gb .CT_Cell )[]*_gb .CT_Cell {for _ ,_feeg :=range _gdbd {_edcf ,_acca :=_ag .ParseCellReference (*_feeg .RAttr );
if _acca !=nil {return _gdbd ;};_gdcde :=_edcf .ColumnIdx -1;_bgba :=_ag .IndexToColumn (_gdcde )+_ddg .Sprintf ("\u0025\u0064",_edcf .RowIdx );_feeg .RAttr =&_bgba ;};return _gdbd ;};

// SetHeightCells is a no-op.
func (_fcg OneCellAnchor )SetHeightCells (int32 ){};

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_dfaab *_gb .Sst ;_cdfcb map[string ]int ;};

// X returns the inner wrapped XML type.
func (_cfc Comments )X ()*_gb .Comments {return _cfc ._ccae };

// Type returns the type of anchor
func (_egab TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_eeeg *Workbook )AddDrawing ()Drawing {_cgfef :=_be .NewWsDr ();_eeeg ._fcadf =append (_eeeg ._fcadf ,_cgfef );_acgf :=_d .AbsoluteFilename (_d .DocTypeSpreadsheet ,_d .DrawingType ,len (_eeeg ._fcadf ));_eeeg .ContentTypes .AddOverride (_acgf ,_d .DrawingContentType );
_eeeg ._egbg =append (_eeeg ._egbg ,_aga .NewRelationships ());return Drawing {_eeeg ,_cgfef };};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_cbab *Sheet )RecalculateFormulas (){_deab :=_ce .NewEvaluator ();_gcege :=_cbab .FormulaContext ();for _ ,_affa :=range _cbab .Rows (){for _ ,_gdfdgc :=range _affa .Cells (){if _gdfdgc .X ().F !=nil {_bbgb :=_gdfdgc .X ().F .Content ;if _gdfdgc .X ().F .TAttr ==_gb .ST_CellFormulaTypeShared &&len (_bbgb )==0{continue ;
};_gdge :=_deab .Eval (_gcege ,_bbgb ).AsString ();if _gdge .Type ==_ce .ResultTypeError {_b .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_bbgb ,_gdge .ErrorMessage );
_gdfdgc .X ().V =nil ;}else {if _gdge .Type ==_ce .ResultTypeNumber {_gdfdgc .X ().TAttr =_gb .ST_CellTypeN ;}else {_gdfdgc .X ().TAttr =_gb .ST_CellTypeInlineStr ;};_gdfdgc .X ().V =_d .String (_gdge .Value ());if _gdfdgc .X ().F .TAttr ==_gb .ST_CellFormulaTypeArray {if _gdge .Type ==_ce .ResultTypeArray {_cbab .setArray (_gdfdgc .Reference (),_gdge );
}else if _gdge .Type ==_ce .ResultTypeList {_cbab .setList (_gdfdgc .Reference (),_gdge );};}else if _gdfdgc .X ().F .TAttr ==_gb .ST_CellFormulaTypeShared &&_gdfdgc .X ().F .RefAttr !=nil {_cbeb ,_gfbe ,_gabc :=_ag .ParseRangeReference (*_gdfdgc .X ().F .RefAttr );
if _gabc !=nil {_b .Log .Debug ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_gabc );continue ;};
_cbab .setShared (_gdfdgc .Reference (),_cbeb ,_gfbe ,_bbgb );};};};};};};

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_fbg *_gb .CT_ConditionalFormatting };

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_cff Cell )SetBool (v bool ){_cff .clearValue ();_cff ._aba .V =_d .String (_g .Itoa (_fefb (v )));_cff ._aba .TAttr =_gb .ST_CellTypeB ;};type MergedCell struct{_cccf *Workbook ;_edfe *Sheet ;_ccbg *_gb .CT_MergeCell ;};

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_bffe *_gb .CT_RElt };

// LockSheet controls the locking of the sheet.
func (_fcce SheetProtection )LockSheet (b bool ){if !b {_fcce ._ecc .SheetAttr =nil ;}else {_fcce ._ecc .SheetAttr =_d .Bool (true );};};func (_bbc *Sheet )setArray (_eaed string ,_bdee _ce .Result )error {_dbbd ,_efbg :=_ag .ParseCellReference (_eaed );
if _efbg !=nil {return _efbg ;};for _bgee ,_dce :=range _bdee .ValueArray {_bbd :=_bbc .Row (_dbbd .RowIdx +uint32 (_bgee ));for _efgg ,_facg :=range _dce {_dbbf :=_bbd .Cell (_ag .IndexToColumn (_dbbd .ColumnIdx +uint32 (_efgg )));if _facg .Type !=_ce .ResultTypeEmpty {if _facg .IsBoolean {_dbbf .SetBool (_facg .ValueNumber !=0);
}else {_dbbf .SetCachedFormulaResult (_facg .String ());};};};};return nil ;};

// Fonts returns the list of fonts defined in the stylesheet.
func (_agedc StyleSheet )Fonts ()[]Font {_dada :=[]Font {};for _ ,_bafcd :=range _agedc ._geeec .Fonts .Font {_dada =append (_dada ,Font {_bafcd ,_agedc ._geeec });};return _dada ;};func (_fgd *Workbook )ensureSharedStringsRelationships (){_aeaa :=false ;
for _ ,_aaeg :=range _fgd .ContentTypes .X ().Override {if _aaeg .ContentTypeAttr ==_d .SharedStringsContentType {_aeaa =true ;break ;};};if !_aeaa {_fgd .ContentTypes .AddOverride (_ffce ,_d .SharedStringsContentType );};_deec :=false ;for _ ,_bbdd :=range _fgd ._bcca .Relationships (){if _bbdd .X ().TargetAttr ==_gbaa {_deec =true ;
break ;};};if !_deec {_fgd ._bcca .AddRelationship (_gbaa ,_d .SharedStringsType );};};

// Comment is a single comment within a sheet.
type Comment struct{_aggf *Workbook ;_geg *_gb .CT_Comment ;_dadd *_gb .Comments ;};

// SetHeightAuto sets the row height to be automatically determined.
func (_dcde Row )SetHeightAuto (){_dcde ._fagb .HtAttr =nil ;_dcde ._fagb .CustomHeightAttr =nil };

// SetHidden marks the defined name as hidden.
func (_bdd DefinedName )SetLocalSheetID (id uint32 ){_bdd ._bdce .LocalSheetIdAttr =_d .Uint32 (id )};

// IsBool returns true if the cell boolean value.
func (_eecf *evalContext )IsBool (cellRef string )bool {return _eecf ._efeg .Cell (cellRef ).IsBool ()};

// SortOrder is a column sort order.
//
//go:generate stringer -type=SortOrder
type SortOrder byte ;

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_gbcf Sheet )ValidateWithPath (path string )error {return _gbcf ._ecbe .ValidateWithPath (path )};func NewPatternFill (fills *_gb .CT_Fills )PatternFill {_bebc :=_gb .NewCT_Fill ();_bebc .PatternFill =_gb .NewCT_PatternFill ();return PatternFill {_bebc .PatternFill ,_bebc };
};

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _fb .ReaderAt ,size int64 )(*Workbook ,error ){const _bgge ="\u0073\u0070r\u0065\u0061\u0064s\u0068\u0065\u0065\u0074\u003a\u0052\u0065\u0061\u0064";if !_fd .GetLicenseKey ().IsLicensed ()&&!_aaff {_ddg .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");
_ddg .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");
return nil ,_fg .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_facc :=New ();_aeabb ,_bfgb :=_fd .GenRefId ("\u0073\u0072");if _bfgb !=nil {_b .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bfgb );
return nil ,_bfgb ;};_facc ._eded =_aeabb ;if _gbfcd :=_fd .Track (_facc ._eded ,_bgge );_gbfcd !=nil {_b .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gbfcd );return nil ,_gbfcd ;};_fceb ,_bfgb :=_bg .TempDir ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078");
if _bfgb !=nil {return nil ,_bfgb ;};_facc .TmpPath =_fceb ;_ccfg ,_bfgb :=_cf .NewReader (r ,size );if _bfgb !=nil {return nil ,_ddg .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_bfgb );};_gdfd :=[]*_cf .File {};
_gdfd =append (_gdfd ,_ccfg .File ...);_dbbbd :=false ;for _ ,_fbf :=range _gdfd {if _fbf .FileHeader .Name =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_dbbbd =true ;break ;};};if _dbbbd {_facc .CreateCustomProperties ();
};_cdee :=_ecd .DecodeMap {};_cdee .SetOnNewRelationshipFunc (_facc .onNewRelationship );_cdee .AddTarget (_d .ContentTypesFilename ,_facc .ContentTypes .X (),"",0);_cdee .AddTarget (_d .BaseRelsFilename ,_facc .Rels .X (),"",0);if _dgd :=_cdee .Decode (_gdfd );
_dgd !=nil {return nil ,_dgd ;};for _ ,_eece :=range _gdfd {if _eece ==nil {continue ;};if _gbfe :=_facc .AddExtraFileFromZip (_eece );_gbfe !=nil {return nil ,_gbfe ;};};if _dbbbd {_ceee :=false ;for _ ,_cag :=range _facc .Rels .X ().Relationship {if _cag .TargetAttr =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_ceee =true ;
break ;};};if !_ceee {_facc .AddCustomRelationships ();};};return _facc ,nil ;};

// SetNumberFormat applies a number format to a cell style avoiding redundancy. The function checks if the given string
// already exists in the saved number formats. If found, the existing number format is reused; otherwise,
// the new number format is added to the saved number formats collection. The number format is then applied to the cell style,
// affecting all styles that reference it by index.
func (_bad CellStyle )SetNumberFormat (s string ){var _cbbc NumberFormat ;if _bad ._bae .StyleSheet ._geeec .NumFmts ==nil {_bad ._bae .StyleSheet ._geeec .NumFmts =_gb .NewCT_NumFmts ();};_gdc :=_bad ._bae .StyleSheet ._geeec .NumFmts .NumFmt ;for _ ,_gbfc :=range _gdc {if _cce .DeepEqual (_gbfc .FormatCodeAttr ,s ){_cbbc =NumberFormat {_bad ._bae ,_gbfc };
_bad ._gag .ApplyNumberFormatAttr =_d .Bool (true );_bad ._gag .NumFmtIdAttr =_d .Uint32 (_cbbc .ID ());return ;};};_ebe :=_gb .NewCT_NumFmt ();_ebe .NumFmtIdAttr =uint32 (200+len (_bad ._bae .StyleSheet ._geeec .NumFmts .NumFmt ));_bad ._bae .StyleSheet ._geeec .NumFmts .NumFmt =append (_bad ._bae .StyleSheet ._geeec .NumFmts .NumFmt ,_ebe );
_bad ._bae .StyleSheet ._geeec .NumFmts .CountAttr =_d .Uint32 (uint32 (len (_bad ._bae .StyleSheet ._geeec .NumFmts .NumFmt )));_cbbc =NumberFormat {_bad ._bae ,_ebe };_cbbc ._dfce .FormatCodeAttr =s ;_bad ._gag .ApplyNumberFormatAttr =_d .Bool (true );
_bad ._gag .NumFmtIdAttr =_d .Uint32 (_cbbc .ID ());};

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_eaaf TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_eaaf ._dgfa .From }};

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_gcbf StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_egag :=range _gcbf .CellStyles (){if _egag .HasNumberFormat ()&&_egag .NumberFormat ()==uint32 (f ){return _egag ;};};_deadg :=_gcbf .AddCellStyle ();_deadg .SetNumberFormatStandard (f );
return _deadg ;};

// X returns the inner wrapped XML type.
func (_eaeg Table )X ()*_gb .Table {return _eaeg ._ddefc };func (_dagg Fill )SetPatternFill ()PatternFill {_dagg ._fdca .GradientFill =nil ;_dagg ._fdca .PatternFill =_gb .NewCT_PatternFill ();_dagg ._fdca .PatternFill .PatternTypeAttr =_gb .ST_PatternTypeSolid ;
return PatternFill {_dagg ._fdca .PatternFill ,_dagg ._fdca };};

// ExtractText returns text from the workbook as a WorkbookText object.
func (_dfae *Workbook )ExtractText ()*WorkbookText {_fddf :=[]*SheetText {};for _ ,_ffgce :=range _dfae .Sheets (){_fddf =append (_fddf ,&SheetText {Cells :_ffgce .ExtractText ().Cells });};return &WorkbookText {Sheets :_fddf };};

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_eeac StyleSheet )RemoveFont (f Font )error {for _gbceb ,_aacaf :=range _eeac ._geeec .Fonts .Font {if _aacaf ==f .X (){_eeac ._geeec .Fonts .Font =append (_eeac ._geeec .Fonts .Font [:_gbceb ],_eeac ._geeec .Fonts .Font [_gbceb +1:]...);return nil ;
};};return _fg .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_cgaa Cell )SetCachedFormulaResult (s string ){_cgaa ._aba .V =&s };func (_gcfd *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _gcfd .getAllCellsInFormulaArrays (false );};var _gce []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};


// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_gaf IconScale )AddFormatValue (t _gb .ST_CfvoType ,val string ){_gafe :=_gb .NewCT_Cfvo ();_gafe .TypeAttr =t ;_gafe .ValAttr =_d .String (val );_gaf ._bdbb .Cfvo =append (_gaf ._bdbb .Cfvo ,_gafe );};

// X returns the inner wrapped XML type.
func (_gdcf ConditionalFormatting )X ()*_gb .CT_ConditionalFormatting {return _gdcf ._fbg };

// MoveTo repositions the anchor without changing the objects size.
func (_deca TwoCellAnchor )MoveTo (col ,row int32 ){_cada :=_deca .TopLeft ();_aadedb :=_deca .BottomRight ();_ffgd :=_aadedb .Col ()-_cada .Col ();_ffgab :=_aadedb .Row ()-_cada .Row ();_cada .SetCol (col );_cada .SetRow (row );_aadedb .SetCol (col +_ffgd );
_aadedb .SetRow (row +_ffgab );};

// SetFill applies a fill to a cell style avoiding redundancy. The function checks if the given fill
// already exists in the saved fills. If found, the existing fill is reused; otherwise,
// the new fill is added to the saved fills collection. The fill is then applied to the cell style,
// affecting all styles that reference it by index.
func (_dbf CellStyle )SetFill (f Fill ){_cgbe :=f ._cdg .Fill ;for _ ,_gcff :=range _cgbe {if _cce .DeepEqual (_gcff ,f ._fdca ){f ._fdca =_gcff ;_dbf ._gag .FillIdAttr =_d .Uint32 (f .Index ());_dbf ._gag .ApplyFillAttr =_d .Bool (true );return ;};};f ._cdg .Fill =append (f ._cdg .Fill ,f ._fdca );
f ._cdg .CountAttr =_d .Uint32 (uint32 (len (f ._cdg .Fill )));_dbf ._gag .FillIdAttr =_d .Uint32 (f .Index ());_dbf ._gag .ApplyFillAttr =_d .Bool (true );};

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_gdcc Comment )SetCellReference (cellRef string ){_gdcc ._geg .RefAttr =cellRef };

// Rows returns all of the rows in a sheet.
func (_acgde *Sheet )Rows ()[]Row {_dcda :=[]Row {};for _ ,_eeca :=range _acgde ._ecbe .SheetData .Row {_dcda =append (_dcda ,Row {_acgde ._gaca ,_acgde ,_eeca });};return _dcda ;};

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;

// X returns the inner wrapped XML type.
func (_gac Row )X ()*_gb .CT_Row {return _gac ._fagb };

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_gcae *Workbook )AddDefinedName (name ,ref string )DefinedName {if _gcae ._fdea .DefinedNames ==nil {_gcae ._fdea .DefinedNames =_gb .NewCT_DefinedNames ();};_cgef :=_gb .NewCT_DefinedName ();_cgef .Content =ref ;_cgef .NameAttr =name ;_gcae ._fdea .DefinedNames .DefinedName =append (_gcae ._fdea .DefinedNames .DefinedName ,_cgef );
return DefinedName {_cgef };};

// X returns the inner wrapped XML type.
func (_bdaee NumberFormat )X ()*_gb .CT_NumFmt {return _bdaee ._dfce };

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_gabb *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_ef .Replace (rangeRef ,"\u0024","",-1);_gabb ._ecbe .AutoFilter =_gb .NewCT_AutoFilter ();_gabb ._ecbe .AutoFilter .RefAttr =_d .String (rangeRef );_gccg :="\u0027"+_gabb .Name ()+"\u0027\u0021";
var _cggf DefinedName ;for _ ,_cedac :=range _gabb ._gaca .DefinedNames (){if _cedac .Name ()==_cgbf {if _ef .HasPrefix (_cedac .Content (),_gccg ){_cggf =_cedac ;_cggf .SetContent (_gabb .RangeReference (rangeRef ));break ;};};};if _cggf .X ()==nil {_cggf =_gabb ._gaca .AddDefinedName (_cgbf ,_gabb .RangeReference (rangeRef ));
};for _decb ,_gagf :=range _gabb ._gaca ._cgcb {if _gagf ==_gabb ._ecbe {_cggf .SetLocalSheetID (uint32 (_decb ));};};};func (_gbfce Font )SetBold (b bool ){if b {_gbfce ._aag .B =[]*_gb .CT_BooleanProperty {{}};}else {_gbfce ._aag .B =nil ;};};type DifferentialStyle struct{_bbb *_gb .CT_Dxf ;
_eeff *Workbook ;_eda *_gb .CT_Dxfs ;};

// HasNumberFormat returns true if the cell style has a number format applied.
func (_adb CellStyle )HasNumberFormat ()bool {return _adb ._gag .NumFmtIdAttr !=nil &&_adb ._gag .ApplyNumberFormatAttr !=nil &&*_adb ._gag .ApplyNumberFormatAttr ;};

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_gfcg Sheet )Extents ()string {_fgcd ,_bfde ,_gfed ,_fagg :=_gfcg .ExtentsIndex ();return _ddg .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_fgcd ,_bfde ,_gfed ,_fagg );};

// SetNumber sets the cell type to number, and the value to the given number
func (_fac Cell )SetNumber (v float64 ){_fac .clearValue ();if _fe .IsNaN (v )||_fe .IsInf (v ,0){_fac ._aba .TAttr =_gb .ST_CellTypeE ;_fac ._aba .V =_d .String ("\u0023\u004e\u0055M\u0021");return ;};_fac ._aba .TAttr =_gb .ST_CellTypeN ;_fac ._aba .V =_d .String (_g .FormatFloat (v ,'f',-1,64));
};

// SetStyle applies a style to a cell avoiding redundancy. The function checks if the given style
// already exists in the saved styles. If found, the existing style is reused; otherwise,
// the new style is added to the saved styles collection. The style is then applied to the cell.
// This style is referenced in the generated XML via CellStyle.Index().
func (_bbg Cell )SetStyle (cs CellStyle ){_abb :=cs ._ddf .Xf ;for _ ,_cgg :=range _abb {if _cce .DeepEqual (_cgg ,cs ._gag ){cs ._gag =_cgg ;_bbg .SetStyleIndex (cs .Index ());return ;};};cs ._ddf .Xf =append (cs ._ddf .Xf ,cs ._gag );cs ._ddf .CountAttr =_d .Uint32 (uint32 (len (cs ._ddf .Xf )));
_bbg .SetStyleIndex (cs .Index ());};

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_cabaec :=_gb .NewStyleSheet ();_cabaec .CellStyleXfs =_gb .NewCT_CellStyleXfs ();_cabaec .CellXfs =_gb .NewCT_CellXfs ();_cabaec .CellStyles =_gb .NewCT_CellStyles ();_ffdg :=_gb .NewCT_CellStyle ();_ffdg .NameAttr =_d .String ("\u004e\u006f\u0072\u006d\u0061\u006c");
_ffdg .XfIdAttr =0;_ffdg .BuiltinIdAttr =_d .Uint32 (0);_cabaec .CellStyles .CellStyle =append (_cabaec .CellStyles .CellStyle ,_ffdg );_cabaec .CellStyles .CountAttr =_d .Uint32 (uint32 (len (_cabaec .CellStyles .CellStyle )));_acdd :=_gb .NewCT_Xf ();
_acdd .NumFmtIdAttr =_d .Uint32 (0);_acdd .FontIdAttr =_d .Uint32 (0);_acdd .FillIdAttr =_d .Uint32 (0);_acdd .BorderIdAttr =_d .Uint32 (0);_cabaec .CellStyleXfs .Xf =append (_cabaec .CellStyleXfs .Xf ,_acdd );_cabaec .CellStyleXfs .CountAttr =_d .Uint32 (uint32 (len (_cabaec .CellStyleXfs .Xf )));
_feba :=NewFills ();_cabaec .Fills =_feba .X ();_gabg :=_feba .appendFill ().SetPatternFill ();_gabg .SetPattern (_gb .ST_PatternTypeNone );_gabg =_feba .appendFill ().SetPatternFill ();_gabg .SetPattern (_gb .ST_PatternTypeGray125 );_cabaec .Fonts =_gb .NewCT_Fonts ();
_cabaec .Borders =_gb .NewCT_Borders ();_gabga :=StyleSheet {wb ,_cabaec };_gabga .appendBorder ().InitializeDefaults ();_bafc :=_gabga .appendFont ();_bafc .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_bafc .SetSize (11);_aabe :=_gb .NewCT_Xf ();
*_aabe =*_acdd ;_aabe .XfIdAttr =_d .Uint32 (0);_cabaec .CellXfs .Xf =append (_cabaec .CellXfs .Xf ,_aabe );_cabaec .CellXfs .CountAttr =_d .Uint32 (uint32 (len (_cabaec .CellXfs .Xf )));return _gabga ;};type evalContext struct{_efeg *Sheet ;_gada ,_bff uint32 ;
_ada map[string ]struct{};};

// LockStructure controls the locking of the workbook structure.
func (_dgbbf WorkbookProtection )LockStructure (b bool ){if !b {_dgbbf ._dfbd .LockStructureAttr =nil ;}else {_dgbbf ._dfbd .LockStructureAttr =_d .Bool (true );};};

// AnchorType is the type of anchor.
type AnchorType byte ;

// SetHeight sets the height of the anchored object.
func (_acbg OneCellAnchor )SetHeight (h _dg .Distance ){_acbg ._cdffe .Ext .CyAttr =int64 (h /_dg .EMU )};

// LockWindow controls the locking of the workbook windows.
func (_ecbfc WorkbookProtection )LockWindow (b bool ){if !b {_ecbfc ._dfbd .LockWindowsAttr =nil ;}else {_ecbfc ._dfbd .LockWindowsAttr =_d .Bool (true );};};

// DefinedNames returns a slice of all defined names in the workbook.
func (_ebfe *Workbook )DefinedNames ()[]DefinedName {if _ebfe ._fdea .DefinedNames ==nil {return nil ;};_facf :=[]DefinedName {};for _ ,_daff :=range _ebfe ._fdea .DefinedNames .DefinedName {_facf =append (_facf ,DefinedName {_daff });};return _facf ;};


// GetValueAsBool retrieves the cell's value as a boolean
func (_dab Cell )GetValueAsBool ()(bool ,error ){if _dab ._aba .TAttr !=_gb .ST_CellTypeB {return false ,_fg .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");
};if _dab ._aba .V ==nil {return false ,_fg .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _g .ParseBool (*_dab ._aba .V );};

// SetWidth sets the width of the anchored object.
func (_cegf OneCellAnchor )SetWidth (w _dg .Distance ){_cegf ._cdffe .Ext .CxAttr =int64 (w /_dg .EMU )};

// GetFormula returns the formula for a cell.
func (_cdfe Cell )GetFormula ()string {if _cdfe ._aba .F !=nil {return _cdfe ._aba .F .Content ;};return "";};func (_decc StyleSheet )appendBorder ()Border {_edcd :=_gb .NewCT_Border ();_decc ._geeec .Borders .Border =append (_decc ._geeec .Borders .Border ,_edcd );
_decc ._geeec .Borders .CountAttr =_d .Uint32 (uint32 (len (_decc ._geeec .Borders .Border )));return Border {_edcd ,_decc ._geeec .Borders };};

// GetFormat sets the number format code.
func (_acgc NumberFormat )GetFormat ()string {return _acgc ._dfce .FormatCodeAttr };

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_eab Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_eab .SetNumber (v );_eab .SetStyle (_eab ._bf .StyleSheet .GetOrCreateStandardNumberFormat (f ));};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_aabad *Workbook )RecalculateFormulas (){for _ ,_beacc :=range _aabad .Sheets (){_beacc .RecalculateFormulas ();};};

// IsWindowLocked returns whether the workbook windows are locked.
func (_dbfa WorkbookProtection )IsWindowLocked ()bool {return _dbfa ._dfbd .LockWindowsAttr !=nil &&*_dbfa ._dfbd .LockWindowsAttr ;};

// CellText is used for keeping text with references to a cell where it is located.
type CellText struct{Text string ;Cell Cell ;};func (_daad *Sheet )setList (_addg string ,_afadc _ce .Result )error {_cefd ,_bdcae :=_ag .ParseCellReference (_addg );if _bdcae !=nil {return _bdcae ;};_aeefg :=_daad .Row (_cefd .RowIdx );for _ddec ,_egea :=range _afadc .ValueList {_eedc :=_aeefg .Cell (_ag .IndexToColumn (_cefd .ColumnIdx +uint32 (_ddec )));
if _egea .Type !=_ce .ResultTypeEmpty {if _egea .IsBoolean {_eedc .SetBool (_egea .ValueNumber !=0);}else {_eedc .SetCachedFormulaResult (_egea .String ());};};};return nil ;};func _gceg ()*_be .CT_TwoCellAnchor {_fged :=_be .NewCT_TwoCellAnchor ();_fged .EditAsAttr =_be .ST_EditAsOneCell ;
_fged .From .Col =5;_fged .From .Row =0;_fged .From .ColOff .ST_CoordinateUnqualified =_d .Int64 (0);_fged .From .RowOff .ST_CoordinateUnqualified =_d .Int64 (0);_fged .To .Col =10;_fged .To .Row =20;_fged .To .ColOff .ST_CoordinateUnqualified =_d .Int64 (0);
_fged .To .RowOff .ST_CoordinateUnqualified =_d .Int64 (0);return _fged ;};

// X returns the inner wrapped XML type.
func (_ffa MergedCell )X ()*_gb .CT_MergeCell {return _ffa ._ccbg };

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_dcg DataValidation )SetRange (cellRange string ){_dcg ._daca .SqrefAttr =_gb .ST_Sqref {cellRange }};

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_cbeg *_gb .CT_DataValidation };

// SetPasswordHash sets the password hash to the input.
func (_gdgg WorkbookProtection )SetPasswordHash (pwHash string ){_gdgg ._dfbd .WorkbookPasswordAttr =_d .String (pwHash );};

// SetWidthCells is a no-op.
func (_abgb OneCellAnchor )SetWidthCells (int32 ){};

// SetStyle sets the cell style for an entire column.
func (_eeae Column )SetStyle (cs CellStyle ){_eeae ._beb .StyleAttr =_d .Uint32 (cs .Index ())};

// Reference returns the region of cells that are merged.
func (_abeb MergedCell )Reference ()string {return _abeb ._ccbg .RefAttr };func _cdgcc (_dgbd string ,_egfb uint32 ,_aaac bool )string {_baeb ,_fegg ,_fggfd :=_ag .ParseRangeReference (_dgbd );if _fggfd ==nil {_faccb ,_eabb :=_baeb .ColumnIdx ,_fegg .ColumnIdx ;
if _egfb >=_faccb &&_egfb <=_eabb {if _faccb ==_eabb {if _aaac {return "";}else {return _dgbd ;};}else {_cebc :=_fegg .Update (_cfd .UpdateActionRemoveColumn );return _ddg .Sprintf ("\u0025\u0073\u003a%\u0073",_baeb .String (),_cebc .String ());};}else if _egfb < _faccb {_dffe :=_baeb .Update (_cfd .UpdateActionRemoveColumn );
_aaae :=_fegg .Update (_cfd .UpdateActionRemoveColumn );return _ddg .Sprintf ("\u0025\u0073\u003a%\u0073",_dffe .String (),_aaae .String ());};}else {_cfff ,_eaga ,_aagg :=_ag .ParseColumnRangeReference (_dgbd );if _aagg !=nil {return "";};_badd ,_gcfa :=_cfff .ColumnIdx ,_eaga .ColumnIdx ;
if _egfb >=_badd &&_egfb <=_gcfa {if _badd ==_gcfa {if _aaac {return "";}else {return _dgbd ;};}else {_ccde :=_eaga .Update (_cfd .UpdateActionRemoveColumn );return _ddg .Sprintf ("\u0025\u0073\u003a%\u0073",_cfff .String (),_ccde .String ());};}else if _egfb < _badd {_bcd :=_cfff .Update (_cfd .UpdateActionRemoveColumn );
_effd :=_eaga .Update (_cfd .UpdateActionRemoveColumn );return _ddg .Sprintf ("\u0025\u0073\u003a%\u0073",_bcd .String (),_effd .String ());};};return "";};func (_dcdc DifferentialStyle )Fill ()Fill {if _dcdc ._bbb .Fill ==nil {_dcdc ._bbb .Fill =_gb .NewCT_Fill ();
};return Fill {_dcdc ._bbb .Fill ,nil };};

// SetWidth controls the width of a column.
func (_fgb Column )SetWidth (w _dg .Distance ){_fgb ._beb .WidthAttr =_d .Float64 (float64 (w /_dg .Character ));};type ConditionalFormattingRule struct{_cbf *_gb .CT_CfRule };

// AddRun adds a new run of text to the cell.
func (_efgb RichText )AddRun ()RichTextRun {_ddd :=_gb .NewCT_RElt ();_efgb ._eadb .R =append (_efgb ._eadb .R ,_ddd );return RichTextRun {_ddd };};

// SetShowRuler controls the visibility of the ruler
func (_gcfad SheetView )SetShowRuler (b bool ){if !b {_gcfad ._gcad .ShowRulerAttr =_d .Bool (false );}else {_gcfad ._gcad .ShowRulerAttr =nil ;};};

// SetRow set the row of the cell marker.
func (_gec CellMarker )SetRow (row int32 ){_gec ._gbef .Row =row };

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_dgge StyleSheet )AddNumberFormat ()NumberFormat {if _dgge ._geeec .NumFmts ==nil {_dgge ._geeec .NumFmts =_gb .NewCT_NumFmts ();};_bgac :=_gb .NewCT_NumFmt ();_bgac .NumFmtIdAttr =uint32 (200+len (_dgge ._geeec .NumFmts .NumFmt ));_dgge ._geeec .NumFmts .NumFmt =append (_dgge ._geeec .NumFmts .NumFmt ,_bgac );
_dgge ._geeec .NumFmts .CountAttr =_d .Uint32 (uint32 (len (_dgge ._geeec .NumFmts .NumFmt )));return NumberFormat {_dgge ._agdc ,_bgac };};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_ecdd TwoCellAnchor )SetWidthCells (w int32 ){_eedcd :=_ecdd .TopLeft ();_aede :=_ecdd .BottomRight ();_aede .SetCol (_eedcd .Col ()+w );};

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_gbce DataValidationCompare )SetValue (v string ){_gbce ._ceec .Formula1 =&v };func _gadd ()*_be .CT_AbsoluteAnchor {_fag :=_be .NewCT_AbsoluteAnchor ();return _fag };const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;AnchorTypeTwoCell ;
);

// IsEmpty checks if the cell style contains nothing.
func (_bdaf CellStyle )IsEmpty ()bool {return _bdaf ._bae ==nil ||_bdaf ._gag ==nil ||_bdaf ._ddf ==nil ||_bdaf ._ddf .Xf ==nil ;};func (_eeacc *Workbook )onNewRelationship (_baac *_ecd .DecodeMap ,_dcce ,_egd string ,_daf []*_cf .File ,_deada *_abd .Relationship ,_dcgg _ecd .Target )error {_ecea :=_d .DocTypeSpreadsheet ;
switch _egd {case _d .OfficeDocumentType :_eeacc ._fdea =_gb .NewWorkbook ();_baac .AddTarget (_dcce ,_eeacc ._fdea ,_egd ,0);_eeacc ._bcca =_aga .NewRelationships ();_baac .AddTarget (_ecd .RelationsPathFor (_dcce ),_eeacc ._bcca .X (),_egd ,0);_deada .TargetAttr =_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,0);
case _d .CorePropertiesType :_baac .AddTarget (_dcce ,_eeacc .CoreProperties .X (),_egd ,0);_deada .TargetAttr =_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,0);case _d .CustomPropertiesType :_baac .AddTarget (_dcce ,_eeacc .CustomProperties .X (),_egd ,0);
_deada .TargetAttr =_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,0);case _d .ExtendedPropertiesType :_baac .AddTarget (_dcce ,_eeacc .AppProperties .X (),_egd ,0);_deada .TargetAttr =_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,0);case _d .WorksheetType :_cggc :=_gb .NewWorksheet ();
_gccf :=uint32 (len (_eeacc ._cgcb ));_eeacc ._cgcb =append (_eeacc ._cgcb ,_cggc );_baac .AddTarget (_dcce ,_cggc ,_egd ,_gccf );_bagce :=_aga .NewRelationships ();_baac .AddTarget (_ecd .RelationsPathFor (_dcce ),_bagce .X (),_egd ,0);_eeacc ._bgff =append (_eeacc ._bgff ,_bagce );
_eeacc ._gdeg =append (_eeacc ._gdeg ,nil );_deada .TargetAttr =_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,len (_eeacc ._cgcb ));case _d .StylesType :_eeacc .StyleSheet =NewStyleSheet (_eeacc );_baac .AddTarget (_dcce ,_eeacc .StyleSheet .X (),_egd ,0);
_deada .TargetAttr =_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,0);case _d .ThemeType :_gdcdc :=_eed .NewTheme ();_eeacc ._aecae =append (_eeacc ._aecae ,_gdcdc );_baac .AddTarget (_dcce ,_gdcdc ,_egd ,0);_deada .TargetAttr =_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,len (_eeacc ._aecae ));
case _d .SharedStringsType :_eeacc .SharedStrings =NewSharedStrings ();_baac .AddTarget (_dcce ,_eeacc .SharedStrings .X (),_egd ,0);_deada .TargetAttr =_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,0);case _d .ThumbnailType :for _edcdg ,_dabg :=range _daf {if _dabg ==nil {continue ;
};if _dabg .Name ==_dcce {_febd ,_ddbb :=_dabg .Open ();if _ddbb !=nil {return _ddg .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_ddbb );};_eeacc .Thumbnail ,_ ,_ddbb =_ff .Decode (_febd );
_febd .Close ();if _ddbb !=nil {return _ddg .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_ddbb );};_daf [_edcdg ]=nil ;};};case _d .ImageType :for _dgdd ,_caea :=range _eeacc ._ddaa {_fgfbc :=_c .Clean (_dcce );
if _fgfbc ==_dgdd {_deada .TargetAttr =_caea ;return nil ;};};_cabf :=_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,len (_eeacc .Images )+1);for _abdg ,_edag :=range _daf {if _edag ==nil {continue ;};if _edag .Name ==_c .Clean (_dcce ){_gegeg ,_aefe :=_ecd .ExtractToDiskTmp (_edag ,_eeacc .TmpPath );
if _aefe !=nil {return _aefe ;};_bdcg ,_aefe :=_aga .ImageFromStorage (_gegeg );if _aefe !=nil {return _aefe ;};_bgfc :=_aga .MakeImageRef (_bdcg ,&_eeacc .DocBase ,_eeacc ._bcca );_bgfc .SetTarget (_cabf );_eeacc ._ddaa [_edag .Name ]=_cabf ;_eeacc .Images =append (_eeacc .Images ,_bgfc );
_daf [_abdg ]=nil ;};};_deada .TargetAttr =_cabf ;case _d .DrawingType :_cddfd :=_be .NewWsDr ();_cgagd :=uint32 (len (_eeacc ._fcadf ));_baac .AddTarget (_dcce ,_cddfd ,_egd ,_cgagd );_eeacc ._fcadf =append (_eeacc ._fcadf ,_cddfd );_defc :=_aga .NewRelationships ();
_baac .AddTarget (_ecd .RelationsPathFor (_dcce ),_defc .X (),_egd ,_cgagd );_eeacc ._egbg =append (_eeacc ._egbg ,_defc );_deada .TargetAttr =_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,len (_eeacc ._fcadf ));case _d .VMLDrawingType :_caeag :=_ed .NewContainer ();
_dagbe :=uint32 (len (_eeacc ._ddae ));_baac .AddTarget (_dcce ,_caeag ,_egd ,_dagbe );_eeacc ._ddae =append (_eeacc ._ddae ,_caeag );case _d .CommentsType :_eeacc ._gdeg [_dcgg .Index ]=_gb .NewComments ();_baac .AddTarget (_dcce ,_eeacc ._gdeg [_dcgg .Index ],_egd ,_dcgg .Index );
_deada .TargetAttr =_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,len (_eeacc ._gdeg ));case _d .ChartType :_gcec :=_dc .NewChartSpace ();_bagcf :=uint32 (len (_eeacc ._egaa ));_baac .AddTarget (_dcce ,_gcec ,_egd ,_bagcf );_eeacc ._egaa =append (_eeacc ._egaa ,_gcec );
_deada .TargetAttr =_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,len (_eeacc ._egaa ));_eeacc ._ggfe [_deada .TargetAttr ]=_gcec ;case _d .TableType :_gccb :=_gb .NewTable ();_aggfa :=uint32 (len (_eeacc ._bfeb ));_baac .AddTarget (_dcce ,_gccb ,_egd ,_aggfa );
_eeacc ._bfeb =append (_eeacc ._bfeb ,_gccb );_deada .TargetAttr =_d .RelativeFilename (_ecea ,_dcgg .Typ ,_egd ,len (_eeacc ._bfeb ));default:_b .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_dcce ,_egd );
};return nil ;};

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_agdf *Workbook )SetActiveSheet (s Sheet ){for _ebff ,_febab :=range _agdf ._cgcb {if s ._ecbe ==_febab {_agdf .SetActiveSheetIndex (uint32 (_ebff ));};};};

// ExtractText returns text from the sheet as a SheetText object.
func (_cfa *Sheet )ExtractText ()*SheetText {_bege :=[]CellText {};for _ ,_bfa :=range _cfa .Rows (){for _ ,_cffg :=range _bfa .Cells (){if !_cffg .IsEmpty (){if _ccdd :=_cffg .GetFormattedValue ();_ccdd !=""{_bege =append (_bege ,CellText {Text :_ccdd ,Cell :_cffg });
};};};};return &SheetText {Cells :_bege };};func (_ccegf Sheet )validateRowCellNumbers ()error {_ddgae :=map[uint32 ]struct{}{};for _ ,_gdaaf :=range _ccegf ._ecbe .SheetData .Row {if _gdaaf .RAttr !=nil {if _ ,_ddee :=_ddgae [*_gdaaf .RAttr ];_ddee {return _ddg .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_ccegf .Name (),*_gdaaf .RAttr );
};_ddgae [*_gdaaf .RAttr ]=struct{}{};};_ffbc :=map[string ]struct{}{};for _ ,_fbdea :=range _gdaaf .C {if _fbdea .RAttr ==nil {continue ;};if _ ,_cgdb :=_ffbc [*_fbdea .RAttr ];_cgdb {return _ddg .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_ccegf .Name (),*_fbdea .RAttr );
};_ffbc [*_fbdea .RAttr ]=struct{}{};};};return nil ;};

// Borders returns the list of borders defined in the stylesheet.
func (_gfaa StyleSheet )Borders ()[]Border {_dddac :=[]Border {};for _ ,_caf :=range _gfaa ._geeec .Borders .Border {_dddac =append (_dddac ,Border {_eb :_caf });};return _dddac ;};

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_abge DataValidationList )SetRange (cellRange string ){_abge ._cbeg .Formula1 =_d .String (cellRange );_abge ._cbeg .Formula2 =_d .String ("\u0030");};func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_fbdf :=NumberFormat {_dfce :_gb .NewCT_NumFmt ()};
_fbdf ._dfce .NumFmtIdAttr =uint32 (id );_fbdf ._dfce .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";switch id {case StandardFormat0 :_fbdf ._dfce .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_fbdf ._dfce .FormatCodeAttr ="\u0030";
case StandardFormat2 :_fbdf ._dfce .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_fbdf ._dfce .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";case StandardFormat4 :_fbdf ._dfce .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";
case StandardFormat9 :_fbdf ._dfce .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_fbdf ._dfce .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_fbdf ._dfce .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";
case StandardFormat12 :_fbdf ._dfce .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_fbdf ._dfce .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_fbdf ._dfce .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";
case StandardFormat15 :_fbdf ._dfce .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_fbdf ._dfce .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_fbdf ._dfce .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";
case StandardFormat18 :_fbdf ._dfce .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_fbdf ._dfce .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_fbdf ._dfce .FormatCodeAttr ="\u0068\u003a\u006d\u006d";
case StandardFormat21 :_fbdf ._dfce .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_fbdf ._dfce .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_fbdf ._dfce .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";
case StandardFormat38 :_fbdf ._dfce .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_fbdf ._dfce .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";
case StandardFormat40 :_fbdf ._dfce .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_fbdf ._dfce .FormatCodeAttr ="\u006d\u006d\u003as\u0073";
case StandardFormat46 :_fbdf ._dfce .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_fbdf ._dfce .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_fbdf ._dfce .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";
case StandardFormat49 :_fbdf ._dfce .FormatCodeAttr ="\u0040";};return _fbdf ;};

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_aag *_gb .CT_Font ;_aec *_gb .StyleSheet ;};

// ClearNumberFormat removes any number formatting from the style.
func (_ggb CellStyle )ClearNumberFormat (){_ggb ._gag .NumFmtIdAttr =nil ;_ggb ._gag .ApplyNumberFormatAttr =nil ;};func _aceb ()*_be .CT_OneCellAnchor {_daac :=_be .NewCT_OneCellAnchor ();return _daac };

// SetWidth is a no-op.
func (_accb TwoCellAnchor )SetWidth (w _dg .Distance ){};

// GetVerticalAlignment sets the vertical alignment of a cell style.
func (_dad CellStyle )GetVerticalAlignment ()_gb .ST_VerticalAlignment {if _dad ._gag .Alignment ==nil {return _gb .ST_VerticalAlignmentUnset ;};return _dad ._gag .Alignment .VerticalAttr ;};func (_gdba StyleSheet )GetCellStyle (id uint32 )CellStyle {for _aaba ,_befc :=range _gdba ._geeec .CellXfs .Xf {if uint32 (_aaba )==id {return CellStyle {_gdba ._agdc ,_befc ,_gdba ._geeec .CellXfs };
};};return CellStyle {};};type SheetProtection struct{_ecc *_gb .CT_SheetProtection };

// MoveTo is a no-op.
func (_bge AbsoluteAnchor )MoveTo (x ,y int32 ){};func _efb (_ca _af .Time )_af .Time {_ca =_ca .Local ();return _af .Date (_ca .Year (),_ca .Month (),_ca .Day (),_ca .Hour (),_ca .Minute (),_ca .Second (),_ca .Nanosecond (),_af .UTC );};

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_fgf Cell )SetRichTextString ()RichText {_fgf .clearValue ();_fgf ._aba .Is =_gb .NewCT_Rst ();_fgf ._aba .TAttr =_gb .ST_CellTypeInlineStr ;return RichText {_fgf ._aba .Is };};

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_dcdb *Sheet )SheetViews ()[]SheetView {if _dcdb ._ecbe .SheetViews ==nil {return nil ;};_eafd :=[]SheetView {};for _ ,_gabbe :=range _dcdb ._ecbe .SheetViews .SheetView {_eafd =append (_eafd ,SheetView {_gabbe });};return _eafd ;};const _cgbf ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";


// X returns the inner wrapped XML type.
func (_fecb WorkbookProtection )X ()*_gb .CT_WorkbookProtection {return _fecb ._dfbd };

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_ceec *_gb .CT_DataValidation };

// TopLeft is a no-op.
func (_cg AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_bbed Sheet )RangeReference (n string )string {_gbgc :=_ef .Split (n ,"\u003a");_dddf ,_ :=_ag .ParseCellReference (_gbgc [0]);_agga :=_ddg .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_dddf .Column ,_dddf .RowIdx );if len (_gbgc )==1{return _ddg .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_bbed .Name (),_agga );
};_fggf ,_ :=_ag .ParseCellReference (_gbgc [1]);_gab :=_ddg .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_fggf .Column ,_fggf .RowIdx );return _ddg .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_bbed .Name (),_agga ,_gab );
};

// X returns the inner wrapped XML type.
func (_gafa RichText )X ()*_gb .CT_Rst {return _gafa ._eadb };func (_cfce SortOrder )String ()string {if _cfce >=SortOrder (len (_fgbde )-1){return _ddg .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_cfce );
};return _efga [_fgbde [_cfce ]:_fgbde [_cfce +1]];};

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_aea Cell )SetTime (d _af .Time ){_aea .clearValue ();d =_efb (d );_dda :=_aea ._bf .Epoch ();if d .Before (_dda ){_b .Log .Debug ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");
return ;};_ebfa :=d .Sub (_dda );_gcf :=new (_ec .Float );_eef :=new (_ec .Float );_eef .SetPrec (128);_eef .SetUint64 (uint64 (_ebfa ));_affc :=new (_ec .Float );_affc .SetUint64 (24*60*60*1e9);_gcf .Quo (_eef ,_affc );_aea ._aba .V =_d .String (_gcf .Text ('g',20));
};

// SetConditionValue sets the condition value to be used for style applicaton.
func (_caec ConditionalFormattingRule )SetConditionValue (v string ){_caec ._cbf .Formula =[]string {v }};

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_gbcee Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_afeea :=[]Cell {};for _gdfdg :=uint32 (0);_gdfdg <=lastColIdx ;_gdfdg ++{_ffed :=_gbcee .Cell (_ag .IndexToColumn (_gdfdg ));_afeea =append (_afeea ,_ffed );};return _afeea ;};func (_gagd *Sheet )setShared (_fee string ,_bfgdd ,_cgaaf _ag .CellReference ,_eadfb string ){_begg :=_gagd .FormulaContext ();
_cgfe :=_ce .NewEvaluator ();for _dge :=_bfgdd .RowIdx ;_dge <=_cgaaf .RowIdx ;_dge ++{for _fbdba :=_bfgdd .ColumnIdx ;_fbdba <=_cgaaf .ColumnIdx ;_fbdba ++{_ebgg :=_dge -_bfgdd .RowIdx ;_dabbf :=_fbdba -_bfgdd .ColumnIdx ;_begg .SetOffset (_dabbf ,_ebgg );
_adfg :=_cgfe .Eval (_begg ,_eadfb );_bedc :=_ddg .Sprintf ("\u0025\u0073\u0025\u0064",_ag .IndexToColumn (_fbdba ),_dge );_dfedeb :=_gagd .Cell (_bedc );if _adfg .Type ==_ce .ResultTypeNumber {_dfedeb .X ().TAttr =_gb .ST_CellTypeN ;}else {_dfedeb .X ().TAttr =_gb .ST_CellTypeInlineStr ;
};_dfedeb .X ().V =_d .String (_adfg .Value ());};};_ =_cgfe ;_ =_begg ;};

// ClearFont clears any font configuration from the cell style.
func (_dac CellStyle )ClearFont (){_dac ._gag .FontIdAttr =nil ;_dac ._gag .ApplyFontAttr =nil };

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_dee ,_fgfg :=_db .Open (filename );if _fgfg !=nil {return nil ,_ddg .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_fgfg );};defer _dee .Close ();
_cdag ,_fgfg :=_db .Stat (filename );if _fgfg !=nil {return nil ,_ddg .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_fgfg );};_bdef ,_fgfg :=Read (_dee ,_cdag .Size ());if _fgfg !=nil {return nil ,_fgfg ;
};_agea ,_ :=_e .Abs (_e .Dir (filename ));_bdef ._bgeb =_e .Join (_agea ,filename );return _bdef ,nil ;};

// SetHeight is a nop-op.
func (_gefbc TwoCellAnchor )SetHeight (h _dg .Distance ){};

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_cgeb *Sheet )InitialView ()SheetView {if _cgeb ._ecbe .SheetViews ==nil ||len (_cgeb ._ecbe .SheetViews .SheetView )==0{return _cgeb .AddView ();};return SheetView {_cgeb ._ecbe .SheetViews .SheetView [0]};};

// SetRowOffset sets a column offset in absolute distance.
func (_eea CellMarker )SetRowOffset (m _dg .Distance ){_eea ._gbef .RowOff .ST_CoordinateUnqualified =_d .Int64 (int64 (m /_dg .EMU ));};

// AddCommentWithStyle adds a new comment styled in a default way
func (_bdf Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_aabd :=_bdf .AddComment (cellRef ,author );_aeb :=_aabd .AddRun ();_aeb .SetBold (true );_aeb .SetSize (10);_aeb .SetColor (_fa .Black );_aeb .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");
_aeb .SetText (author +"\u003a");_aeb =_aabd .AddRun ();_aeb .SetSize (10);_aeb .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_aeb .SetColor (_fa .Black );_aeb .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_caa ,_dabc :=_ag .ParseCellReference (cellRef );
if _dabc !=nil {return _dabc ;};_bdf ._dfa ._ddae [0].Shape =append (_bdf ._dfa ._ddae [0].Shape ,_ed .NewCommentShape (int64 (_caa .ColumnIdx ),int64 (_caa .RowIdx -1)));return nil ;};func (_aca Border )SetTop (style _gb .ST_BorderStyle ,c _fa .Color ){if _aca ._eb .Top ==nil {_aca ._eb .Top =_gb .NewCT_BorderPr ();
};_aca ._eb .Top .Color =_gb .NewCT_Color ();_aca ._eb .Top .Color .RgbAttr =c .AsRGBAString ();_aca ._eb .Top .StyleAttr =style ;};

// SetHeightCells is a no-op.
func (_bb AbsoluteAnchor )SetHeightCells (int32 ){};

// Border is a cell border configuraton.
type Border struct{_eb *_gb .CT_Border ;_cga *_gb .CT_Borders ;};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_bgd *Workbook )SetActiveSheetIndex (idx uint32 ){if _bgd ._fdea .BookViews ==nil {_bgd ._fdea .BookViews =_gb .NewCT_BookViews ();};if len (_bgd ._fdea .BookViews .WorkbookView )==0{_bgd ._fdea .BookViews .WorkbookView =append (_bgd ._fdea .BookViews .WorkbookView ,_gb .NewCT_BookView ());
};_bgd ._fdea .BookViews .WorkbookView [0].ActiveTabAttr =_d .Uint32 (idx );};

// ClearFill clears any fill configuration from the cell style.
func (_dfb CellStyle )ClearFill (){_dfb ._gag .FillIdAttr =nil ;_dfb ._gag .ApplyFillAttr =nil };func (_efc Cell )clearValue (){_efc ._aba .F =nil ;_efc ._aba .Is =nil ;_efc ._aba .V =nil ;_efc ._aba .TAttr =_gb .ST_CellTypeUnset ;};

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_fdab *Workbook )RemoveSheetByName (name string )error {_cead :=-1;for _deg ,_beae :=range _fdab .Sheets (){if name ==_beae .Name (){_cead =_deg ;break ;};};if _cead ==-1{return ErrorNotFound ;};return _fdab .RemoveSheet (_cead );};

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_gd ,_cbb int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_ced _dg .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_eg int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_gf _dg .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_cbd int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_afd _dg .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_bc _dg .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};

// SetSize sets the text size for a rich text run.
func (_ebeg RichTextRun )SetSize (m _dg .Distance ){_ebeg .ensureRpr ();_ebeg ._bffe .RPr .Sz =_gb .NewCT_FontSize ();_ebeg ._bffe .RPr .Sz .ValAttr =float64 (m /_dg .Point );};

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_fdfc TwoCellAnchor )SetHeightCells (h int32 ){_fdfc .SetHeight (0);_cddf :=_fdfc .TopLeft ();_acddb :=_fdfc .BottomRight ();_acddb .SetRow (_cddf .Row ()+h );};

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_gegd ConditionalFormattingRule )SetColorScale ()ColorScale {_gegd .clear ();_gegd .SetType (_gb .ST_CfTypeColorScale );_gegd ._cbf .ColorScale =_gb .NewCT_ColorScale ();return ColorScale {_gegd ._cbf .ColorScale };};func (_cdcb Fills )appendFill ()Fill {_efaa :=_gb .NewCT_Fill ();
_cdcb ._cdfg .Fill =append (_cdcb ._cdfg .Fill ,_efaa );_cdcb ._cdfg .CountAttr =_d .Uint32 (uint32 (len (_cdcb ._cdfg .Fill )));return Fill {_efaa ,_cdcb ._cdfg };};

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_bfcb :=uint16 (0);if len (s )> 0{for _bgbd :=len (s )-1;_bgbd >=0;_bgbd --{_efce :=s [_bgbd ];_bfcb =((_bfcb >>14)&0x01)|((_bfcb <<1)&0x7fff);_bfcb ^=uint16 (_efce );};_bfcb =((_bfcb >>14)&0x01)|((_bfcb <<1)&0x7fff);
_bfcb ^=uint16 (len (s ));_bfcb ^=(0x8000|('N'<<8)|'K');};return _ddg .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_bfcb ));};

// Type returns the type of anchor
func (_ccg AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };func (_aff Border )SetDiagonal (style _gb .ST_BorderStyle ,c _fa .Color ,up ,down bool ){if _aff ._eb .Diagonal ==nil {_aff ._eb .Diagonal =_gb .NewCT_BorderPr ();};_aff ._eb .Diagonal .Color =_gb .NewCT_Color ();
_aff ._eb .Diagonal .Color .RgbAttr =c .AsRGBAString ();_aff ._eb .Diagonal .StyleAttr =style ;if up {_aff ._eb .DiagonalUpAttr =_d .Bool (true );};if down {_aff ._eb .DiagonalDownAttr =_d .Bool (true );};};

// SetPriority sets the rule priority
func (_ggf ConditionalFormattingRule )SetPriority (p int32 ){_ggf ._cbf .PriorityAttr =p };

// BottomRight is a no-op.
func (_gafb OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};func (_bgeff *Sheet )getAllCellsInFormulaArrays (_cbde bool )(map[string ]bool ,error ){_dgeb :=_ce .NewEvaluator ();_efedf :=_bgeff .FormulaContext ();_cabg :=map[string ]bool {};
for _ ,_adgg :=range _bgeff .Rows (){for _ ,_gcabe :=range _adgg .Cells (){if _gcabe .X ().F !=nil {_cbca :=_gcabe .X ().F .Content ;if _gcabe .X ().F .TAttr ==_gb .ST_CellFormulaTypeArray {_ccfa :=_dgeb .Eval (_efedf ,_cbca ).AsString ();if _ccfa .Type ==_ce .ResultTypeError {_b .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_cbca ,_ccfa .ErrorMessage );
_gcabe .X ().V =nil ;};if _ccfa .Type ==_ce .ResultTypeArray {_abde ,_bbde :=_ag .ParseCellReference (_gcabe .Reference ());if _bbde !=nil {return map[string ]bool {},_bbde ;};if (_cbde &&len (_ccfa .ValueArray )==1)||(!_cbde &&len (_ccfa .ValueArray [0])==1){continue ;
};for _fgaf ,_ebeb :=range _ccfa .ValueArray {_cbbb :=_abde .RowIdx +uint32 (_fgaf );for _acbd :=range _ebeb {_aabdf :=_ag .IndexToColumn (_abde .ColumnIdx +uint32 (_acbd ));_cabg [_ddg .Sprintf ("\u0025\u0073\u0025\u0064",_aabdf ,_cbbb )]=true ;};};}else if _ccfa .Type ==_ce .ResultTypeList {_geacg ,_agdd :=_ag .ParseCellReference (_gcabe .Reference ());
if _agdd !=nil {return map[string ]bool {},_agdd ;};if _cbde ||len (_ccfa .ValueList )==1{continue ;};_adcb :=_geacg .RowIdx ;for _bcb :=range _ccfa .ValueList {_ebaf :=_ag .IndexToColumn (_geacg .ColumnIdx +uint32 (_bcb ));_cabg [_ddg .Sprintf ("\u0025\u0073\u0025\u0064",_ebaf ,_adcb )]=true ;
};};};};};};return _cabg ,nil ;};

// RemoveDefinedName removes an existing defined name.
func (_beef *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _fg .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");
};for _gcfc ,_geaa :=range _beef ._fdea .DefinedNames .DefinedName {if _geaa ==dn .X (){copy (_beef ._fdea .DefinedNames .DefinedName [_gcfc :],_beef ._fdea .DefinedNames .DefinedName [_gcfc +1:]);_beef ._fdea .DefinedNames .DefinedName [len (_beef ._fdea .DefinedNames .DefinedName )-1]=nil ;
_beef ._fdea .DefinedNames .DefinedName =_beef ._fdea .DefinedNames .DefinedName [:len (_beef ._fdea .DefinedNames .DefinedName )-1];return nil ;};};return _fg .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");
};

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_dead *Sheet )Column (idx uint32 )Column {for _ ,_cdbb :=range _dead ._ecbe .Cols {for _ ,_abec :=range _cdbb .Col {if idx >=_abec .MinAttr &&idx <=_abec .MaxAttr {return Column {_abec };};};};var _eaf *_gb .CT_Cols ;if len (_dead ._ecbe .Cols )==0{_eaf =_gb .NewCT_Cols ();
_dead ._ecbe .Cols =append (_dead ._ecbe .Cols ,_eaf );}else {_eaf =_dead ._ecbe .Cols [0];};_dca :=_gb .NewCT_Col ();_dca .MinAttr =idx ;_dca .MaxAttr =idx ;_eaf .Col =append (_eaf .Col ,_dca );return Column {_dca };};

// Column returns the cell column
func (_dgg Cell )Column ()(string ,error ){_gee ,_afca :=_ag .ParseCellReference (_dgg .Reference ());if _afca !=nil {return "",_afca ;};return _gee .Column ,nil ;};

// SetText sets the text to be displayed.
func (_fda RichTextRun )SetText (s string ){_fda ._bffe .T =s };

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};func (_ggac Row )renumberAs (_fcdg uint32 ){_ggac ._fagb .RAttr =_d .Uint32 (_fcdg );for _ ,_cbdc :=range _ggac .Cells (){_baf ,_cgac :=_ag .ParseCellReference (_cbdc .Reference ());if _cgac ==nil {_fagf :=_ddg .Sprintf ("\u0025\u0073\u0025\u0064",_baf .Column ,_fcdg );
_cbdc ._aba .RAttr =_d .String (_fagf );};};};

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_cfcgc StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _cfcgc ._geeec .Dxfs ==nil {_cfcgc ._geeec .Dxfs =_gb .NewCT_Dxfs ();};_debf :=_gb .NewCT_Dxf ();_cfcgc ._geeec .Dxfs .Dxf =append (_cfcgc ._geeec .Dxfs .Dxf ,_debf );_cfcgc ._geeec .Dxfs .CountAttr =_d .Uint32 (uint32 (len (_cfcgc ._geeec .Dxfs .Dxf )));
return DifferentialStyle {_debf ,_cfcgc ._agdc ,_cfcgc ._geeec .Dxfs };};

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_ebcb Row )Cells ()[]Cell {_gafc :=[]Cell {};_afcdf :=-1;_ebfb :=append ([]*_gb .CT_Cell {},_ebcb ._fagb .C ...);for _ ,_ffec :=range _ebfb {if _ffec .RAttr ==nil {_b .Log .Debug ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
continue ;};_cced ,_acgd :=_ag .ParseCellReference (*_ffec .RAttr );if _acgd !=nil {_b .Log .Debug ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_ffec .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
continue ;};_egcff :=int (_cced .ColumnIdx );if _egcff -_afcdf > 1{for _gaeb :=_afcdf +1;_gaeb < _egcff ;_gaeb ++{_gafc =append (_gafc ,_ebcb .Cell (_ag .IndexToColumn (uint32 (_gaeb ))));};};_afcdf =_egcff ;_gafc =append (_gafc ,Cell {_ebcb ._fabg ,_ebcb ._cabb ,_ebcb ._fagb ,_ffec });
};return _gafc ;};

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_gfdf *Sheet )Row (rowNum uint32 )Row {for _ ,_ddag :=range _gfdf ._ecbe .SheetData .Row {if _ddag .RAttr !=nil &&*_ddag .RAttr ==rowNum {return Row {_gfdf ._gaca ,_gfdf ,_ddag };};};return _gfdf .AddNumberedRow (rowNum );};func (_cfgd Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _aefa ,_feb ,_dgfc ,_gdg uint32 =1,1,0,0;
for _ ,_cacf :=range _cfgd .Rows (){if _cacf .RowNumber ()< _aefa {_aefa =_cacf .RowNumber ();}else if _cacf .RowNumber ()> _feb {_feb =_cacf .RowNumber ();};for _ ,_defg :=range _cacf .Cells (){_adbd ,_cage :=_ag .ParseCellReference (_defg .Reference ());
if _cage ==nil {if _adbd .ColumnIdx < _dgfc {_dgfc =_adbd .ColumnIdx ;}else if _adbd .ColumnIdx > _gdg {_gdg =_adbd .ColumnIdx ;};};};};return _ag .IndexToColumn (_dgfc ),_aefa ,_ag .IndexToColumn (_gdg ),_feb ;};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_gace *Workbook )GetFilename ()string {return _gace ._bgeb };func (_beac StandardFormat )String ()string {switch {case 0<=_beac &&_beac <=4:return _effa [_cabae [_beac ]:_cabae [_beac +1]];case 9<=_beac &&_beac <=22:_beac -=9;return _bgcc [_cgee [_beac ]:_cgee [_beac +1]];
case 37<=_beac &&_beac <=40:_beac -=37;return _gfadf [_debc [_beac ]:_debc [_beac +1]];case 45<=_beac &&_beac <=49:_beac -=45;return _cfab [_bdaab [_beac ]:_bdaab [_beac +1]];default:return _ddg .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_beac );
};};

// SetPassword sets the password hash to a hash of the input password.
func (_fefd SheetProtection )SetPassword (pw string ){_fefd .SetPasswordHash (PasswordHash (pw ))};

// SetHyperlink sets a hyperlink on a cell.
func (_ffe Cell )SetHyperlink (hl _aga .Hyperlink ){_bdb :=_ffe ._afdd ._ecbe ;if _bdb .Hyperlinks ==nil {_bdb .Hyperlinks =_gb .NewCT_Hyperlinks ();};_dag :=_aga .Relationship (hl );_ded :=_gb .NewCT_Hyperlink ();_ded .RefAttr =_ffe .Reference ();_ded .IdAttr =_d .String (_dag .ID ());
_bdb .Hyperlinks .Hyperlink =append (_bdb .Hyperlinks .Hyperlink ,_ded );};

// GetFormat returns a cell data format.
func (_fabd *evalContext )GetFormat (cellRef string )string {return _fabd ._efeg .Cell (cellRef ).getFormat ();};

// GetFont gets a Font from a cell style.
func (_ebd CellStyle )GetFont ()*_gb .CT_Font {if _dba :=_ebd ._gag .FontIdAttr ;_dba !=nil {_begb :=_ebd ._bae .StyleSheet .Fonts ();if int (*_dba )< len (_begb ){return _begb [int (*_dba )].X ();};};return nil ;};

// X returns the inner wrapped XML type.
func (_aeda SheetProtection )X ()*_gb .CT_SheetProtection {return _aeda ._ecc };

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_gbcg Comments )AddComment (cellRef string ,author string )RichText {_gda :=_gb .NewCT_Comment ();_gbcg ._ccae .CommentList .Comment =append (_gbcg ._ccae .CommentList .Comment ,_gda );_gda .RefAttr =cellRef ;_gda .AuthorIdAttr =_gbcg .getOrCreateAuthor (author );
_gda .Text =_gb .NewCT_Rst ();return RichText {_gda .Text };};

// SetContent sets the defined name content.
func (_gdec DefinedName )SetContent (s string ){_gdec ._bdce .Content =s };

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_cb AbsoluteAnchor )SetColOffset (m _dg .Distance ){_cb ._abf .Pos .XAttr .ST_CoordinateUnqualified =_d .Int64 (int64 (m /_dg .EMU ));};func (_edc ConditionalFormattingRule )InitializeDefaults (){_edc .SetType (_gb .ST_CfTypeCellIs );_edc .SetOperator (_gb .ST_ConditionalFormattingOperatorGreaterThan );
_edc .SetPriority (1);};

// PasswordHash returns the hash of the workbook password.
func (_feae WorkbookProtection )PasswordHash ()string {if _feae ._dfbd .WorkbookPasswordAttr ==nil {return "";};return *_feae ._dfbd .WorkbookPasswordAttr ;};

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_eac CellStyle )SetNumberFormatStandard (s StandardFormat ){_eac ._gag .NumFmtIdAttr =_d .Uint32 (uint32 (s ));_eac ._gag .ApplyNumberFormatAttr =_d .Bool (true );};

// DataValidation controls cell validation
type DataValidation struct{_daca *_gb .CT_DataValidation };func (_fef Border )SetRight (style _gb .ST_BorderStyle ,c _fa .Color ){if _fef ._eb .Right ==nil {_fef ._eb .Right =_gb .NewCT_BorderPr ();};_fef ._eb .Right .Color =_gb .NewCT_Color ();_fef ._eb .Right .Color .RgbAttr =c .AsRGBAString ();
_fef ._eb .Right .StyleAttr =style ;};

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_gbbcf *Sheet )AddHyperlink (url string )_aga .Hyperlink {for _eegfa ,_affg :=range _gbbcf ._gaca ._cgcb {if _affg ==_gbbcf ._ecbe {return _gbbcf ._gaca ._bgff [_eegfa ].AddHyperlink (url );};};return _aga .Hyperlink {};};func _fefb (_fca bool )int {if _fca {return 1;
};return 0;};

// AddView adds a sheet view.
func (_eeab *Sheet )AddView ()SheetView {if _eeab ._ecbe .SheetViews ==nil {_eeab ._ecbe .SheetViews =_gb .NewCT_SheetViews ();};_dcgb :=_gb .NewCT_SheetView ();_eeab ._ecbe .SheetViews .SheetView =append (_eeab ._ecbe .SheetViews .SheetView ,_dcgb );return SheetView {_dcgb };
};

// SetPattern sets the pattern of the fill.
func (_bea PatternFill )SetPattern (p _gb .ST_PatternType ){_bea ._fcb .PatternTypeAttr =p };

// PasswordHash returns the hash of the workbook password.
func (_ddda SheetProtection )PasswordHash ()string {if _ddda ._ecc .PasswordAttr ==nil {return "";};return *_ddda ._ecc .PasswordAttr ;};

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_ccgc *Sheet )SetDrawing (d Drawing ){var _egce _aga .Relationships ;for _bdgd ,_dcdcd :=range _ccgc ._gaca ._cgcb {if _dcdcd ==_ccgc ._ecbe {_egce =_ccgc ._gaca ._bgff [_bdgd ];break ;};};var _cdceb string ;for _ecad ,_cdgaf :=range d ._edd ._fcadf {if _cdgaf ==d ._agda {_fgfbe :=_egce .AddAutoRelationship (_d .DocTypeSpreadsheet ,_d .WorksheetType ,_ecad +1,_d .DrawingType );
_cdceb =_fgfbe .ID ();break ;};};_ccgc ._ecbe .Drawing =_gb .NewCT_Drawing ();_ccgc ._ecbe .Drawing .IdAttr =_cdceb ;};

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_bcffg Drawing )AddChart (at AnchorType )(_ab .Chart ,Anchor ){_fgfec :=_dc .NewChartSpace ();_bcffg ._edd ._egaa =append (_bcffg ._edd ._egaa ,_fgfec );_gdcd :=_d .AbsoluteFilename (_d .DocTypeSpreadsheet ,_d .ChartContentType ,len (_bcffg ._edd ._egaa ));
_bcffg ._edd .ContentTypes .AddOverride (_gdcd ,_d .ChartContentType );var _caae string ;for _cdff ,_cfbe :=range _bcffg ._edd ._fcadf {if _cfbe ==_bcffg ._agda {_egf :=_d .RelativeFilename (_d .DocTypeSpreadsheet ,_d .DrawingType ,_d .ChartType ,len (_bcffg ._edd ._egaa ));
_gedc :=_bcffg ._edd ._egbg [_cdff ].AddRelationship (_egf ,_d .ChartType );_caae =_gedc .ID ();break ;};};var _gdab Anchor ;var _bfcc *_be .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_gbcd :=_gadd ();_bcffg ._agda .EG_Anchor =append (_bcffg ._agda .EG_Anchor ,&_be .EG_Anchor {AbsoluteAnchor :_gbcd });
_gbcd .Choice =&_be .EG_ObjectChoicesChoice {};_gbcd .Choice .GraphicFrame =_be .NewCT_GraphicalObjectFrame ();_bfcc =_gbcd .Choice .GraphicFrame ;_gdab =AbsoluteAnchor {_gbcd };case AnchorTypeOneCell :_edac :=_aceb ();_bcffg ._agda .EG_Anchor =append (_bcffg ._agda .EG_Anchor ,&_be .EG_Anchor {OneCellAnchor :_edac });
_edac .Choice =&_be .EG_ObjectChoicesChoice {};_edac .Choice .GraphicFrame =_be .NewCT_GraphicalObjectFrame ();_bfcc =_edac .Choice .GraphicFrame ;_gdab =OneCellAnchor {_edac };case AnchorTypeTwoCell :_dcge :=_gceg ();_bcffg ._agda .EG_Anchor =append (_bcffg ._agda .EG_Anchor ,&_be .EG_Anchor {TwoCellAnchor :_dcge });
_dcge .Choice =&_be .EG_ObjectChoicesChoice {};_dcge .Choice .GraphicFrame =_be .NewCT_GraphicalObjectFrame ();_bfcc =_dcge .Choice .GraphicFrame ;_gdab =TwoCellAnchor {_dcge };};_bfcc .NvGraphicFramePr =_be .NewCT_GraphicalObjectFrameNonVisual ();_bfcc .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_bcffg ._agda .EG_Anchor ));
_bfcc .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_bfcc .Graphic =_eed .NewGraphic ();_bfcc .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";
_dabb :=_dc .NewChart ();_dabb .IdAttr =_caae ;_bfcc .Graphic .GraphicData .Any =[]_d .Any {_dabb };_dabe :=_ab .MakeChart (_fgfec );_dabe .Properties ().SetSolidFill (_fa .White );_dabe .SetDisplayBlanksAs (_dc .ST_DispBlanksAsGap );return _dabe ,_gdab ;
};

// Protection controls the protection on an individual sheet.
func (_fdbd *Sheet )Protection ()SheetProtection {if _fdbd ._ecbe .SheetProtection ==nil {_fdbd ._ecbe .SheetProtection =_gb .NewCT_SheetProtection ();};return SheetProtection {_fdbd ._ecbe .SheetProtection };};

// RemoveSheet removes the sheet with the given index from the workbook.
func (_fbbb *Workbook )RemoveSheet (ind int )error {if _fbbb .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_daba :=range _fbbb ._bcca .Relationships (){if _daba .ID ()==_fbbb ._fdea .Sheets .Sheet [ind ].IdAttr {_fbbb ._bcca .Remove (_daba );break ;
};};_fbbb .ContentTypes .RemoveOverride (_d .AbsoluteFilename (_d .DocTypeSpreadsheet ,_d .WorksheetContentType ,ind +1));copy (_fbbb ._cgcb [ind :],_fbbb ._cgcb [ind +1:]);_fbbb ._cgcb =_fbbb ._cgcb [:len (_fbbb ._cgcb )-1];_baea :=_fbbb ._fdea .Sheets .Sheet [ind ];
copy (_fbbb ._fdea .Sheets .Sheet [ind :],_fbbb ._fdea .Sheets .Sheet [ind +1:]);_fbbb ._fdea .Sheets .Sheet =_fbbb ._fdea .Sheets .Sheet [:len (_fbbb ._fdea .Sheets .Sheet )-1];for _fdfb :=range _fbbb ._fdea .Sheets .Sheet {if _fbbb ._fdea .Sheets .Sheet [_fdfb ].SheetIdAttr > _baea .SheetIdAttr {_fbbb ._fdea .Sheets .Sheet [_fdfb ].SheetIdAttr --;
};};copy (_fbbb ._bgff [ind :],_fbbb ._bgff [ind +1:]);_fbbb ._bgff =_fbbb ._bgff [:len (_fbbb ._bgff )-1];copy (_fbbb ._gdeg [ind :],_fbbb ._gdeg [ind +1:]);_fbbb ._gdeg =_fbbb ._gdeg [:len (_fbbb ._gdeg )-1];return nil ;};

// X returns the inner wrapped XML type.
func (_ge Cell )X ()*_gb .CT_Cell {return _ge ._aba };func (_ebf Cell )getLabelPrefix ()string {if _ebf ._aba .SAttr ==nil {return "";};_fab :=*_ebf ._aba .SAttr ;_fdb :=_ebf ._bf .StyleSheet .GetCellStyle (_fab );switch _fdb ._gag .Alignment .HorizontalAttr {case _gb .ST_HorizontalAlignmentLeft :return "\u0027";
case _gb .ST_HorizontalAlignmentRight :return "\u0022";case _gb .ST_HorizontalAlignmentCenter :return "\u005e";case _gb .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};func (_bbf Font )SetName (name string ){_bbf ._aag .Name =[]*_gb .CT_FontName {{ValAttr :name }}};


// AddHyperlink creates and sets a hyperlink on a cell.
func (_bedb Cell )AddHyperlink (url string ){for _ceb ,_aab :=range _bedb ._bf ._cgcb {if _aab ==_bedb ._afdd ._ecbe {_bedb .SetHyperlink (_bedb ._bf ._bgff [_ceb ].AddHyperlink (url ));return ;};};};

// AddFormatValue adds a format value (databars require two).
func (_gdcfg DataBarScale )AddFormatValue (t _gb .ST_CfvoType ,val string ){_cdfa :=_gb .NewCT_Cfvo ();_cdfa .TypeAttr =t ;_cdfa .ValAttr =_d .String (val );_gdcfg ._gbg .Cfvo =append (_gdcfg ._gbg .Cfvo ,_cdfa );};

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_babg StyleSheet )Fills ()Fills {return Fills {_babg ._geeec .Fills }};

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_eeg Cell )SetStringByID (id int ){_eeg ._bf .ensureSharedStringsRelationships ();_eeg .clearValue ();_eeg ._aba .V =_d .String (_g .Itoa (id ));_eeg ._aba .TAttr =_gb .ST_CellTypeS ;};func (_ecdb Cell )GetRawValue ()(string ,error ){switch _ecdb ._aba .TAttr {case _gb .ST_CellTypeInlineStr :if _ecdb ._aba .Is ==nil ||_ecdb ._aba .Is .T ==nil {return "",nil ;
};return *_ecdb ._aba .Is .T ,nil ;case _gb .ST_CellTypeS :if _ecdb ._aba .V ==nil {return "",nil ;};_cdd ,_fc :=_g .Atoi (*_ecdb ._aba .V );if _fc !=nil {return "",_fc ;};return _ecdb ._bf .SharedStrings .GetString (_cdd );case _gb .ST_CellTypeStr :if _ecdb ._aba .F !=nil {return _ecdb ._aba .F .Content ,nil ;
};};if _ecdb ._aba .V ==nil {return "",nil ;};return *_ecdb ._aba .V ,nil ;};func (_defgg SheetView )ensurePane (){if _defgg ._gcad .Pane ==nil {_defgg ._gcad .Pane =_gb .NewCT_Pane ();_defgg ._gcad .Pane .ActivePaneAttr =_gb .ST_PaneBottomLeft ;};};

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_fgeb *Workbook )Close ()error {if _fgeb .TmpPath !=""{return _bg .RemoveAll (_fgeb .TmpPath );};return nil ;};

// Tables returns a slice of all defined tables in the workbook.
func (_gbgdb *Workbook )Tables ()[]Table {if _gbgdb ._bfeb ==nil {return nil ;};_edbf :=[]Table {};for _ ,_cadab :=range _gbgdb ._bfeb {_edbf =append (_edbf ,Table {_cadab });};return _edbf ;};

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_efff Comparer )LessCells (lhs ,rhs Cell )bool {if _efff .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_adce ,_dea :=lhs .getRawSortValue ();
_ddb ,_deag :=rhs .getRawSortValue ();switch {case _dea &&_deag :_cdca ,_ :=_g .ParseFloat (_adce ,64);_egcf ,_ :=_g .ParseFloat (_ddb ,64);return _cdca < _egcf ;case _dea :return true ;case _deag :return false ;};_adce =lhs .GetFormattedValue ();_ddb =rhs .GetFormattedValue ();
return _adce < _ddb ;};

// ClearProtection removes any protections applied to teh sheet.
func (_fgbag *Sheet )ClearProtection (){_fgbag ._ecbe .SheetProtection =nil };

// X returns the inner wrapped XML type.
func (_gfd Border )X ()*_gb .CT_Border {return _gfd ._eb };

// SetWrapped configures the cell to wrap text.
func (_fcd CellStyle )SetWrapped (b bool ){if _fcd ._gag .Alignment ==nil {_fcd ._gag .Alignment =_gb .NewCT_CellAlignment ();};if !b {_fcd ._gag .Alignment .WrapTextAttr =nil ;}else {_fcd ._gag .Alignment .WrapTextAttr =_d .Bool (true );_fcd ._gag .ApplyAlignmentAttr =_d .Bool (true );
};};

// X returns the inner wrapped XML type.
func (_ggff DifferentialStyle )X ()*_gb .CT_Dxf {return _ggff ._bbb };func (_abfe CellStyle )Index ()uint32 {for _cda ,_efbd :=range _abfe ._ddf .Xf {if _abfe ._gag ==_efbd {return uint32 (_cda );};};return 0;};

// SetStyle sets the style to be used for conditional rules
func (_dcd ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_dcd ._cbf .DxfIdAttr =_d .Uint32 (d .Index ());};

// Themes returns the array of workbook dml.Theme.
func (_cfea *Workbook )Themes ()[]*_eed .Theme {return _cfea ._aecae };

// ColOffset returns the offset from the row cell.
func (_aeg CellMarker )ColOffset ()_dg .Distance {if _aeg ._gbef .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _dg .Distance (float64 (*_aeg ._gbef .ColOff .ST_CoordinateUnqualified )*_dg .EMU );};func (_cbe *evalContext )Sheet (name string )_ce .Context {for _ ,_ccca :=range _cbe ._efeg ._gaca .Sheets (){if _ccca .Name ()==name {return _ccca .FormulaContext ();
};};return _ce .InvalidReferenceContext ;};

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_bgea *Sheet )InsertRow (rowNum int )Row {_cdge :=uint32 (rowNum );for _ ,_dcf :=range _bgea .Rows (){if _dcf ._fagb .RAttr !=nil &&*_dcf ._fagb .RAttr >=_cdge {*_dcf ._fagb .RAttr ++;for _ ,_gege :=range _dcf .Cells (){_gbgd ,_ffb :=_ag .ParseCellReference (_gege .Reference ());
if _ffb !=nil {continue ;};_gbgd .RowIdx ++;_gege ._aba .RAttr =_d .String (_gbgd .String ());};};};for _ ,_fdf :=range _bgea .MergedCells (){_ege ,_gdeb ,_afde :=_ag .ParseRangeReference (_fdf .Reference ());if _afde !=nil {continue ;};if int (_ege .RowIdx )>=rowNum {_ege .RowIdx ++;
};if int (_gdeb .RowIdx )>=rowNum {_gdeb .RowIdx ++;};_fgff :=_ddg .Sprintf ("\u0025\u0073\u003a%\u0073",_ege ,_gdeb );_fdf .SetReference (_fgff );};return _bgea .AddNumberedRow (_cdge );};

// Protection allows control over the workbook protections.
func (_bfgdb *Workbook )Protection ()WorkbookProtection {if _bfgdb ._fdea .WorkbookProtection ==nil {_bfgdb ._fdea .WorkbookProtection =_gb .NewCT_WorkbookProtection ();};return WorkbookProtection {_bfgdb ._fdea .WorkbookProtection };};

// GetFill gets a Fill from a cell style.
func (_gbdf CellStyle )GetFill ()*_gb .CT_Fill {if _eba :=_gbdf ._gag .FillIdAttr ;_eba !=nil {_afeg :=_gbdf ._bae .StyleSheet .Fills ().X ().Fill ;if int (*_eba )< len (_afeg ){return _afeg [int (*_eba )];};};return nil ;};

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_abfd Cell )SetString (s string )int {_abfd ._bf .ensureSharedStringsRelationships ();_abfd .clearValue ();_cfe :=_abfd ._bf .SharedStrings .AddString (s );_abfd ._aba .V =_d .String (_g .Itoa (_cfe ));_abfd ._aba .TAttr =_gb .ST_CellTypeS ;return _cfe ;
};

// AddRule adds and returns a new rule that can be configured.
func (_dbbb ConditionalFormatting )AddRule ()ConditionalFormattingRule {_aade :=_gb .NewCT_CfRule ();_dbbb ._fbg .CfRule =append (_dbbb ._fbg .CfRule ,_aade );_abe :=ConditionalFormattingRule {_aade };_abe .InitializeDefaults ();_abe .SetPriority (int32 (len (_dbbb ._fbg .CfRule )+1));
return _abe ;};

// New constructs a new workbook.
func New ()*Workbook {_aged :=&Workbook {};_aged ._fdea =_gb .NewWorkbook ();_aged .AppProperties =_aga .NewAppProperties ();_aged .CoreProperties =_aga .NewCoreProperties ();_aged .StyleSheet =NewStyleSheet (_aged );_aged .Rels =_aga .NewRelationships ();
_aged ._bcca =_aga .NewRelationships ();_aged .Rels .AddRelationship (_d .RelativeFilename (_d .DocTypeSpreadsheet ,"",_d .ExtendedPropertiesType ,0),_d .ExtendedPropertiesType );_aged .Rels .AddRelationship (_d .RelativeFilename (_d .DocTypeSpreadsheet ,"",_d .CorePropertiesType ,0),_d .CorePropertiesType );
_aged .Rels .AddRelationship (_d .RelativeFilename (_d .DocTypeSpreadsheet ,"",_d .OfficeDocumentType ,0),_d .OfficeDocumentType );_aged ._bcca .AddRelationship (_d .RelativeFilename (_d .DocTypeSpreadsheet ,_d .OfficeDocumentType ,_d .StylesType ,0),_d .StylesType );
_aged .ContentTypes =_aga .NewContentTypes ();_aged .ContentTypes .AddDefault ("\u0076\u006d\u006c",_d .VMLDrawingContentType );_aged .ContentTypes .AddOverride (_d .AbsoluteFilename (_d .DocTypeSpreadsheet ,_d .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");
_aged .ContentTypes .AddOverride (_d .AbsoluteFilename (_d .DocTypeSpreadsheet ,_d .StylesType ,0),_d .SMLStyleSheetContentType );_aged .SharedStrings =NewSharedStrings ();_aged .ContentTypes .AddOverride (_d .AbsoluteFilename (_d .DocTypeSpreadsheet ,_d .SharedStringsType ,0),_d .SharedStringsContentType );
_aged ._bcca .AddRelationship (_d .RelativeFilename (_d .DocTypeSpreadsheet ,_d .OfficeDocumentType ,_d .SharedStringsType ,0),_d .SharedStringsType );_aged ._ddaa =map[string ]string {};return _aged ;};

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_bfb Cell )GetCachedFormulaResult ()string {if _bfb ._aba .V !=nil {return *_bfb ._aba .V ;};return "";};

// SheetText is an array of extracted text items which has some methods for representing extracted text from a sheet.
type SheetText struct{Cells []CellText ;};

// ClearProtection clears all workbook protections.
func (_gccgd *Workbook )ClearProtection (){_gccgd ._fdea .WorkbookProtection =nil };

// X returns the inner wrapped XML type.
func (_eddf SheetView )X ()*_gb .CT_SheetView {return _eddf ._gcad };

// IconScale maps values to icons.
type IconScale struct{_bdbb *_gb .CT_IconSet };

// X returns the inner wrapped XML type.
func (_cacg IconScale )X ()*_gb .CT_IconSet {return _cacg ._bdbb };func (_beda Cell )getRawSortValue ()(string ,bool ){if _beda .HasFormula (){_bgc :=_beda .GetCachedFormulaResult ();return _bgc ,_ee .IsNumber (_bgc );};_afb ,_ :=_beda .GetRawValue ();
return _afb ,_ee .IsNumber (_afb );};

// Cell returns the actual cell behind the merged region
func (_afab MergedCell )Cell ()Cell {_geee :=_afab .Reference ();if _bde :=_ef .Index (_afab .Reference (),"\u003a");_bde !=-1{_geee =_geee [0:_bde ];return _afab ._edfe .Cell (_geee );};return Cell {};};func (_fgg Cell )setLocked (_gcb bool ){_eff :=_fgg ._aba .SAttr ;
if _eff !=nil {_ecdc :=_fgg ._bf .StyleSheet .GetCellStyle (*_eff );if _ecdc ._gag .Protection ==nil {_ecdc ._gag .Protection =_gb .NewCT_CellProtection ();};_ecdc ._gag .Protection .LockedAttr =&_gcb ;};};func (_bggc RichTextRun )ensureRpr (){if _bggc ._bffe .RPr ==nil {_bggc ._bffe .RPr =_gb .NewCT_RPrElt ();
};};

// IsSheetLocked returns whether the sheet objects are locked.
func (_fbgg SheetProtection )IsObjectLocked ()bool {return _fbgg ._ecc .ObjectsAttr !=nil &&*_fbgg ._ecc .ObjectsAttr ;};func (_ggcf PatternFill )ClearBgColor (){_ggcf ._fcb .BgColor =nil };

// AddFormatValue adds a format value to be used to determine the cell background.
func (_aeac ColorScale )AddFormatValue (t _gb .ST_CfvoType ,val string ){_efed :=_gb .NewCT_Cfvo ();_efed .TypeAttr =t ;_efed .ValAttr =_d .String (val );_aeac ._eca .Cfvo =append (_aeac ._eca .Cfvo ,_efed );};func (_edg Cell )getLocked ()bool {if _edg ._aba .SAttr ==nil {return false ;
};_agd :=*_edg ._aba .SAttr ;_ae :=_edg ._bf .StyleSheet .GetCellStyle (_agd );return *_ae ._gag .Protection .LockedAttr ;};

// AddSheet adds a new sheet to a workbook.
func (_dade *Workbook )AddSheet ()Sheet {_ggbc :=_gb .NewCT_Sheet ();_ggbc .SheetIdAttr =1;for _ ,_fbdd :=range _dade ._fdea .Sheets .Sheet {if _ggbc .SheetIdAttr <=_fbdd .SheetIdAttr {_ggbc .SheetIdAttr =_fbdd .SheetIdAttr +1;};};_dade ._fdea .Sheets .Sheet =append (_dade ._fdea .Sheets .Sheet ,_ggbc );
_ggbc .NameAttr =_ddg .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_ggbc .SheetIdAttr );_caef :=_gb .NewWorksheet ();_caef .Dimension =_gb .NewCT_SheetDimension ();_caef .Dimension .RefAttr ="\u0041\u0031";_dade ._cgcb =append (_dade ._cgcb ,_caef );
_ecbfe :=_aga .NewRelationships ();_dade ._bgff =append (_dade ._bgff ,_ecbfe );_caef .SheetData =_gb .NewCT_SheetData ();_dade ._gdeg =append (_dade ._gdeg ,nil );_cfcc :=_d .DocTypeSpreadsheet ;_gccc :=_dade ._bcca .AddAutoRelationship (_cfcc ,_d .OfficeDocumentType ,len (_dade ._fdea .Sheets .Sheet ),_d .WorksheetType );
_ggbc .IdAttr =_gccc .ID ();_dade .ContentTypes .AddOverride (_d .AbsoluteFilename (_cfcc ,_d .WorksheetContentType ,len (_dade ._fdea .Sheets .Sheet )),_d .WorksheetContentType );return Sheet {_dade ,_ggbc ,_caef };};

// Author returns the author of the comment
func (_adcd Comment )Author ()string {if _adcd ._geg .AuthorIdAttr < uint32 (len (_adcd ._dadd .Authors .Author )){return _adcd ._dadd .Authors .Author [_adcd ._geg .AuthorIdAttr ];};return "";};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_agdg *Workbook )ClearCachedFormulaResults (){for _ ,_bdeb :=range _agdg .Sheets (){_bdeb .ClearCachedFormulaResults ();};};

// AddString adds a string to the shared string cache.
func (_bdg SharedStrings )AddString (v string )int {if _bgcgf ,_ccec :=_bdg ._cdfcb [v ];_ccec {return _bgcgf ;};_abag :=_gb .NewCT_Rst ();_abag .T =_d .String (v );_bdg ._dfaab .Si =append (_bdg ._dfaab .Si ,_abag );_aeca :=len (_bdg ._dfaab .Si )-1;_bdg ._cdfcb [v ]=_aeca ;
_bdg ._dfaab .CountAttr =_d .Uint32 (uint32 (len (_bdg ._dfaab .Si )));_bdg ._dfaab .UniqueCountAttr =_bdg ._dfaab .CountAttr ;return _aeca ;};type Table struct{_ddefc *_gb .Table };func (_ad Border )SetBottom (style _gb .ST_BorderStyle ,c _fa .Color ){if _ad ._eb .Bottom ==nil {_ad ._eb .Bottom =_gb .NewCT_BorderPr ();
};_ad ._eb .Bottom .Color =_gb .NewCT_Color ();_ad ._eb .Bottom .Color .RgbAttr =c .AsRGBAString ();_ad ._eb .Bottom .StyleAttr =style ;};func (_afdf Border )SetLeft (style _gb .ST_BorderStyle ,c _fa .Color ){if _afdf ._eb .Left ==nil {_afdf ._eb .Left =_gb .NewCT_BorderPr ();
};_afdf ._eb .Left .Color =_gb .NewCT_Color ();_afdf ._eb .Left .Color .RgbAttr =c .AsRGBAString ();_afdf ._eb .Left .StyleAttr =style ;};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_gbcb CellStyle )NumberFormat ()uint32 {if _gbcb ._gag .NumFmtIdAttr ==nil {return 0;};return *_gbcb ._gag .NumFmtIdAttr ;};type Fills struct{_cdfg *_gb .CT_Fills };

// Cell is a single cell within a sheet.
type Cell struct{_bf *Workbook ;_afdd *Sheet ;_add *_gb .CT_Row ;_aba *_gb .CT_Cell ;};

// SetHeight sets the height of the anchored object.
func (_afc AbsoluteAnchor )SetHeight (h _dg .Distance ){_afc ._abf .Ext .CyAttr =int64 (h /_dg .EMU )};

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_fgea Row )Cell (col string )Cell {_faf :=_ddg .Sprintf ("\u0025\u0073\u0025\u0064",col ,_fgea .RowNumber ());for _ ,_gbfcf :=range _fgea ._fagb .C {if _gbfcf .RAttr !=nil &&*_gbfcf .RAttr ==_faf {return Cell {_fgea ._fabg ,_fgea ._cabb ,_fgea ._fagb ,_gbfcf };
};};return _fgea .AddNamedCell (col );};func (_cgae *evalContext )Cell (ref string ,ev _ce .Evaluator )_ce .Result {if !_fdd (ref ){return _ce .MakeErrorResultType (_ce .ErrorTypeName ,"");};_gdd :=_cgae ._efeg .Name ()+"\u0021"+ref ;if _ddba ,_bdbg :=ev .GetFromCache (_gdd );
_bdbg {return _ddba ;};_cebg ,_efa :=_ag .ParseCellReference (ref );if _efa !=nil {return _ce .MakeErrorResult (_ddg .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_efa ));};if _cgae ._gada !=0&&!_cebg .AbsoluteColumn {_cebg .ColumnIdx +=_cgae ._gada ;
_cebg .Column =_ag .IndexToColumn (_cebg .ColumnIdx );};if _cgae ._bff !=0&&!_cebg .AbsoluteRow {_cebg .RowIdx +=_cgae ._bff ;};_eedg :=_cgae ._efeg .Cell (_cebg .String ());if _eedg .HasFormula (){if _ ,_ageg :=_cgae ._ada [ref ];_ageg {return _ce .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );
};_cgae ._ada [ref ]=struct{}{};_gaed :=ev .Eval (_cgae ,_eedg .GetFormula ());delete (_cgae ._ada ,ref );ev .SetCache (_gdd ,_gaed );return _gaed ;};if _eedg .IsEmpty (){_fga :=_ce .MakeEmptyResult ();ev .SetCache (_gdd ,_fga );return _fga ;}else if _eedg .IsNumber (){_bdbc ,_ :=_eedg .GetValueAsNumber ();
_gbed :=_ce .MakeNumberResult (_bdbc );ev .SetCache (_gdd ,_gbed );return _gbed ;}else if _eedg .IsBool (){_cefc ,_ :=_eedg .GetValueAsBool ();_dfaa :=_ce .MakeBoolResult (_cefc );ev .SetCache (_gdd ,_dfaa );return _dfaa ;};_gfeg ,_ :=_eedg .GetRawValue ();
if _eedg .IsError (){_ece :=_ce .MakeErrorResult ("");_ece .ValueString =_gfeg ;ev .SetCache (_gdd ,_ece );return _ece ;};_eaa :=_ce .MakeStringResult (_gfeg );ev .SetCache (_gdd ,_eaa );return _eaa ;};

// X returns the inner wrapped XML type.
func (_bcef DefinedName )X ()*_gb .CT_DefinedName {return _bcef ._bdce };func _cec (_dfc *Sheet )*evalContext {return &evalContext {_efeg :_dfc ,_ada :make (map[string ]struct{})};};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_gcad *_gb .CT_SheetView };

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_dbcda *Sheet )FormulaContext ()_ce .Context {return _cec (_dbcda )};

// Name returns the name of the table
func (_faee Table )Name ()string {if _faee ._ddefc .NameAttr !=nil {return *_faee ._ddefc .NameAttr ;};return "";};func (_dggb Font )SetItalic (b bool ){if b {_dggb ._aag .I =[]*_gb .CT_BooleanProperty {{}};}else {_dggb ._aag .I =nil ;};};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_afed Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _cfeb ,_ccef Cell ;for _ ,_ccc :=range lhs .Cells (){_bdag ,_ :=_ag .ParseCellReference (_ccc .Reference ());if _bdag .Column ==column {_cfeb =_ccc ;break ;};};for _ ,_bfgd :=range rhs .Cells (){_cac ,_ :=_ag .ParseCellReference (_bfgd .Reference ());
if _cac .Column ==column {_ccef =_bfgd ;break ;};};return _afed .LessCells (_cfeb ,_ccef );};

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_eca *_gb .CT_ColorScale };

// Validate attempts to validate the structure of a workbook.
func (_gaaf *Workbook )Validate ()error {if _gaaf ==nil ||_gaaf ._fdea ==nil {return _fg .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");
};_cffd :=uint32 (0);for _ ,_bcbf :=range _gaaf ._fdea .Sheets .Sheet {if _bcbf .SheetIdAttr > _cffd {_cffd =_bcbf .SheetIdAttr ;};};if _cffd !=uint32 (len (_gaaf ._cgcb )){return _ddg .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_cffd ,len (_gaaf ._cgcb ));
};_cdae :=map[string ]struct{}{};for _agfc ,_fea :=range _gaaf ._fdea .Sheets .Sheet {_ccfbd :=Sheet {_gaaf ,_fea ,_gaaf ._cgcb [_agfc ]};if _ ,_ddafe :=_cdae [_ccfbd .Name ()];_ddafe {return _ddg .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_agfc ,_ccfbd .Name ());
};_cdae [_ccfbd .Name ()]=struct{}{};if _fafbe :=_ccfbd .ValidateWithPath (_ddg .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_agfc ));_fafbe !=nil {return _fafbe ;};if _effaf :=_ccfbd .Validate ();
_effaf !=nil {return _effaf ;};};return nil ;};

// SetColOffset sets a column offset in absolute distance.
func (_gca CellMarker )SetColOffset (m _dg .Distance ){_gca ._gbef .ColOff .ST_CoordinateUnqualified =_d .Int64 (int64 (m /_dg .EMU ));};

// SetRowOffset sets the row offset of the two cell anchor
func (_ecbf TwoCellAnchor )SetRowOffset (m _dg .Distance ){_bafa :=m -_ecbf .TopLeft ().RowOffset ();_ecbf .TopLeft ().SetRowOffset (m );_ecbf .BottomRight ().SetRowOffset (_ecbf .BottomRight ().RowOffset ()+_bafa );};func (_fba PatternFill )X ()*_gb .CT_PatternFill {return _fba ._fcb };


// X returns the inner wrapped XML type.
func (_gde CellMarker )X ()*_be .CT_Marker {return _gde ._gbef };

// X returns the inner wrapped XML type.
func (_fbcg ConditionalFormattingRule )X ()*_gb .CT_CfRule {return _fbcg ._cbf };const _cgb ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_afgbf *Workbook ;_dfce *_gb .CT_NumFmt ;};

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_gabe TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_gabe ._dgfa .To }};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_bfg Comment )CellReference ()string {return _bfg ._geg .RefAttr };func (_ggbe Fill )Index ()uint32 {if _ggbe ._cdg ==nil {return 0;};for _fgbf ,_ecb :=range _ggbe ._cdg .Fill {if _ggbe ._fdca ==_ecb {return uint32 (_fgbf );};};return 0;};

// Text returns text from the sheet as one string separated with line breaks.
func (_afee *SheetText )Text ()string {_agf :=_cc .NewBuffer ([]byte {});for _ ,_bfd :=range _afee .Cells {if _bfd .Text !=""{_agf .WriteString (_bfd .Text );_agf .WriteString ("\u000a");};};return _agf .String ();};

// SetPassword sets the password hash to a hash of the input password.
func (_dccfd WorkbookProtection )SetPassword (pw string ){_dccfd .SetPasswordHash (PasswordHash (pw ))};const (DVOpGreater =_gb .ST_DataValidationOperatorGreaterThanOrEqual ;);func (_fgedd Sheet )validateSheetNames ()error {_acdb :=len ([]rune (_fgedd .Name ()));
if _acdb > 31{return _ddg .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_fgedd .Name (),_acdb );
};return nil ;};func (_bfc *evalContext )SetOffset (col ,row uint32 ){_bfc ._gada =col ;_bfc ._bff =row };

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_afga *Sheet )RemoveColumn (column string )error {_efgge ,_abdf :=_afga .getAllCellsInFormulaArraysForColumn ();if _abdf !=nil {return _abdf ;};_eagd :=_ag .ColumnToIndex (column );for _ ,_dbfc :=range _afga .Rows (){_ffga :=_ddg .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_dbfc .X ().RAttr );
if _ ,_bggg :=_efgge [_ffga ];_bggg {return nil ;};};for _ ,_bagc :=range _afga .Rows (){_afabc :=_bagc ._fagb .C ;for _cgc ,_cbaa :=range _afabc {_aeee ,_fbb :=_ag .ParseCellReference (*_cbaa .RAttr );if _fbb !=nil {return _fbb ;};if _aeee .ColumnIdx ==_eagd {_bagc ._fagb .C =append (_afabc [:_cgc ],_afga .slideCellsLeft (_afabc [_cgc +1:])...);
break ;}else if _aeee .ColumnIdx > _eagd {_bagc ._fagb .C =append (_afabc [:_cgc ],_afga .slideCellsLeft (_afabc [_cgc :])...);break ;};};};_abdf =_afga .updateAfterRemove (_eagd ,_cfd .UpdateActionRemoveColumn );if _abdf !=nil {return _abdf ;};_abdf =_afga .removeColumnFromNamedRanges (_eagd );
if _abdf !=nil {return _abdf ;};_abdf =_afga .removeColumnFromMergedCells (_eagd );if _abdf !=nil {return _abdf ;};for _ ,_cfbd :=range _afga ._gaca .Sheets (){_cfbd .RecalculateFormulas ();};return nil ;};const (StandardFormatGeneral StandardFormat =0;
StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;
StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;
StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;
StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;
StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;);

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_aecc *Workbook )RemoveCalcChain (){var _cdaeb string ;for _ ,_bbcc :=range _aecc ._bcca .Relationships (){if _bbcc .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_cdaeb ="\u0078\u006c\u002f"+_bbcc .Target ();
_aecc ._bcca .Remove (_bbcc );break ;};};if _cdaeb ==""{return ;};_aecc .ContentTypes .RemoveOverride (_cdaeb );for _bede ,_ceadd :=range _aecc .ExtraFiles {if _ceadd .ZipPath ==_cdaeb {_aecc .ExtraFiles [_bede ]=_aecc .ExtraFiles [len (_aecc .ExtraFiles )-1];
_aecc .ExtraFiles =_aecc .ExtraFiles [:len (_aecc .ExtraFiles )-1];return ;};};};func (_dccfg StyleSheet )appendFont ()Font {_bdfb :=_gb .NewCT_Font ();_dccfg ._geeec .Fonts .Font =append (_dccfg ._geeec .Fonts .Font ,_bdfb );_dccfg ._geeec .Fonts .CountAttr =_d .Uint32 (uint32 (len (_dccfg ._geeec .Fonts .Font )));
return Font {_bdfb ,_dccfg ._geeec };};

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_afcd Cell )SetFormulaArray (s string ){_ba :=_ce .ParseString (s );if _ba ==nil {return ;};_afcd .clearValue ();_afcd ._aba .TAttr =_gb .ST_CellTypeStr ;_afcd ._aba .F =_gb .NewCT_CellFormula ();_afcd ._aba .F .TAttr =_gb .ST_CellFormulaTypeArray ;
_afcd ._aba .F .Content =s ;};

// SetColOffset sets the column offset of the top-left anchor.
func (_def OneCellAnchor )SetColOffset (m _dg .Distance ){_def .TopLeft ().SetColOffset (m )};

// WorkbookText is an array of extracted text items which has some methods for representing extracted text from a workbook.
type WorkbookText struct{Sheets []*SheetText ;};

// SetRotation configures the cell to be rotated.
func (_ccd CellStyle )SetRotation (deg uint8 ){if _ccd ._gag .Alignment ==nil {_ccd ._gag .Alignment =_gb .NewCT_CellAlignment ();};_ccd ._gag .ApplyAlignmentAttr =_d .Bool (true );_ccd ._gag .Alignment .TextRotationAttr =_d .Uint8 (deg );};

// SetValues sets the possible values. This is incompatible with SetRange.
func (_dacf DataValidationList )SetValues (values []string ){_dacf ._cbeg .Formula1 =_d .String ("\u0022"+_ef .Join (values ,"\u002c")+"\u0022");_dacf ._cbeg .Formula2 =_d .String ("\u0030");};

// SetReference sets the regin of cells that the merged cell applies to.
func (_egggd MergedCell )SetReference (ref string ){_egggd ._ccbg .RefAttr =ref };

// GetString retrieves a string from the shared strings table by index.
func (_bece SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_ddg .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );
};if id > len (_bece ._dfaab .Si )-1{return "",_ddg .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_bece ._dfaab .Si ));
};_bbe :=_bece ._dfaab .Si [id ];if _bbe .T !=nil {return *_bbe .T ,nil ;};_bedf :="";for _ ,_dga :=range _bbe .R {if _dga .T !=""{_bedf +=_dga .T ;};};return _bedf ,nil ;};const (_effa ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";
_bgcc ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";
_gfadf ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";
_cfab ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";
);

// SetError sets the cell type to error and the value to the given error message.
func (_cdb Cell )SetError (msg string ){_cdb .clearValue ();_cdb ._aba .V =_d .String (msg );_cdb ._aba .TAttr =_gb .ST_CellTypeE ;};

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_dgfa *_be .CT_TwoCellAnchor };

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_aafe *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_edca :=_gb .NewCT_ConditionalFormatting ();_aafe ._ecbe .ConditionalFormatting =append (_aafe ._ecbe .ConditionalFormatting ,_edca );_fgfeg :=make (_gb .ST_Sqref ,0,0);
_edca .SqrefAttr =&_fgfeg ;for _ ,_dffb :=range cellRanges {*_edca .SqrefAttr =append (*_edca .SqrefAttr ,_dffb );};return ConditionalFormatting {_edca };};

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_dfaab :_gb .NewSst (),_cdfcb :make (map[string ]int )};};

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_gb .Comments )Comments {return Comments {w ,x }};

// GetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_edb CellStyle )GetHorizontalAlignment ()_gb .ST_HorizontalAlignment {if _edb ._gag .Alignment ==nil {return _gb .ST_HorizontalAlignmentUnset ;};return _edb ._gag .Alignment .HorizontalAttr ;};

// Row is a row within a spreadsheet.
type Row struct{_fabg *Workbook ;_cabb *Sheet ;_fagb *_gb .CT_Row ;};

// AddGradientStop adds a color gradient stop.
func (_fec ColorScale )AddGradientStop (color _fa .Color ){_ead :=_gb .NewCT_Color ();_ead .RgbAttr =color .AsRGBAString ();_fec ._eca .Color =append (_fec ._eca .Color ,_ead );};

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_egead *Workbook )Uses1904Dates ()bool {if _egead ._fdea .WorkbookPr ==nil ||_egead ._fdea .WorkbookPr .Date1904Attr ==nil {return false ;};return *_egead ._fdea .WorkbookPr .Date1904Attr ;};

// Comments returns the comments for a sheet.
func (_fcgc *Sheet )Comments ()Comments {for _ffcf ,_cbg :=range _fcgc ._gaca ._cgcb {if _cbg ==_fcgc ._ecbe {if _fcgc ._gaca ._gdeg [_ffcf ]==nil {_fcgc ._gaca ._gdeg [_ffcf ]=_gb .NewComments ();_fcgc ._gaca ._bgff [_ffcf ].AddAutoRelationship (_d .DocTypeSpreadsheet ,_d .WorksheetType ,_ffcf +1,_d .CommentsType );
_fcgc ._gaca .ContentTypes .AddOverride (_d .AbsoluteFilename (_d .DocTypeSpreadsheet ,_d .CommentsType ,_ffcf +1),_d .CommentsContentType );};if len (_fcgc ._gaca ._ddae )==0{_fcgc ._gaca ._ddae =append (_fcgc ._gaca ._ddae ,_ed .NewCommentDrawing ());
_ggca :=_fcgc ._gaca ._bgff [_ffcf ].AddAutoRelationship (_d .DocTypeSpreadsheet ,_d .WorksheetType ,1,_d .VMLDrawingType );if _fcgc ._ecbe .LegacyDrawing ==nil {_fcgc ._ecbe .LegacyDrawing =_gb .NewCT_LegacyDrawing ();};_fcgc ._ecbe .LegacyDrawing .IdAttr =_ggca .ID ();
};return Comments {_fcgc ._gaca ,_fcgc ._gaca ._gdeg [_ffcf ]};};};_b .Log .Debug ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");
return Comments {};};

// SaveToFile writes the workbook out to a file.
func (_gfgeb *Workbook )SaveToFile (path string )error {_bgae ,_ffafa :=_db .Create (path );if _ffafa !=nil {return _ffafa ;};defer _bgae .Close ();return _gfgeb .Save (_bgae );};func (_ffee *Sheet )removeColumnFromNamedRanges (_gge uint32 )error {for _ ,_fbeae :=range _ffee ._gaca .DefinedNames (){_bcac :=_fbeae .Name ();
_abbc :=_fbeae .Content ();_dgcbf :=_ef .Split (_abbc ,"\u0021");if len (_dgcbf )!=2{return _fg .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_abbc );};_eefb :=_dgcbf [0];if _ffee .Name ()==_eefb {_gcde :=_ffee ._gaca .RemoveDefinedName (_fbeae );
if _gcde !=nil {return _gcde ;};_bdaa :=_cdgcc (_dgcbf [1],_gge ,true );if _bdaa !=""{_gcgf :=_eefb +"\u0021"+_bdaa ;_ffee ._gaca .AddDefinedName (_bcac ,_gcgf );};};};_dece :=0;if _ffee ._ecbe .TableParts !=nil &&_ffee ._ecbe .TableParts .TablePart !=nil {_dece =len (_ffee ._ecbe .TableParts .TablePart );
};if _dece !=0{_gfad :=0;for _ ,_bccd :=range _ffee ._gaca .Sheets (){if _bccd .Name ()==_ffee .Name (){break ;}else {if _bccd ._ecbe .TableParts !=nil &&_bccd ._ecbe .TableParts .TablePart !=nil {_gfad +=len (_bccd ._ecbe .TableParts .TablePart );};};
};_aagb :=_ffee ._gaca ._bfeb [_gfad :_gfad +_dece ];for _cdbgg ,_ecgc :=range _aagb {_ccda :=_ecgc ;_ccda .RefAttr =_cdgcc (_ccda .RefAttr ,_gge ,false );_ffee ._gaca ._bfeb [_gfad +_cdbgg ]=_ccda ;};};return nil ;};

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_abf *_be .CT_AbsoluteAnchor };

// StyleSheet is a document style sheet.
type StyleSheet struct{_agdc *Workbook ;_geeec *_gb .StyleSheet ;};

// GetLocked returns true if the cell is locked.
func (_caecb *evalContext )GetLocked (cellRef string )bool {return _caecb ._efeg .Cell (cellRef ).getLocked ();};

// RowOffset returns the offset from the row cell.
func (_abbd CellMarker )RowOffset ()_dg .Distance {if _abbd ._gbef .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _dg .Distance (float64 (*_abbd ._gbef .RowOff .ST_CoordinateUnqualified )*_dg .EMU );};

// BottomRight is a no-op.
func (_afg AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};

// AddDataValidation adds a data validation rule to a sheet.
func (_cgde *Sheet )AddDataValidation ()DataValidation {if _cgde ._ecbe .DataValidations ==nil {_cgde ._ecbe .DataValidations =_gb .NewCT_DataValidations ();};_adfc :=_gb .NewCT_DataValidation ();_adfc .ShowErrorMessageAttr =_d .Bool (true );_cgde ._ecbe .DataValidations .DataValidation =append (_cgde ._ecbe .DataValidations .DataValidation ,_adfc );
_cgde ._ecbe .DataValidations .CountAttr =_d .Uint32 (uint32 (len (_cgde ._ecbe .DataValidations .DataValidation )));return DataValidation {_adfc };};

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_aga .DocBase ;_fdea *_gb .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_gdeg []*_gb .Comments ;_cgcb []*_gb .Worksheet ;_bgff []_aga .Relationships ;_bcca _aga .Relationships ;_aecae []*_eed .Theme ;_fcadf []*_be .WsDr ;
_egbg []_aga .Relationships ;_ddae []*_ed .Container ;_egaa []*_dc .ChartSpace ;_bfeb []*_gb .Table ;_bgeb string ;_ddaa map[string ]string ;_ggfe map[string ]*_dc .ChartSpace ;_eded string ;};

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_gfb Row )AddNamedCell (col string )Cell {_deb :=_gb .NewCT_Cell ();_deb .RAttr =_d .Stringf ("\u0025\u0073\u0025\u0064",col ,_gfb .RowNumber ());_dace :=-1;_cdfc :=_ag .ColumnToIndex (col );for _ddfc ,_ecba :=range _gfb ._fagb .C {_dgbg ,_cceg :=_ag .ParseCellReference (*_ecba .RAttr );
if _cceg !=nil {return Cell {};};if _cdfc < _dgbg .ColumnIdx {_dace =_ddfc ;break ;};};if _dace ==-1{_gfb ._fagb .C =append (_gfb ._fagb .C ,_deb );}else {_gfb ._fagb .C =append (_gfb ._fagb .C [:_dace ],append ([]*_gb .CT_Cell {_deb },_gfb ._fagb .C [_dace :]...)...);
};return Cell {_gfb ._fabg ,_gfb ._cabb ,_gfb ._fagb ,_deb };};

// SetFont applies a font to a cell style avoiding redundancy. The function checks if the given font
// already exists in the saved fonts. If found, the existing font is reused; otherwise,
// the new font is added to the saved fonts collection. The font is then applied to the cell style,
// affecting all styles that reference it by index.
func (_bcff CellStyle )SetFont (f Font ){_efe :=f ._aec .Fonts .Font ;for _ ,_fgfe :=range _efe {if _cce .DeepEqual (_fgfe ,f ._aag ){f ._aag =_fgfe ;_bcff ._gag .FontIdAttr =_d .Uint32 (f .Index ());_bcff ._gag .ApplyFontAttr =_d .Bool (true );return ;
};};f ._aec .Fonts .Font =append (f ._aec .Fonts .Font ,f ._aag );f ._aec .Fonts .CountAttr =_d .Uint32 (uint32 (len (f ._aec .Fonts .Font )));_bcff ._gag .FontIdAttr =_d .Uint32 (f .Index ());_bcff ._gag .ApplyFontAttr =_d .Bool (true );};

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_acb Cell )SetFormulaShared (formulaStr string ,rows ,cols uint32 )error {_bac :=_ce .ParseString (formulaStr );if _bac ==nil {return _fg .New (_ddg .Sprintf ("\u0043a\u006en\u006f\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0073",formulaStr ));
};_acb .clearValue ();_acb ._aba .TAttr =_gb .ST_CellTypeStr ;_acb ._aba .F =_gb .NewCT_CellFormula ();_acb ._aba .F .TAttr =_gb .ST_CellFormulaTypeShared ;_acb ._aba .F .Content =formulaStr ;_afe ,_aa :=_ag .ParseCellReference (_acb .Reference ());if _aa !=nil {return _aa ;
};_baa :=uint32 (0);for _ ,_ga :=range _acb ._afdd .Rows (){for _ ,_age :=range _ga ._fagb .C {if _age .F !=nil &&_age .F .SiAttr !=nil &&*_age .F .SiAttr >=_baa {_baa =*_age .F .SiAttr ;};};};_baa ++;_dcc :=_ddg .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_afe .Column ,_afe .RowIdx ,_ag .IndexToColumn (_afe .ColumnIdx +cols ),_afe .RowIdx +rows );
_acb ._aba .F .RefAttr =_d .String (_dcc );_acb ._aba .F .SiAttr =_d .Uint32 (_baa );_beg :=Sheet {_acb ._bf ,_acb ._afdd ._bfaa ,_acb ._afdd ._ecbe };for _bed :=_afe .RowIdx ;_bed <=_afe .RowIdx +rows ;_bed ++{for _egg :=_afe .ColumnIdx ;_egg <=_afe .ColumnIdx +cols ;
_egg ++{if _bed ==_afe .RowIdx &&_egg ==_afe .ColumnIdx {continue ;};_da :=_ddg .Sprintf ("\u0025\u0073\u0025\u0064",_ag .IndexToColumn (_egg ),_bed );_beg .Cell (_da ).Clear ();_beg .Cell (_da ).X ().F =_gb .NewCT_CellFormula ();_beg .Cell (_da ).X ().F .TAttr =_gb .ST_CellFormulaTypeShared ;
_beg .Cell (_da ).X ().F .SiAttr =_d .Uint32 (_baa );};};return nil ;};

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_bgf *Sheet )AddNumberedRow (rowNum uint32 )Row {_eaba :=_gb .NewCT_Row ();_eaba .RAttr =_d .Uint32 (rowNum );_bgf ._ecbe .SheetData .Row =append (_bgf ._ecbe .SheetData .Row ,_eaba );_a .Slice (_bgf ._ecbe .SheetData .Row ,func (_decd ,_cad int )bool {_fddc :=_bgf ._ecbe .SheetData .Row [_decd ].RAttr ;
_afabg :=_bgf ._ecbe .SheetData .Row [_cad ].RAttr ;if _fddc ==nil {return true ;};if _afabg ==nil {return true ;};return *_fddc < *_afabg ;});return Row {_bgf ._gaca ,_bgf ,_eaba };};

// IsDBCS returns if a workbook's default language is among DBCS.
func (_ddga *evalContext )IsDBCS ()bool {_gaa :=_ddga ._efeg ._gaca .CoreProperties .X ().Language ;if _gaa ==nil {return false ;};_effc :=string (_gaa .Data );for _ ,_fgfb :=range _gce {if _effc ==_fgfb {return true ;};};return false ;};

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_eadb *_gb .CT_Rst };func (_eefd *evalContext )NamedRange (ref string )_ce .Reference {for _ ,_bfe :=range _eefd ._efeg ._gaca .DefinedNames (){if _bfe .Name ()==ref {return _ce .MakeRangeReference (_bfe .Content ());};};for _ ,_cge :=range _eefd ._efeg ._gaca .Tables (){if _cge .Name ()==ref {return _ce .MakeRangeReference (_ddg .Sprintf ("\u0025\u0073\u0021%\u0073",_eefd ._efeg .Name (),_cge .Reference ()));
};};return _ce .ReferenceInvalid ;};

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_deaf *Workbook )AddImage (i _aga .Image )(_aga .ImageRef ,error ){_acfgd :=_aga .MakeImageRef (i ,&_deaf .DocBase ,_deaf ._bcca );if i .Data ==nil &&i .Path ==""{return _acfgd ,_fg .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");
};if i .Format ==""{return _acfgd ,_fg .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _acfgd ,_fg .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");
};if i .Path !=""{_gdbgc :=_bg .Add (i .Path );if _gdbgc !=nil {return _acfgd ,_gdbgc ;};};_deaf .Images =append (_deaf .Images ,_acfgd );return _acfgd ,nil ;};

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_ebdc *Sheet )SetBorder (cellRange string ,border Border )error {_cgfcf ,_fbdb ,_ggfg :=_ag .ParseRangeReference (cellRange );if _ggfg !=nil {return _ggfg ;};_adfd :=_ebdc ._gaca .StyleSheet .AddCellStyle ();_gfae :=_ebdc ._gaca .StyleSheet .AddBorder ();
_adfd .SetBorder (_gfae );_gfae ._eb .Top =border ._eb .Top ;_gfae ._eb .Left =border ._eb .Left ;_bdgc :=_ebdc ._gaca .StyleSheet .AddCellStyle ();_cgge :=_ebdc ._gaca .StyleSheet .AddBorder ();_bdgc .SetBorder (_cgge );_cgge ._eb .Top =border ._eb .Top ;
_cgge ._eb .Right =border ._eb .Right ;_afdg :=_ebdc ._gaca .StyleSheet .AddCellStyle ();_fgfd :=_ebdc ._gaca .StyleSheet .AddBorder ();_afdg .SetBorder (_fgfd );_fgfd ._eb .Top =border ._eb .Top ;_dagd :=_ebdc ._gaca .StyleSheet .AddCellStyle ();_ccfgc :=_ebdc ._gaca .StyleSheet .AddBorder ();
_dagd .SetBorder (_ccfgc );_ccfgc ._eb .Left =border ._eb .Left ;_daaa :=_ebdc ._gaca .StyleSheet .AddCellStyle ();_fcab :=_ebdc ._gaca .StyleSheet .AddBorder ();_daaa .SetBorder (_fcab );_fcab ._eb .Right =border ._eb .Right ;_cbea :=_ebdc ._gaca .StyleSheet .AddCellStyle ();
_eeea :=_ebdc ._gaca .StyleSheet .AddBorder ();_cbea .SetBorder (_eeea );_eeea ._eb .Bottom =border ._eb .Bottom ;_caba :=_ebdc ._gaca .StyleSheet .AddCellStyle ();_afgg :=_ebdc ._gaca .StyleSheet .AddBorder ();_caba .SetBorder (_afgg );_afgg ._eb .Bottom =border ._eb .Bottom ;
_afgg ._eb .Left =border ._eb .Left ;_afce :=_ebdc ._gaca .StyleSheet .AddCellStyle ();_bfcbf :=_ebdc ._gaca .StyleSheet .AddBorder ();_afce .SetBorder (_bfcbf );_bfcbf ._eb .Bottom =border ._eb .Bottom ;_bfcbf ._eb .Right =border ._eb .Right ;_cabbc :=_cgfcf .RowIdx ;
_affd :=_cgfcf .ColumnIdx ;_deaa :=_fbdb .RowIdx ;_cdgc :=_fbdb .ColumnIdx ;for _cbeag :=_cabbc ;_cbeag <=_deaa ;_cbeag ++{for _fbfg :=_affd ;_fbfg <=_cdgc ;_fbfg ++{_deef :=_ddg .Sprintf ("\u0025\u0073\u0025\u0064",_ag .IndexToColumn (_fbfg ),_cbeag );
switch {case _cbeag ==_cabbc &&_fbfg ==_affd :_ebdc .Cell (_deef ).SetStyle (_adfd );case _cbeag ==_cabbc &&_fbfg ==_cdgc :_ebdc .Cell (_deef ).SetStyle (_bdgc );case _cbeag ==_deaa &&_fbfg ==_affd :_ebdc .Cell (_deef ).SetStyle (_caba );case _cbeag ==_deaa &&_fbfg ==_cdgc :_ebdc .Cell (_deef ).SetStyle (_afce );
case _cbeag ==_cabbc :_ebdc .Cell (_deef ).SetStyle (_afdg );case _cbeag ==_deaa :_ebdc .Cell (_deef ).SetStyle (_cbea );case _fbfg ==_affd :_ebdc .Cell (_deef ).SetStyle (_dagd );case _fbfg ==_cdgc :_ebdc .Cell (_deef ).SetStyle (_daaa );};};};return nil ;
};

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_fbgd *Workbook )Save (w _fb .Writer )error {const _fcbbg ="\u0073\u0070\u0072\u0065ad\u0073\u0068\u0065\u0065\u0074\u003a\u0077\u0062\u002e\u0053\u0061\u0076\u0065";if !_fd .GetLicenseKey ().IsLicensed ()&&!_aaff {_ddg .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");
_ddg .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");
return _fg .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};if len (_fbgd ._eded )==0{_ecbfeg ,_aceea :=_fd .GenRefId ("\u0073\u0077");if _aceea !=nil {_b .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_aceea );
return _aceea ;};_fbgd ._eded =_ecbfeg ;};if _afeb :=_fd .Track (_fbgd ._eded ,_fcbbg );_afeb !=nil {_b .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_afeb );return _afeb ;};_ddgg :=_cf .NewWriter (w );defer _ddgg .Close ();_fecf :=_d .DocTypeSpreadsheet ;
if _ccaed :=_ecd .MarshalXML (_ddgg ,_d .BaseRelsFilename ,_fbgd .Rels .X ());_ccaed !=nil {return _ccaed ;};if _acfg :=_ecd .MarshalXMLByType (_ddgg ,_fecf ,_d .ExtendedPropertiesType ,_fbgd .AppProperties .X ());_acfg !=nil {return _acfg ;};if _bega :=_ecd .MarshalXMLByType (_ddgg ,_fecf ,_d .CorePropertiesType ,_fbgd .CoreProperties .X ());
_bega !=nil {return _bega ;};_dfga :=_d .AbsoluteFilename (_fecf ,_d .OfficeDocumentType ,0);if _geb :=_ecd .MarshalXML (_ddgg ,_dfga ,_fbgd ._fdea );_geb !=nil {return _geb ;};if _acab :=_ecd .MarshalXML (_ddgg ,_ecd .RelationsPathFor (_dfga ),_fbgd ._bcca .X ());
_acab !=nil {return _acab ;};if _decg :=_ecd .MarshalXMLByType (_ddgg ,_fecf ,_d .StylesType ,_fbgd .StyleSheet .X ());_decg !=nil {return _decg ;};for _affgd ,_adcc :=range _fbgd ._aecae {if _ddc :=_ecd .MarshalXMLByTypeIndex (_ddgg ,_fecf ,_d .ThemeType ,_affgd +1,_adcc );
_ddc !=nil {return _ddc ;};};for _bfce ,_fcae :=range _fbgd ._cgcb {_fcae .Dimension .RefAttr =Sheet {_fbgd ,nil ,_fcae }.Extents ();_agcd :=_d .AbsoluteFilename (_fecf ,_d .WorksheetType ,_bfce +1);_ecd .MarshalXML (_ddgg ,_agcd ,_fcae );_ecd .MarshalXML (_ddgg ,_ecd .RelationsPathFor (_agcd ),_fbgd ._bgff [_bfce ].X ());
};if _cade :=_ecd .MarshalXMLByType (_ddgg ,_fecf ,_d .SharedStringsType ,_fbgd .SharedStrings .X ());_cade !=nil {return _cade ;};if _fbgd .CustomProperties .X ()!=nil {if _gbdfb :=_ecd .MarshalXMLByType (_ddgg ,_fecf ,_d .CustomPropertiesType ,_fbgd .CustomProperties .X ());
_gbdfb !=nil {return _gbdfb ;};};if _fbgd .Thumbnail !=nil {_adde :=_d .AbsoluteFilename (_fecf ,_d .ThumbnailType ,0);_deed ,_cffgg :=_ddgg .Create (_adde );if _cffgg !=nil {return _cffgg ;};if _aaafc :=_dd .Encode (_deed ,_fbgd .Thumbnail ,nil );_aaafc !=nil {return _aaafc ;
};};for _fege ,_ccbgg :=range _fbgd ._egaa {_bagb :=_d .AbsoluteFilename (_fecf ,_d .ChartType ,_fege +1);_ecd .MarshalXML (_ddgg ,_bagb ,_ccbgg );};for _acfb ,_bfbd :=range _fbgd ._bfeb {_ffbf :=_d .AbsoluteFilename (_fecf ,_d .TableType ,_acfb +1);_ecd .MarshalXML (_ddgg ,_ffbf ,_bfbd );
};for _dbea ,_dbd :=range _fbgd ._fcadf {_ccfed :=_d .AbsoluteFilename (_fecf ,_d .DrawingType ,_dbea +1);_ecd .MarshalXML (_ddgg ,_ccfed ,_dbd );if !_fbgd ._egbg [_dbea ].IsEmpty (){_ecd .MarshalXML (_ddgg ,_ecd .RelationsPathFor (_ccfed ),_fbgd ._egbg [_dbea ].X ());
};};for _gfbge ,_afba :=range _fbgd ._ddae {_ecd .MarshalXML (_ddgg ,_d .AbsoluteFilename (_fecf ,_d .VMLDrawingType ,_gfbge +1),_afba );};for _cefcg ,_ecbag :=range _fbgd .Images {if _dgba :=_aga .AddImageToZip (_ddgg ,_ecbag ,_cefcg +1,_d .DocTypeSpreadsheet );
_dgba !=nil {return _dgba ;};};if _gddfd :=_ecd .MarshalXML (_ddgg ,_d .ContentTypesFilename ,_fbgd .ContentTypes .X ());_gddfd !=nil {return _gddfd ;};for _cdfb ,_acce :=range _fbgd ._gdeg {if _acce ==nil {continue ;};_ecd .MarshalXML (_ddgg ,_d .AbsoluteFilename (_fecf ,_d .CommentsType ,_cdfb +1),_acce );
};if _aeeb :=_fbgd .WriteExtraFiles (_ddgg );_aeeb !=nil {return _aeeb ;};return _ddgg .Close ();};func (_aaa DataValidation )clear (){_aaa ._daca .Formula1 =_d .String ("\u0030");_aaa ._daca .Formula2 =_d .String ("\u0030");};

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_ageb SheetView )SetZoom (pct uint32 ){_ageb ._gcad .ZoomScaleAttr =&pct };

// AddMergedCells merges cells within a sheet.
func (_adge *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _adge ._ecbe .MergeCells ==nil {_adge ._ecbe .MergeCells =_gb .NewCT_MergeCells ();};_gcfb :=_gb .NewCT_MergeCell ();_gcfb .RefAttr =_ddg .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );
_adge ._ecbe .MergeCells .MergeCell =append (_adge ._ecbe .MergeCells .MergeCell ,_gcfb );_adge ._ecbe .MergeCells .CountAttr =_d .Uint32 (uint32 (len (_adge ._ecbe .MergeCells .MergeCell )));return MergedCell {_adge ._gaca ,_adge ,_gcfb };};

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_abaf Cell )SetFormulaRaw (s string ){_cdc :=_ce .ParseString (s );if _cdc ==nil {return ;};_abaf .clearValue ();_abaf ._aba .TAttr =_gb .ST_CellTypeStr ;_abaf ._aba .F =_gb .NewCT_CellFormula ();_abaf ._aba .F .Content =s ;};

// AddFill creates a new empty Fill style.
func (_acea Fills )AddFill ()Fill {_eggg :=_gb .NewCT_Fill ();return Fill {_eggg ,_acea ._cdfg }};

// Clear clears the cell's value and type.
func (_df Cell )Clear (){_df .clearValue ();_df ._aba .TAttr =_gb .ST_CellTypeUnset };

// X returns the inner wrapped XML type.
func (_cdcd RichTextRun )X ()*_gb .CT_RElt {return _cdcd ._bffe };const (DVCompareTypeWholeNumber =DVCompareType (_gb .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_gb .ST_DataValidationTypeDecimal );DVCompareTypeDate =DVCompareType (_gb .ST_DataValidationTypeDate );
DVCompareTypeTime =DVCompareType (_gb .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_gb .ST_DataValidationTypeTextLength ););

// AddCell adds a cell to a spreadsheet.
func (_dgf Row )AddCell ()Cell {_edaa :=uint32 (len (_dgf ._fagb .C ));var _eacd *string ;if _edaa > 0{_fbcb :=_d .Stringf ("\u0025\u0073\u0025\u0064",_ag .IndexToColumn (_edaa -1),_dgf .RowNumber ());if _dgf ._fagb .C [_edaa -1].RAttr !=nil &&*_dgf ._fagb .C [_edaa -1].RAttr ==*_fbcb {_eacd =_d .Stringf ("\u0025\u0073\u0025\u0064",_ag .IndexToColumn (_edaa ),_dgf .RowNumber ());
};};_cede :=_gb .NewCT_Cell ();_dgf ._fagb .C =append (_dgf ._fagb .C ,_cede );if _eacd ==nil {_begbc :=uint32 (0);for _ ,_abba :=range _dgf ._fagb .C {if _abba .RAttr !=nil {_gdacf ,_ :=_ag .ParseCellReference (*_abba .RAttr );if _gdacf .ColumnIdx >=_begbc {_begbc =_gdacf .ColumnIdx +1;
};};};_eacd =_d .Stringf ("\u0025\u0073\u0025\u0064",_ag .IndexToColumn (_begbc ),_dgf .RowNumber ());};_cede .RAttr =_eacd ;return Cell {_dgf ._fabg ,_dgf ._cabb ,_dgf ._fagb ,_cede };};

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_accbb *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _accbb .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _aaec _aga .Relationship ;for _ ,_cdfga :=range _accbb ._bcca .Relationships (){if _cdfga .ID ()==_accbb ._fdea .Sheets .Sheet [ind ].IdAttr {var _bfad bool ;
if _aaec ,_bfad =_accbb ._bcca .CopyRelationship (_cdfga .ID ());!_bfad {return Sheet {},ErrorNotFound ;};break ;};};_accbb .ContentTypes .CopyOverride (_d .AbsoluteFilename (_d .DocTypeSpreadsheet ,_d .WorksheetContentType ,ind +1),_d .AbsoluteFilename (_d .DocTypeSpreadsheet ,_d .WorksheetContentType ,len (_accbb .ContentTypes .X ().Override )));
_bbbf :=*_accbb ._cgcb [ind ];_accbb ._cgcb =append (_accbb ._cgcb ,&_bbbf );var _bbbd uint32 =0;for _ ,_dffd :=range _accbb ._fdea .Sheets .Sheet {if _dffd .SheetIdAttr > _bbbd {_bbbd =_dffd .SheetIdAttr ;};};_bbbd ++;_beacf :=*_accbb ._fdea .Sheets .Sheet [ind ];
_beacf .IdAttr =_aaec .ID ();_beacf .NameAttr =copiedSheetName ;_beacf .SheetIdAttr =_bbbd ;_accbb ._fdea .Sheets .Sheet =append (_accbb ._fdea .Sheets .Sheet ,&_beacf );_dagb :=_aga .NewRelationshipsCopy (_accbb ._bgff [ind ]);_accbb ._bgff =append (_accbb ._bgff ,_dagb );
_dcfb :=_accbb ._gdeg [ind ];if _dcfb ==nil {_accbb ._gdeg =append (_accbb ._gdeg ,nil );}else {_cgga :=*_dcfb ;_accbb ._gdeg =append (_accbb ._gdeg ,&_cgga );};_gfcb :=Sheet {_accbb ,&_beacf ,&_bbbf };return _gfcb ,nil ;};

// SetColor sets the text color.
func (_dccf RichTextRun )SetColor (c _fa .Color ){_dccf .ensureRpr ();_dccf ._bffe .RPr .Color =_gb .NewCT_Color ();_fgeda :="\u0066\u0066"+*c .AsRGBString ();_dccf ._bffe .RPr .Color .RgbAttr =&_fgeda ;};

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_fgbd Comment )SetAuthor (author string ){_fgbd ._geg .AuthorIdAttr =Comments {_fgbd ._aggf ,_fgbd ._dadd }.getOrCreateAuthor (author );};

// SetHeight sets the row height in points.
func (_bcgc Row )SetHeight (d _dg .Distance ){_bcgc ._fagb .HtAttr =_d .Float64 (float64 (d ));_bcgc ._fagb .CustomHeightAttr =_d .Bool (true );};

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_edd *Workbook ;_agda *_be .WsDr ;};

// SetCol set the column of the cell marker.
func (_cae CellMarker )SetCol (col int32 ){_cae ._gbef .Col =col };

// SetName sets the sheet name.
func (_ccfb *Sheet )SetName (name string ){_ccfb ._bfaa .NameAttr =name };

// InitializeDefaults initializes a border to its defaulte empty values.
func (_cgag Border )InitializeDefaults (){_cgag ._eb .Left =_gb .NewCT_BorderPr ();_cgag ._eb .Bottom =_gb .NewCT_BorderPr ();_cgag ._eb .Right =_gb .NewCT_BorderPr ();_cgag ._eb .Top =_gb .NewCT_BorderPr ();_cgag ._eb .Diagonal =_gb .NewCT_BorderPr ();
};

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_bfgbg *Workbook )Epoch ()_af .Time {if _bfgbg .Uses1904Dates (){_af .Date (1904,1,1,0,0,0,0,_af .UTC );};return _af .Date (1899,12,30,0,0,0,0,_af .UTC );};var ErrorNotFound =_fg .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_gbf AbsoluteAnchor )SetRowOffset (m _dg .Distance ){_gbf ._abf .Pos .YAttr .ST_CoordinateUnqualified =_d .Int64 (int64 (m /_dg .EMU ));};

// SetFont sets the font name for a rich text run.
func (_gcd RichTextRun )SetFont (s string ){_gcd .ensureRpr ();_gcd ._bffe .RPr .RFont =_gb .NewCT_FontName ();_gcd ._bffe .RPr .RFont .ValAttr =s ;};type WorkbookProtection struct{_dfbd *_gb .CT_WorkbookProtection };func _ccgb (_acg _af .Time )_af .Time {_acg =_acg .UTC ();
return _af .Date (_acg .Year (),_acg .Month (),_acg .Day (),_acg .Hour (),_acg .Minute (),_acg .Second (),_acg .Nanosecond (),_af .Local );};

// SetBold causes the text to be displayed in bold.
func (_aefc RichTextRun )SetBold (b bool ){_aefc .ensureRpr ();_aefc ._bffe .RPr .B =_gb .NewCT_BooleanProperty ();_aefc ._bffe .RPr .B .ValAttr =_d .Bool (b );};

// GetBorder gets a Border from a cell style.
func (_gcfg CellStyle )GetBorder ()*_gb .CT_Border {if _dgcb :=_gcfg ._gag .BorderIdAttr ;_dgcb !=nil {_ged :=_gcfg ._bae .StyleSheet .Borders ();if int (*_dgcb )< len (_ged ){return _ged [int (*_dgcb )].X ();};};return nil ;};

// SetIcons sets the icon set to use for display.
func (_cdbg IconScale )SetIcons (t _gb .ST_IconSetType ){_cdbg ._bdbb .IconSetAttr =t };

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_fbec *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_gbeg :=_fbec ._ecbe .SheetData .Row ;_fae :=_fbec .Rows ();for _fgaag ,_daaae :=range _fae {if _daaae .RowNumber ()==firstRow {_gbeg =_fbec ._ecbe .SheetData .Row [_fgaag :];break ;
};};_cbefa :=Comparer {Order :order };_a .Slice (_gbeg ,func (_aed ,_bgefd int )bool {return _cbefa .LessRows (column ,Row {_fbec ._gaca ,_fbec ,_gbeg [_aed ]},Row {_fbec ._gaca ,_fbec ,_gbeg [_bgefd ]});});for _ccecb ,_bedgd :=range _fbec .Rows (){_affdf :=uint32 (_ccecb +1);
if _bedgd .RowNumber ()!=_affdf {_bedgd .renumberAs (_affdf );};};};func (_fff ConditionalFormattingRule )clear (){_fff ._cbf .OperatorAttr =_gb .ST_ConditionalFormattingOperatorUnset ;_fff ._cbf .ColorScale =nil ;_fff ._cbf .IconSet =nil ;_fff ._cbf .Formula =nil ;
};

// AddBorder creates a new empty Border style.
func (_gcac StyleSheet )AddBorder ()Border {_fcf :=_gb .NewCT_Border ();return Border {_fcf ,_gcac ._geeec .Borders };};

// SetShowValue controls if the cell value is displayed.
func (_gdfe DataBarScale )SetShowValue (b bool ){_gdfe ._gbg .ShowValueAttr =_d .Bool (b )};