//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_ad "archive/zip";_c "bytes";_da "errors";_ae "fmt";_b "github.com/unidoc/unioffice";_gg "github.com/unidoc/unioffice/chart";_gd "github.com/unidoc/unioffice/color";_becg "github.com/unidoc/unioffice/common";_de "github.com/unidoc/unioffice/common/logger";
_ga "github.com/unidoc/unioffice/common/tempstorage";_dfgg "github.com/unidoc/unioffice/internal/formatutils";_be "github.com/unidoc/unioffice/internal/license";_bd "github.com/unidoc/unioffice/measurement";_ed "github.com/unidoc/unioffice/schema/soo/dml";
_ff "github.com/unidoc/unioffice/schema/soo/dml/chart";_eeg "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing";_dfb "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_ec "github.com/unidoc/unioffice/schema/soo/sml";_db "github.com/unidoc/unioffice/spreadsheet/format";
_bec "github.com/unidoc/unioffice/spreadsheet/formula";_ggg "github.com/unidoc/unioffice/spreadsheet/reference";_dae "github.com/unidoc/unioffice/spreadsheet/update";_bc "github.com/unidoc/unioffice/vmldrawing";_ce "github.com/unidoc/unioffice/zippkg";
_d "image";_a "image/jpeg";_eb "io";_cf "math";_dfd "math/big";_df "os";_f "path";_ac "path/filepath";_dfg "reflect";_af "regexp";_g "sort";_ee "strconv";_bg "strings";_fd "time";);

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_acf Cell )SetRichTextString ()RichText {_acf .clearValue ();_acf ._cgd .Is =_ec .NewCT_Rst ();_acf ._cgd .TAttr =_ec .ST_CellTypeInlineStr ;return RichText {_acf ._cgd .Is };};func (_ecfa Cell )GetRawValue ()(string ,error ){switch _ecfa ._cgd .TAttr {case _ec .ST_CellTypeInlineStr :if _ecfa ._cgd .Is ==nil ||_ecfa ._cgd .Is .T ==nil {return "",nil ;
};return *_ecfa ._cgd .Is .T ,nil ;case _ec .ST_CellTypeS :if _ecfa ._cgd .V ==nil {return "",nil ;};_aec ,_cgb :=_ee .Atoi (*_ecfa ._cgd .V );if _cgb !=nil {return "",_cgb ;};return _ecfa ._ggb .SharedStrings .GetString (_aec );case _ec .ST_CellTypeStr :if _ecfa ._cgd .F !=nil {return _ecfa ._cgd .F .Content ,nil ;
};};if _ecfa ._cgd .V ==nil {return "",nil ;};return *_ecfa ._cgd .V ,nil ;};

// X returns the inner wrapped XML type.
func (_bafd Font )X ()*_ec .CT_Font {return _bafd ._aagc };

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_bceb *Sheet )FormulaContext ()_bec .Context {return _egda (_bceb )};

// Name returns the name of the defined name.
func (_afg DefinedName )Name ()string {return _afg ._efeb .NameAttr };

// Fonts returns the list of fonts defined in the stylesheet.
func (_fcee StyleSheet )Fonts ()[]Font {_aabc :=[]Font {};for _ ,_cgbf :=range _fcee ._bdbbe .Fonts .Font {_aabc =append (_aabc ,Font {_cgbf ,_fcee ._bdbbe });};return _aabc ;};

// SetPassword sets the password hash to a hash of the input password.
func (_dddff WorkbookProtection )SetPassword (pw string ){_dddff .SetPasswordHash (PasswordHash (pw ))};

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_becb Sheet )Extents ()string {_cebee ,_cbcg ,_deca ,_ggfc :=_becb .ExtentsIndex ();return _ae .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_cebee ,_cbcg ,_deca ,_ggfc );};

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_afef *_ec .CT_Rst };

// SetBorder applies a border to a cell style avoiding redundancy. The function checks if the given border
// already exists in the saved borders. If found, the existing border is reused; otherwise,
// the new border is added to the saved borders collection. The border is then applied to the cell style,
// affecting all styles that reference it by index.
func (_bcg CellStyle )SetBorder (b Border ){_ded :=b ._caf .Border ;for _ ,_aad :=range _ded {if _dfg .DeepEqual (_aad ,b ._cd ){b ._cd =_aad ;_bcg ._gdcd .BorderIdAttr =_b .Uint32 (b .Index ());_bcg ._gdcd .ApplyBorderAttr =_b .Bool (true );return ;};
};b ._caf .Border =append (b ._caf .Border ,b ._cd );b ._caf .CountAttr =_b .Uint32 (uint32 (len (b ._caf .Border )));_bcg ._gdcd .BorderIdAttr =_b .Uint32 (b .Index ());_bcg ._gdcd .ApplyBorderAttr =_b .Bool (true );};

// SetMinLength sets the minimum bar length in percent.
func (_afd DataBarScale )SetMinLength (l uint32 ){_afd ._begc .MinLengthAttr =_b .Uint32 (l )};func (_cbcad *Sheet )getAllCellsInFormulaArrays (_gddg bool )(map[string ]bool ,error ){_fbbe :=_bec .NewEvaluator ();_bbca :=_cbcad .FormulaContext ();_bbaf :=map[string ]bool {};
for _ ,_ddag :=range _cbcad .Rows (){for _ ,_bbbb :=range _ddag .Cells (){if _bbbb .X ().F !=nil {_dcb :=_bbbb .X ().F .Content ;if _bbbb .X ().F .TAttr ==_ec .ST_CellFormulaTypeArray {_adbf :=_fbbe .Eval (_bbca ,_dcb ).AsString ();if _adbf .Type ==_bec .ResultTypeError {_de .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_dcb ,_adbf .ErrorMessage );
_bbbb .X ().V =nil ;};if _adbf .Type ==_bec .ResultTypeArray {_bfae ,_addbc :=_ggg .ParseCellReference (_bbbb .Reference ());if _addbc !=nil {return map[string ]bool {},_addbc ;};if (_gddg &&len (_adbf .ValueArray )==1)||(!_gddg &&len (_adbf .ValueArray [0])==1){continue ;
};for _abba ,_gbfd :=range _adbf .ValueArray {_acec :=_bfae .RowIdx +uint32 (_abba );for _fbea :=range _gbfd {_adfg :=_ggg .IndexToColumn (_bfae .ColumnIdx +uint32 (_fbea ));_bbaf [_ae .Sprintf ("\u0025\u0073\u0025\u0064",_adfg ,_acec )]=true ;};};}else if _adbf .Type ==_bec .ResultTypeList {_edec ,_bbeg :=_ggg .ParseCellReference (_bbbb .Reference ());
if _bbeg !=nil {return map[string ]bool {},_bbeg ;};if _gddg ||len (_adbf .ValueList )==1{continue ;};_bfcgd :=_edec .RowIdx ;for _ceca :=range _adbf .ValueList {_bgfec :=_ggg .IndexToColumn (_edec .ColumnIdx +uint32 (_ceca ));_bbaf [_ae .Sprintf ("\u0025\u0073\u0025\u0064",_bgfec ,_bfcgd )]=true ;
};};};};};};return _bbaf ,nil ;};

// Row returns the row of the cell marker.
func (_cfg CellMarker )Row ()int32 {return _cfg ._efca .Row };

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_fage Cell )GetCachedFormulaResult ()string {if _fage ._cgd .V !=nil {return *_fage ._cgd .V ;};return "";};

// X returns the inner wrapped XML type.
func (_afe Column )X ()*_ec .CT_Col {return _afe ._dbef };

// RowOffset returns the offset from the row cell.
func (_cbc CellMarker )RowOffset ()_bd .Distance {if _cbc ._efca .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _bd .Distance (float64 (*_cbc ._efca .RowOff .ST_CoordinateUnqualified )*_bd .EMU );};

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_eegaa ConditionalFormattingRule )SetColorScale ()ColorScale {_eegaa .clear ();_eegaa .SetType (_ec .ST_CfTypeColorScale );_eegaa ._gge .ColorScale =_ec .NewCT_ColorScale ();return ColorScale {_eegaa ._gge .ColorScale };};

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_caac DataValidationCompare )SetValue (v string ){_caac ._ccebd .Formula1 =&v };var (_gfee =[...]uint8 {0,21,46,61,76,91};_agfd =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_dcedd =[...]uint8 {0,16,32,48,64};_beda =[...]uint8 {0,16,32,48,64,80};
);

// ExtractText returns text from the sheet as a SheetText object.
func (_dfdf *Sheet )ExtractText ()*SheetText {_feb :=[]CellText {};for _ ,_bdf :=range _dfdf .Rows (){for _ ,_cbfe :=range _bdf .Cells (){if !_cbfe .IsEmpty (){if _ecge :=_cbfe .GetFormattedValue ();_ecge !=""{_feb =append (_feb ,CellText {Text :_ecge ,Cell :_cbfe });
};};};};return &SheetText {Cells :_feb };};

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_fef Row )Cells ()[]Cell {_dfag :=[]Cell {};_dabb :=-1;_gcag :=append ([]*_ec .CT_Cell {},_fef ._ccaa .C ...);for _ ,_dgcc :=range _gcag {if _dgcc .RAttr ==nil {_de .Log .Debug ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
continue ;};_gggf ,_ebce :=_ggg .ParseCellReference (*_dgcc .RAttr );if _ebce !=nil {_de .Log .Debug ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_dgcc .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
continue ;};_ece :=int (_gggf .ColumnIdx );if _ece -_dabb > 1{for _adda :=_dabb +1;_adda < _ece ;_adda ++{_dfag =append (_dfag ,_fef .Cell (_ggg .IndexToColumn (uint32 (_adda ))));};};_dabb =_ece ;_dfag =append (_dfag ,Cell {_fef ._cfddf ,_fef ._aaca ,_fef ._ccaa ,_dgcc });
};return _dfag ;};

// Wrapped returns true if the cell will wrap text.
func (_dfc CellStyle )Wrapped ()bool {if _dfc ._gdcd .Alignment ==nil {return false ;};if _dfc ._gdcd .Alignment .WrapTextAttr ==nil {return false ;};return *_dfc ._gdcd .Alignment .WrapTextAttr ;};

// GetChartByTargetId returns the array of workbook crt.ChartSpace.
func (_bada *Workbook )GetChartByTargetId (targetAttr string )*_ff .ChartSpace {return _bada ._bbdd [targetAttr ];};

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_ceag Drawing )AddChart (at AnchorType )(_gg .Chart ,Anchor ){_efgd :=_ff .NewChartSpace ();_ceag ._ddcd ._gggb =append (_ceag ._ddcd ._gggb ,_efgd );_gfd :=_b .AbsoluteFilename (_b .DocTypeSpreadsheet ,_b .ChartContentType ,len (_ceag ._ddcd ._gggb ));
_ceag ._ddcd .ContentTypes .AddOverride (_gfd ,_b .ChartContentType );var _dgfc string ;for _baf ,_fcf :=range _ceag ._ddcd ._ggfge {if _fcf ==_ceag ._ced {_fdab :=_b .RelativeFilename (_b .DocTypeSpreadsheet ,_b .DrawingType ,_b .ChartType ,len (_ceag ._ddcd ._gggb ));
_bddf :=_ceag ._ddcd ._aaae [_baf ].AddRelationship (_fdab ,_b .ChartType );_dgfc =_bddf .ID ();break ;};};var _deaa Anchor ;var _bbcd *_eeg .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_aace :=_gafbb ();_ceag ._ced .EG_Anchor =append (_ceag ._ced .EG_Anchor ,&_eeg .EG_Anchor {AbsoluteAnchor :_aace });
_aace .Choice =&_eeg .EG_ObjectChoicesChoice {};_aace .Choice .GraphicFrame =_eeg .NewCT_GraphicalObjectFrame ();_bbcd =_aace .Choice .GraphicFrame ;_deaa =AbsoluteAnchor {_aace };case AnchorTypeOneCell :_cgea :=_bcfa ();_ceag ._ced .EG_Anchor =append (_ceag ._ced .EG_Anchor ,&_eeg .EG_Anchor {OneCellAnchor :_cgea });
_cgea .Choice =&_eeg .EG_ObjectChoicesChoice {};_cgea .Choice .GraphicFrame =_eeg .NewCT_GraphicalObjectFrame ();_bbcd =_cgea .Choice .GraphicFrame ;_deaa =OneCellAnchor {_cgea };case AnchorTypeTwoCell :_acg :=_faa ();_ceag ._ced .EG_Anchor =append (_ceag ._ced .EG_Anchor ,&_eeg .EG_Anchor {TwoCellAnchor :_acg });
_acg .Choice =&_eeg .EG_ObjectChoicesChoice {};_acg .Choice .GraphicFrame =_eeg .NewCT_GraphicalObjectFrame ();_bbcd =_acg .Choice .GraphicFrame ;_deaa =TwoCellAnchor {_acg };};_bbcd .NvGraphicFramePr =_eeg .NewCT_GraphicalObjectFrameNonVisual ();_bbcd .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_ceag ._ced .EG_Anchor ));
_bbcd .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_bbcd .Graphic =_ed .NewGraphic ();_bbcd .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";
_bcga :=_ff .NewChart ();_bcga .IdAttr =_dgfc ;_bbcd .Graphic .GraphicData .Any =[]_b .Any {_bcga };_aabb :=_gg .MakeChart (_efgd );_aabb .Properties ().SetSolidFill (_gd .White );_aabb .SetDisplayBlanksAs (_ff .ST_DispBlanksAsGap );return _aabb ,_deaa ;
};

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_bbgf StyleSheet )AddNumberFormat ()NumberFormat {if _bbgf ._bdbbe .NumFmts ==nil {_bbgf ._bdbbe .NumFmts =_ec .NewCT_NumFmts ();};_dgbf :=_ec .NewCT_NumFmt ();_dgbf .NumFmtIdAttr =uint32 (200+len (_bbgf ._bdbbe .NumFmts .NumFmt ));_bbgf ._bdbbe .NumFmts .NumFmt =append (_bbgf ._bdbbe .NumFmts .NumFmt ,_dgbf );
_bbgf ._bdbbe .NumFmts .CountAttr =_b .Uint32 (uint32 (len (_bbgf ._bdbbe .NumFmts .NumFmt )));return NumberFormat {_bbgf ._eecc ,_dgbf };};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_ecgaf *Sheet )ClearCachedFormulaResults (){for _ ,_dbbc :=range _ecgaf .Rows (){for _ ,_dafd :=range _dbbc .Cells (){if _dafd .X ().F !=nil {_dafd .X ().V =nil ;};};};};

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_dccb *Sheet )SetBorder (cellRange string ,border Border )error {_dabeg ,_ffgg ,_becf :=_ggg .ParseRangeReference (cellRange );if _becf !=nil {return _becf ;};_dcff :=_dccb ._dfgf .StyleSheet .AddCellStyle ();_bfda :=_dccb ._dfgf .StyleSheet .AddBorder ();
_dcff .SetBorder (_bfda );_bfda ._cd .Top =border ._cd .Top ;_bfda ._cd .Left =border ._cd .Left ;_ccbdd :=_dccb ._dfgf .StyleSheet .AddCellStyle ();_gdba :=_dccb ._dfgf .StyleSheet .AddBorder ();_ccbdd .SetBorder (_gdba );_gdba ._cd .Top =border ._cd .Top ;
_gdba ._cd .Right =border ._cd .Right ;_gdbc :=_dccb ._dfgf .StyleSheet .AddCellStyle ();_edgb :=_dccb ._dfgf .StyleSheet .AddBorder ();_gdbc .SetBorder (_edgb );_edgb ._cd .Top =border ._cd .Top ;_gafd :=_dccb ._dfgf .StyleSheet .AddCellStyle ();_dfdd :=_dccb ._dfgf .StyleSheet .AddBorder ();
_gafd .SetBorder (_dfdd );_dfdd ._cd .Left =border ._cd .Left ;_dbce :=_dccb ._dfgf .StyleSheet .AddCellStyle ();_acfga :=_dccb ._dfgf .StyleSheet .AddBorder ();_dbce .SetBorder (_acfga );_acfga ._cd .Right =border ._cd .Right ;_aggd :=_dccb ._dfgf .StyleSheet .AddCellStyle ();
_bcge :=_dccb ._dfgf .StyleSheet .AddBorder ();_aggd .SetBorder (_bcge );_bcge ._cd .Bottom =border ._cd .Bottom ;_cee :=_dccb ._dfgf .StyleSheet .AddCellStyle ();_cdbdf :=_dccb ._dfgf .StyleSheet .AddBorder ();_cee .SetBorder (_cdbdf );_cdbdf ._cd .Bottom =border ._cd .Bottom ;
_cdbdf ._cd .Left =border ._cd .Left ;_ggge :=_dccb ._dfgf .StyleSheet .AddCellStyle ();_dgdbe :=_dccb ._dfgf .StyleSheet .AddBorder ();_ggge .SetBorder (_dgdbe );_dgdbe ._cd .Bottom =border ._cd .Bottom ;_dgdbe ._cd .Right =border ._cd .Right ;_cebef :=_dabeg .RowIdx ;
_bfgd :=_dabeg .ColumnIdx ;_aggb :=_ffgg .RowIdx ;_cae :=_ffgg .ColumnIdx ;for _affc :=_cebef ;_affc <=_aggb ;_affc ++{for _adff :=_bfgd ;_adff <=_cae ;_adff ++{_ccd :=_ae .Sprintf ("\u0025\u0073\u0025\u0064",_ggg .IndexToColumn (_adff ),_affc );switch {case _affc ==_cebef &&_adff ==_bfgd :_dccb .Cell (_ccd ).SetStyle (_dcff );
case _affc ==_cebef &&_adff ==_cae :_dccb .Cell (_ccd ).SetStyle (_ccbdd );case _affc ==_aggb &&_adff ==_bfgd :_dccb .Cell (_ccd ).SetStyle (_cee );case _affc ==_aggb &&_adff ==_cae :_dccb .Cell (_ccd ).SetStyle (_ggge );case _affc ==_cebef :_dccb .Cell (_ccd ).SetStyle (_gdbc );
case _affc ==_aggb :_dccb .Cell (_ccd ).SetStyle (_aggd );case _adff ==_bfgd :_dccb .Cell (_ccd ).SetStyle (_gafd );case _adff ==_cae :_dccb .Cell (_ccd ).SetStyle (_dbce );};};};return nil ;};

// SetWidth controls the width of a column.
func (_cffa Column )SetWidth (w _bd .Distance ){_cffa ._dbef .WidthAttr =_b .Float64 (float64 (w /_bd .Character ));};const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);

// IsStructureLocked returns whether the workbook structure is locked.
func (_bfab WorkbookProtection )IsStructureLocked ()bool {return _bfab ._bdbc .LockStructureAttr !=nil &&*_bfab ._bdbc .LockStructureAttr ;};

// BottomRight is a no-op.
func (_ea AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};

// Sheet is a single sheet within a workbook.
type Sheet struct{_dfgf *Workbook ;_ade *_ec .CT_Sheet ;_gfba *_ec .Worksheet ;};

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_fce CellStyle )SetHorizontalAlignment (a _ec .ST_HorizontalAlignment ){if _fce ._gdcd .Alignment ==nil {_fce ._gdcd .Alignment =_ec .NewCT_CellAlignment ();};_fce ._gdcd .Alignment .HorizontalAttr =a ;_fce ._gdcd .ApplyAlignmentAttr =_b .Bool (true );
};

// SetFont applies a font to a cell style avoiding redundancy. The function checks if the given font
// already exists in the saved fonts. If found, the existing font is reused; otherwise,
// the new font is added to the saved fonts collection. The font is then applied to the cell style,
// affecting all styles that reference it by index.
func (_gfc CellStyle )SetFont (f Font ){_aff :=f ._fbbf .Fonts .Font ;for _ ,_eecg :=range _aff {if _dfg .DeepEqual (_eecg ,f ._aagc ){f ._aagc =_eecg ;_gfc ._gdcd .FontIdAttr =_b .Uint32 (f .Index ());_gfc ._gdcd .ApplyFontAttr =_b .Bool (true );return ;
};};f ._fbbf .Fonts .Font =append (f ._fbbf .Fonts .Font ,f ._aagc );f ._fbbf .Fonts .CountAttr =_b .Uint32 (uint32 (len (f ._fbbf .Fonts .Font )));_gfc ._gdcd .FontIdAttr =_b .Uint32 (f .Index ());_gfc ._gdcd .ApplyFontAttr =_b .Bool (true );};

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_ffe AbsoluteAnchor )SetColOffset (m _bd .Distance ){_ffe ._cg .Pos .XAttr .ST_CoordinateUnqualified =_b .Int64 (int64 (m /_bd .EMU ));};

// SetPattern sets the pattern of the fill.
func (_gbdf PatternFill )SetPattern (p _ec .ST_PatternType ){_gbdf ._febg .PatternTypeAttr =p };

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_ffee TwoCellAnchor )SetWidthCells (w int32 ){_ceae :=_ffee .TopLeft ();_gdfad :=_ffee .BottomRight ();_gdfad .SetCol (_ceae .Col ()+w );};

// Comments returns the list of comments for this sheet
func (_eab Comments )Comments ()[]Comment {_daea :=[]Comment {};for _ ,_eaee :=range _eab ._bfe .CommentList .Comment {_daea =append (_daea ,Comment {_eab ._edf ,_eaee ,_eab ._bfe });};return _daea ;};

// AddDataValidation adds a data validation rule to a sheet.
func (_dced *Sheet )AddDataValidation ()DataValidation {if _dced ._gfba .DataValidations ==nil {_dced ._gfba .DataValidations =_ec .NewCT_DataValidations ();};_bbdg :=_ec .NewCT_DataValidation ();_bbdg .ShowErrorMessageAttr =_b .Bool (true );_dced ._gfba .DataValidations .DataValidation =append (_dced ._gfba .DataValidations .DataValidation ,_bbdg );
_dced ._gfba .DataValidations .CountAttr =_b .Uint32 (uint32 (len (_dced ._gfba .DataValidations .DataValidation )));return DataValidation {_bbdg };};

// SheetCount returns the number of sheets in the workbook.
func (_bbafg Workbook )SheetCount ()int {return len (_bbafg ._fggfc )};

// IsBool returns true if the cell boolean value.
func (_fecd *evalContext )IsBool (cellRef string )bool {return _fecd ._ddd .Cell (cellRef ).IsBool ()};func (_gegf StyleSheet )appendFont ()Font {_cfbe :=_ec .NewCT_Font ();_gegf ._bdbbe .Fonts .Font =append (_gegf ._bdbbe .Fonts .Font ,_cfbe );_gegf ._bdbbe .Fonts .CountAttr =_b .Uint32 (uint32 (len (_gegf ._bdbbe .Fonts .Font )));
return Font {_cfbe ,_gegf ._bdbbe };};

// AddCommentWithStyle adds a new comment styled in a default way
func (_cea Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_agfa :=_cea .AddComment (cellRef ,author );_def :=_agfa .AddRun ();_def .SetBold (true );_def .SetSize (10);_def .SetColor (_gd .Black );_def .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");
_def .SetText (author +"\u003a");_def =_agfa .AddRun ();_def .SetSize (10);_def .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_def .SetColor (_gd .Black );_def .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_aeac ,_faec :=_ggg .ParseCellReference (cellRef );
if _faec !=nil {return _faec ;};_cea ._edf ._cedfa [0].Shape =append (_cea ._edf ._cedfa [0].Shape ,_bc .NewCommentShape (int64 (_aeac .ColumnIdx ),int64 (_aeac .RowIdx -1)));return nil ;};

// AddGradientStop adds a color gradient stop.
func (_cffb ColorScale )AddGradientStop (color _gd .Color ){_feg :=_ec .NewCT_Color ();_feg .RgbAttr =color .AsRGBAString ();_cffb ._bbb .Color =append (_cffb ._bbb .Color ,_feg );};

// LockWindow controls the locking of the workbook windows.
func (_dfgb WorkbookProtection )LockWindow (b bool ){if !b {_dfgb ._bdbc .LockWindowsAttr =nil ;}else {_dfgb ._bdbc .LockWindowsAttr =_b .Bool (true );};};

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_ecce *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _ecce .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _bcdf _becg .Relationship ;for _ ,_acfee :=range _ecce ._ggda .Relationships (){if _acfee .ID ()==_ecce ._fffe .Sheets .Sheet [ind ].IdAttr {var _abfg bool ;
if _bcdf ,_abfg =_ecce ._ggda .CopyRelationship (_acfee .ID ());!_abfg {return Sheet {},ErrorNotFound ;};break ;};};_ecce .ContentTypes .CopyOverride (_b .AbsoluteFilename (_b .DocTypeSpreadsheet ,_b .WorksheetContentType ,ind +1),_b .AbsoluteFilename (_b .DocTypeSpreadsheet ,_b .WorksheetContentType ,len (_ecce .ContentTypes .X ().Override )));
_dbabc :=*_ecce ._fggfc [ind ];_ecce ._fggfc =append (_ecce ._fggfc ,&_dbabc );var _bbef uint32 =0;for _ ,_agced :=range _ecce ._fffe .Sheets .Sheet {if _agced .SheetIdAttr > _bbef {_bbef =_agced .SheetIdAttr ;};};_bbef ++;_cgdgg :=*_ecce ._fffe .Sheets .Sheet [ind ];
_cgdgg .IdAttr =_bcdf .ID ();_cgdgg .NameAttr =copiedSheetName ;_cgdgg .SheetIdAttr =_bbef ;_ecce ._fffe .Sheets .Sheet =append (_ecce ._fffe .Sheets .Sheet ,&_cgdgg );_caaae :=_becg .NewRelationshipsCopy (_ecce ._ffdfe [ind ]);_ecce ._ffdfe =append (_ecce ._ffdfe ,_caaae );
_adea :=_ecce ._eebg [ind ];if _adea ==nil {_ecce ._eebg =append (_ecce ._eebg ,nil );}else {_eagaf :=*_adea ;_ecce ._eebg =append (_ecce ._eebg ,&_eagaf );};_cfff :=Sheet {_ecce ,&_cgdgg ,&_dbabc };return _cfff ,nil ;};

// SetStyle sets the cell style for an entire column.
func (_gfa Column )SetStyle (cs CellStyle ){_gfa ._dbef .StyleAttr =_b .Uint32 (cs .Index ())};func (_bbgd *evalContext )NamedRange (ref string )_bec .Reference {for _ ,_dgdd :=range _bbgd ._ddd ._dfgf .DefinedNames (){if _dgdd .Name ()==ref {return _bec .MakeRangeReference (_dgdd .Content ());
};};for _ ,_gbdb :=range _bbgd ._ddd ._dfgf .Tables (){if _gbdb .Name ()==ref {return _bec .MakeRangeReference (_ae .Sprintf ("\u0025\u0073\u0021%\u0073",_bbgd ._ddd .Name (),_gbdb .Reference ()));};};return _bec .ReferenceInvalid ;};func _bcfa ()*_eeg .CT_OneCellAnchor {_cgbe :=_eeg .NewCT_OneCellAnchor ();
return _cgbe };

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_cgeb ConditionalFormattingRule )SetDataBar ()DataBarScale {_cgeb .clear ();_cgeb .SetType (_ec .ST_CfTypeDataBar );_cgeb ._gge .DataBar =_ec .NewCT_DataBar ();_ebc :=DataBarScale {_cgeb ._gge .DataBar };_ebc .SetShowValue (true );_ebc .SetMinLength (10);
_ebc .SetMaxLength (90);return _ebc ;};

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_aecd DataValidation )SetRange (cellRange string ){_aecd ._cdg .SqrefAttr =_ec .ST_Sqref {cellRange };};

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_cbed *_ec .Sst ;_eabe map[string ]int ;};

// SetOperator sets the operator for the rule.
func (_dea ConditionalFormattingRule )SetOperator (t _ec .ST_ConditionalFormattingOperator ){_dea ._gge .OperatorAttr =t ;};

// X returns the inner wrapped XML type.
func (_cgf Border )X ()*_ec .CT_Border {return _cgf ._cd };func (_caab Fill )Index ()uint32 {if _caab ._fdfc ==nil {return 0;};for _aefe ,_bcc :=range _caab ._fdfc .Fill {if _caab ._fcc ==_bcc {return uint32 (_aefe );};};return 0;};

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_ccec *Sheet )AddNumberedRow (rowNum uint32 )Row {_efba :=_ec .NewCT_Row ();_efba .RAttr =_b .Uint32 (rowNum );_ccec ._gfba .SheetData .Row =append (_ccec ._gfba .SheetData .Row ,_efba );_g .Slice (_ccec ._gfba .SheetData .Row ,func (_ccbf ,_abd int )bool {_egff :=_ccec ._gfba .SheetData .Row [_ccbf ].RAttr ;
_cddc :=_ccec ._gfba .SheetData .Row [_abd ].RAttr ;if _egff ==nil {return true ;};if _cddc ==nil {return true ;};return *_egff < *_cddc ;});return Row {_ccec ._dfgf ,_ccec ,_efba };};

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_cdga :=_ec .NewStyleSheet ();_cdga .CellStyleXfs =_ec .NewCT_CellStyleXfs ();_cdga .CellXfs =_ec .NewCT_CellXfs ();_cdga .CellStyles =_ec .NewCT_CellStyles ();_fggc :=_ec .NewCT_CellStyle ();_fggc .NameAttr =_b .String ("\u004e\u006f\u0072\u006d\u0061\u006c");
_fggc .XfIdAttr =0;_fggc .BuiltinIdAttr =_b .Uint32 (0);_cdga .CellStyles .CellStyle =append (_cdga .CellStyles .CellStyle ,_fggc );_cdga .CellStyles .CountAttr =_b .Uint32 (uint32 (len (_cdga .CellStyles .CellStyle )));_bgcd :=_ec .NewCT_Xf ();_bgcd .NumFmtIdAttr =_b .Uint32 (0);
_bgcd .FontIdAttr =_b .Uint32 (0);_bgcd .FillIdAttr =_b .Uint32 (0);_bgcd .BorderIdAttr =_b .Uint32 (0);_cdga .CellStyleXfs .Xf =append (_cdga .CellStyleXfs .Xf ,_bgcd );_cdga .CellStyleXfs .CountAttr =_b .Uint32 (uint32 (len (_cdga .CellStyleXfs .Xf )));
_bfef :=NewFills ();_cdga .Fills =_bfef .X ();_fde :=_bfef .appendFill ().SetPatternFill ();_fde .SetPattern (_ec .ST_PatternTypeNone );_fde =_bfef .appendFill ().SetPatternFill ();_fde .SetPattern (_ec .ST_PatternTypeGray125 );_cdga .Fonts =_ec .NewCT_Fonts ();
_cdga .Borders =_ec .NewCT_Borders ();_bcbe :=StyleSheet {wb ,_cdga };_bcbe .appendBorder ().InitializeDefaults ();_feee :=_bcbe .appendFont ();_feee .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_feee .SetSize (11);_fdfbf :=_ec .NewCT_Xf ();*_fdfbf =*_bgcd ;
_fdfbf .XfIdAttr =_b .Uint32 (0);_cdga .CellXfs .Xf =append (_cdga .CellXfs .Xf ,_fdfbf );_cdga .CellXfs .CountAttr =_b .Uint32 (uint32 (len (_cdga .CellXfs .Xf )));return _bcbe ;};var _gefac =false ;

// Type returns the type of anchor
func (_add OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };

// GetLocked returns true if the cell is locked.
func (_cggg *evalContext )GetLocked (cellRef string )bool {return _cggg ._ddd .Cell (cellRef ).getLocked ()};

// AddFormatValue adds a format value to be used to determine the cell background.
func (_ddc ColorScale )AddFormatValue (t _ec .ST_CfvoType ,val string ){_eae :=_ec .NewCT_Cfvo ();_eae .TypeAttr =t ;_eae .ValAttr =_b .String (val );_ddc ._bbb .Cfvo =append (_ddc ._bbb .Cfvo ,_eae );};

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_fced TwoCellAnchor )SetHeightCells (h int32 ){_fced .SetHeight (0);_adacd :=_fced .TopLeft ();_dfagb :=_fced .BottomRight ();_dfagb .SetRow (_adacd .Row ()+h );};

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_fecca *Workbook )AddDefinedName (name ,ref string )DefinedName {if _fecca ._fffe .DefinedNames ==nil {_fecca ._fffe .DefinedNames =_ec .NewCT_DefinedNames ();};_bcacb :=_ec .NewCT_DefinedName ();_bcacb .Content =ref ;_bcacb .NameAttr =name ;_fecca ._fffe .DefinedNames .DefinedName =append (_fecca ._fffe .DefinedNames .DefinedName ,_bcacb );
return DefinedName {_bcacb };};

// Name returns the sheet name
func (_cddg Sheet )Name ()string {return _cddg ._ade .NameAttr };

// CellMarker represents a cell position
type CellMarker struct{_efca *_eeg .CT_Marker };func (_fbbb Fill )SetPatternFill ()PatternFill {_fbbb ._fcc .GradientFill =nil ;_fbbb ._fcc .PatternFill =_ec .NewCT_PatternFill ();_fbbb ._fcc .PatternFill .PatternTypeAttr =_ec .ST_PatternTypeSolid ;return PatternFill {_fbbb ._fcc .PatternFill ,_fbbb ._fcc };
};func (_fadee *Workbook )ensureSharedStringsRelationships (){_cggd :=false ;for _ ,_deaf :=range _fadee .ContentTypes .X ().Override {if _deaf .ContentTypeAttr ==_b .SharedStringsContentType {_cggd =true ;break ;};};if !_cggd {_fadee .ContentTypes .AddOverride (_bcbg ,_b .SharedStringsContentType );
};_ccgb :=false ;for _ ,_bggaa :=range _fadee ._ggda .Relationships (){if _bggaa .X ().TargetAttr ==_fefe {_ccgb =true ;break ;};};if !_ccgb {_fadee ._ggda .AddRelationship (_fefe ,_b .SharedStringsType );};};

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_dbe Cell )SetDate (d _fd .Time ){_dbe .clearValue ();d =_cad (d );_bbc :=_dbe ._ggb .Epoch ();if d .Before (_bbc ){_de .Log .Debug ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");
return ;};_fcdd :=d .Sub (_bbc );_cceb :=new (_dfd .Float );_dde :=new (_dfd .Float );_dde .SetPrec (128);_dde .SetUint64 (uint64 (_fcdd ));_dac :=new (_dfd .Float );_dac .SetUint64 (24*60*60*1e9);_cceb .Quo (_dde ,_dac );_cge ,_ :=_cceb .Uint64 ();_dbe ._cgd .V =_b .Stringf ("\u0025\u0064",_cge );
};

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_gae Comment )SetCellReference (cellRef string ){_gae ._fecad .RefAttr =cellRef };

// SetHidden controls the visibility of a column.
func (_bfbf Column )SetHidden (b bool ){if !b {_bfbf ._dbef .HiddenAttr =nil ;}else {_bfbf ._dbef .HiddenAttr =_b .Bool (true );};};

// SetHidden marks the defined name as hidden.
func (_gedc DefinedName )SetLocalSheetID (id uint32 ){_gedc ._efeb .LocalSheetIdAttr =_b .Uint32 (id )};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_egcg Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _edcg ,_gdg Cell ;for _ ,_aae :=range lhs .Cells (){_fgd ,_ :=_ggg .ParseCellReference (_aae .Reference ());if _fgd .Column ==column {_edcg =_aae ;break ;};};for _ ,_cdf :=range rhs .Cells (){_abca ,_ :=_ggg .ParseCellReference (_cdf .Reference ());
if _abca .Column ==column {_gdg =_cdf ;break ;};};return _egcg .LessCells (_edcg ,_gdg );};

// X returns the inner wrapped XML type.
func (_egga SharedStrings )X ()*_ec .Sst {return _egga ._cbed };

// X returns the inner wrapped XML type.
func (_gcg Cell )X ()*_ec .CT_Cell {return _gcg ._cgd };

// DefinedNames returns a slice of all defined names in the workbook.
func (_adge *Workbook )DefinedNames ()[]DefinedName {if _adge ._fffe .DefinedNames ==nil {return nil ;};_gdga :=[]DefinedName {};for _ ,_fcgc :=range _adge ._fffe .DefinedNames .DefinedName {_gdga =append (_gdga ,DefinedName {_fcgc });};return _gdga ;};


// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_bgge *_eeg .CT_OneCellAnchor };

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_dfeg *Sheet )Cell (cellRef string )Cell {_aadb ,_cde :=_ggg .ParseCellReference (cellRef );if _cde !=nil {_de .Log .Debug ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_cde );
return _dfeg .AddRow ().AddCell ();};return _dfeg .Row (_aadb .RowIdx ).Cell (_aadb .Column );};

// X returns the inner wrapped XML type.
func (_bbfa Sheet )X ()*_ec .Worksheet {return _bbfa ._gfba };

// TopLeft returns the top-left corner of the anchored object.
func (_bega OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_bega ._bgge .From }};

// SetHeight sets the height of the anchored object.
func (_ab AbsoluteAnchor )SetHeight (h _bd .Distance ){_ab ._cg .Ext .CyAttr =int64 (h /_bd .EMU )};type SheetProtection struct{_dabg *_ec .CT_SheetProtection };

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_bbcf CellStyle )SetVerticalAlignment (a _ec .ST_VerticalAlignment ){if _bbcf ._gdcd .Alignment ==nil {_bbcf ._gdcd .Alignment =_ec .NewCT_CellAlignment ();};_bbcf ._gdcd .ApplyAlignmentAttr =_b .Bool (true );_bbcf ._gdcd .Alignment .VerticalAttr =a ;
};

// X returns the inner wrapped XML type.
func (_gacb DefinedName )X ()*_ec .CT_DefinedName {return _gacb ._efeb };

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_gef DataValidationList )SetRange (cellRange string ){_gef ._cgab .Formula1 =_b .String (cellRange );_gef ._cgab .Formula2 =_b .String ("\u0030");};

// SetPasswordHash sets the password hash to the input.
func (_decae SheetProtection )SetPasswordHash (pwHash string ){_decae ._dabg .PasswordAttr =_b .String (pwHash );};

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_gcceb *Workbook )SetActiveSheet (s Sheet ){for _fcgg ,_acgfbe :=range _gcceb ._fggfc {if s ._gfba ==_acgfbe {_gcceb .SetActiveSheetIndex (uint32 (_fcgg ));};};};

// ClearNumberFormat removes any number formatting from the style.
func (_bcf CellStyle )ClearNumberFormat (){_bcf ._gdcd .NumFmtIdAttr =nil ;_bcf ._gdcd .ApplyNumberFormatAttr =nil ;};

// PasswordHash returns the hash of the workbook password.
func (_ggbf SheetProtection )PasswordHash ()string {if _ggbf ._dabg .PasswordAttr ==nil {return "";};return *_ggbf ._dabg .PasswordAttr ;};func (_fcbb *Sheet )removeColumnFromNamedRanges (_cbeda uint32 )error {for _ ,_adgdc :=range _fcbb ._dfgf .DefinedNames (){_ffec :=_adgdc .Name ();
_dded :=_adgdc .Content ();_bfaga :=_bg .Split (_dded ,"\u0021");if len (_bfaga )!=2{return _da .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_dded );};_cgfdg :=_bfaga [0];
if _fcbb .Name ()==_cgfdg {_ccac :=_fcbb ._dfgf .RemoveDefinedName (_adgdc );if _ccac !=nil {return _ccac ;};_eade :=_dfae (_bfaga [1],_cbeda ,true );if _eade !=""{_gfde :=_cgfdg +"\u0021"+_eade ;_fcbb ._dfgf .AddDefinedName (_ffec ,_gfde );};};};_eccg :=0;
if _fcbb ._gfba .TableParts !=nil &&_fcbb ._gfba .TableParts .TablePart !=nil {_eccg =len (_fcbb ._gfba .TableParts .TablePart );};if _eccg !=0{_ebcc :=0;for _ ,_egef :=range _fcbb ._dfgf .Sheets (){if _egef .Name ()==_fcbb .Name (){break ;}else {if _egef ._gfba .TableParts !=nil &&_egef ._gfba .TableParts .TablePart !=nil {_ebcc +=len (_egef ._gfba .TableParts .TablePart );
};};};_gdeaa :=_fcbb ._dfgf ._bbcff [_ebcc :_ebcc +_eccg ];for _fcdcd ,_bagb :=range _gdeaa {_gdbb :=_bagb ;_gdbb .RefAttr =_dfae (_gdbb .RefAttr ,_cbeda ,false );_fcbb ._dfgf ._bbcff [_ebcc +_fcdcd ]=_gdbb ;};};return nil ;};

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_geb :=uint16 (0);if len (s )> 0{for _aabg :=len (s )-1;_aabg >=0;_aabg --{_agae :=s [_aabg ];_geb =((_geb >>14)&0x01)|((_geb <<1)&0x7fff);_geb ^=uint16 (_agae );};_geb =((_geb >>14)&0x01)|((_geb <<1)&0x7fff);_geb ^=uint16 (len (s ));
_geb ^=(0x8000|('N'<<8)|'K');};return _ae .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_geb ));};

// X returns the inner wrapped XML type.
func (_dgab ColorScale )X ()*_ec .CT_ColorScale {return _dgab ._bbb };func (_bff *evalContext )SetOffset (col ,row uint32 ){_bff ._dbfc =col ;_bff ._eea =row };

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_becg .DocBase ;_fffe *_ec .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_eebg []*_ec .Comments ;_fggfc []*_ec .Worksheet ;_ffdfe []_becg .Relationships ;_ggda _becg .Relationships ;_edcgg []*_ed .Theme ;_ggfge []*_eeg .WsDr ;
_aaae []_becg .Relationships ;_cedfa []*_bc .Container ;_gggb []*_ff .ChartSpace ;_bbcff []*_ec .Table ;_cage string ;_bae map[string ]string ;_bbdd map[string ]*_ff .ChartSpace ;_aacec string ;};

// ClearFont clears any font configuration from the cell style.
func (_ddb CellStyle )ClearFont (){_ddb ._gdcd .FontIdAttr =nil ;_ddb ._gdcd .ApplyFontAttr =nil };

// GetDrawing return the worksheet drawing and its relationships if exists.
func (_feda *Sheet )GetDrawing ()(*_eeg .WsDr ,_becg .Relationships ){if _ggfg :=_feda ._gfba .Drawing ;_ggfg !=nil {_cab :=0;for _ ,_cbfg :=range _feda ._dfgf ._fggfc {if _bfcg :=_cbfg .Drawing ;_bfcg !=nil {if _cbfg ==_feda ._gfba {return _feda ._dfgf ._ggfge [_cab ],_feda ._dfgf ._aaae [_cab ];
};_cab ++;};};};return nil ,_becg .Relationships {};};func (_gbc Cell )getLabelPrefix ()string {if _gbc ._cgd .SAttr ==nil {return "";};_cga :=*_gbc ._cgd .SAttr ;_gbcc :=_gbc ._ggb .StyleSheet .GetCellStyle (_cga );switch _gbcc ._gdcd .Alignment .HorizontalAttr {case _ec .ST_HorizontalAlignmentLeft :return "\u0027";
case _ec .ST_HorizontalAlignmentRight :return "\u0022";case _ec .ST_HorizontalAlignmentCenter :return "\u005e";case _ec .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_ecca *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_beea :=_ecca ._gfba .SheetData .Row ;_bgcb :=_ecca .Rows ();for _eafc ,_fcgb :=range _bgcb {if _fcgb .RowNumber ()==firstRow {_beea =_ecca ._gfba .SheetData .Row [_eafc :];break ;
};};_ffa :=Comparer {Order :order };_g .Slice (_beea ,func (_eggb ,_agce int )bool {return _ffa .LessRows (column ,Row {_ecca ._dfgf ,_ecca ,_beea [_eggb ]},Row {_ecca ._dfgf ,_ecca ,_beea [_agce ]});});for _gcbb ,_eddd :=range _ecca .Rows (){_dcgg :=uint32 (_gcbb +1);
if _eddd .RowNumber ()!=_dcgg {_eddd .renumberAs (_dcgg );};};};

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_agdb *Sheet )RemoveColumn (column string )error {_cgfdb ,_gbbb :=_agdb .getAllCellsInFormulaArraysForColumn ();if _gbbb !=nil {return _gbbb ;};_bbdge :=_ggg .ColumnToIndex (column );for _ ,_bfag :=range _agdb .Rows (){_bdbb :=_ae .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_bfag .X ().RAttr );
if _ ,_aggf :=_cgfdb [_bdbb ];_aggf {return nil ;};};for _ ,_afgf :=range _agdb .Rows (){_gcaf :=_afgf ._ccaa .C ;for _gdeg ,_egaf :=range _gcaf {_gdd ,_bcd :=_ggg .ParseCellReference (*_egaf .RAttr );if _bcd !=nil {return _bcd ;};if _gdd .ColumnIdx ==_bbdge {_afgf ._ccaa .C =append (_gcaf [:_gdeg ],_agdb .slideCellsLeft (_gcaf [_gdeg +1:])...);
break ;}else if _gdd .ColumnIdx > _bbdge {_afgf ._ccaa .C =append (_gcaf [:_gdeg ],_agdb .slideCellsLeft (_gcaf [_gdeg :])...);break ;};};};_gbbb =_agdb .updateAfterRemove (_bbdge ,_dae .UpdateActionRemoveColumn );if _gbbb !=nil {return _gbbb ;};_gbbb =_agdb .removeColumnFromNamedRanges (_bbdge );
if _gbbb !=nil {return _gbbb ;};_gbbb =_agdb .removeColumnFromMergedCells (_bbdge );if _gbbb !=nil {return _gbbb ;};for _ ,_bfagc :=range _agdb ._dfgf .Sheets (){_bfagc .RecalculateFormulas ();};return nil ;};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_efeb *_ec .CT_DefinedName };

// IsEmpty checks if the cell style contains nothing.
func (_ged CellStyle )IsEmpty ()bool {return _ged ._gad ==nil ||_ged ._gdcd ==nil ||_ged ._dffa ==nil ||_ged ._dffa .Xf ==nil ;};func _gec (_ddf _fd .Time )_fd .Time {_ddf =_ddf .UTC ();return _fd .Date (_ddf .Year (),_ddf .Month (),_ddf .Day (),_ddf .Hour (),_ddf .Minute (),_ddf .Second (),_ddf .Nanosecond (),_fd .Local );
};

// GetFill gets a Fill from a cell style.
func (_egdc CellStyle )GetFill ()*_ec .CT_Fill {if _cgg :=_egdc ._gdcd .FillIdAttr ;_cgg !=nil {_fab :=_egdc ._gad .StyleSheet .Fills ().X ().Fill ;if int (*_cgg )< len (_fab ){return _fab [int (*_cgg )];};};return nil ;};

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_decda StyleSheet )RemoveFont (f Font )error {for _fagee ,_eegee :=range _decda ._bdbbe .Fonts .Font {if _eegee ==f .X (){_decda ._bdbbe .Fonts .Font =append (_decda ._bdbbe .Fonts .Font [:_fagee ],_decda ._bdbbe .Fonts .Font [_fagee +1:]...);return nil ;
};};return _da .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};func (_eec Border )SetDiagonal (style _ec .ST_BorderStyle ,c _gd .Color ,up ,down bool ){if _eec ._cd .Diagonal ==nil {_eec ._cd .Diagonal =_ec .NewCT_BorderPr ();
};_eec ._cd .Diagonal .Color =_ec .NewCT_Color ();_eec ._cd .Diagonal .Color .RgbAttr =c .AsRGBAString ();_eec ._cd .Diagonal .StyleAttr =style ;if up {_eec ._cd .DiagonalUpAttr =_b .Bool (true );};if down {_eec ._cd .DiagonalDownAttr =_b .Bool (true );
};};

// AddFont creates a new empty Font style.
func (_aecc StyleSheet )AddFont ()Font {_cfbd :=_ec .NewCT_Font ();return Font {_cfbd ,_aecc ._bdbbe }};

// SetColor sets teh color of the databar.
func (_gdgb DataBarScale )SetColor (c _gd .Color ){_gdgb ._begc .Color =_ec .NewCT_Color ();_gdgb ._begc .Color .RgbAttr =c .AsRGBAString ();};

// MoveTo is a no-op.
func (_bca AbsoluteAnchor )MoveTo (x ,y int32 ){};func (_gebfb Fills )appendFill ()Fill {_afec :=_ec .NewCT_Fill ();_gebfb ._dag .Fill =append (_gebfb ._dag .Fill ,_afec );_gebfb ._dag .CountAttr =_b .Uint32 (uint32 (len (_gebfb ._dag .Fill )));return Fill {_afec ,_gebfb ._dag };
};const _ge ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";func (_bfdg SortOrder )String ()string {if _bfdg >=SortOrder (len (_cdedd )-1){return _ae .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_bfdg );
};return _ecdd [_cdedd [_bfdg ]:_cdedd [_bfdg +1]];};

// AddRule adds and returns a new rule that can be configured.
func (_gac ConditionalFormatting )AddRule ()ConditionalFormattingRule {_age :=_ec .NewCT_CfRule ();_gac ._egg .CfRule =append (_gac ._egg .CfRule ,_age );_faf :=ConditionalFormattingRule {_age };_faf .InitializeDefaults ();_faf .SetPriority (int32 (len (_gac ._egg .CfRule )+1));
return _faf ;};

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_egg *_ec .CT_ConditionalFormatting };

// GetFilename returns the filename of the context's workbook.
func (_abaa *evalContext )GetFilename ()string {return _abaa ._ddd ._dfgf .GetFilename ()};func (_cgac Fills )X ()*_ec .CT_Fills {return _cgac ._dag };

// Protection controls the protection on an individual sheet.
func (_cbab *Sheet )Protection ()SheetProtection {if _cbab ._gfba .SheetProtection ==nil {_cbab ._gfba .SheetProtection =_ec .NewCT_SheetProtection ();};return SheetProtection {_cbab ._gfba .SheetProtection };};

// Priority returns the rule priority
func (_gcb ConditionalFormattingRule )Priority ()int32 {return _gcb ._gge .PriorityAttr };

// AddView adds a sheet view.
func (_eabfd *Sheet )AddView ()SheetView {if _eabfd ._gfba .SheetViews ==nil {_eabfd ._gfba .SheetViews =_ec .NewCT_SheetViews ();};_fbbc :=_ec .NewCT_SheetView ();_eabfd ._gfba .SheetViews .SheetView =append (_eabfd ._gfba .SheetViews .SheetView ,_fbbc );
return SheetView {_fbbc };};

// Border is a cell border configuraton.
type Border struct{_cd *_ec .CT_Border ;_caf *_ec .CT_Borders ;};

// CellText is used for keeping text with references to a cell where it is located.
type CellText struct{Text string ;Cell Cell ;};

// X returns the inner wrapped XML type.
func (_egbg Comment )X ()*_ec .CT_Comment {return _egbg ._fecad };

// SetFill applies a fill to a cell style avoiding redundancy. The function checks if the given fill
// already exists in the saved fills. If found, the existing fill is reused; otherwise,
// the new fill is added to the saved fills collection. The fill is then applied to the cell style,
// affecting all styles that reference it by index.
func (_cbf CellStyle )SetFill (f Fill ){_gdab :=f ._fdfc .Fill ;for _ ,_dggg :=range _gdab {if _dfg .DeepEqual (_dggg ,f ._fcc ){f ._fcc =_dggg ;_cbf ._gdcd .FillIdAttr =_b .Uint32 (f .Index ());_cbf ._gdcd .ApplyFillAttr =_b .Bool (true );return ;};};
f ._fdfc .Fill =append (f ._fdfc .Fill ,f ._fcc );f ._fdfc .CountAttr =_b .Uint32 (uint32 (len (f ._fdfc .Fill )));_cbf ._gdcd .FillIdAttr =_b .Uint32 (f .Index ());_cbf ._gdcd .ApplyFillAttr =_b .Bool (true );};

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_bgfe *Sheet )AddHyperlink (url string )_becg .Hyperlink {for _eaga ,_dcge :=range _bgfe ._dfgf ._fggfc {if _dcge ==_bgfe ._gfba {return _bgfe ._dfgf ._ffdfe [_eaga ].AddHyperlink (url );};};return _becg .Hyperlink {};};func (_ggae *Sheet )setList (_gdea string ,_baa _bec .Result )error {_cegd ,_dfdc :=_ggg .ParseCellReference (_gdea );
if _dfdc !=nil {return _dfdc ;};_gbfe :=_ggae .Row (_cegd .RowIdx );for _gabaa ,_gcedg :=range _baa .ValueList {_bgag :=_gbfe .Cell (_ggg .IndexToColumn (_cegd .ColumnIdx +uint32 (_gabaa )));if _gcedg .Type !=_bec .ResultTypeEmpty {if _gcedg .IsBoolean {_bgag .SetBool (_gcedg .ValueNumber !=0);
}else {_bgag .SetCachedFormulaResult (_gcedg .String ());};};};return nil ;};

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_abad *Workbook )Save (w _eb .Writer )error {const _bdca ="\u0073\u0070\u0072\u0065ad\u0073\u0068\u0065\u0065\u0074\u003a\u0077\u0062\u002e\u0053\u0061\u0076\u0065";if !_be .GetLicenseKey ().IsLicensed ()&&!_gefac {_ae .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");
_ae .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");
return _da .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};if len (_abad ._aacec )==0{_ggee ,_ebeef :=_be .GenRefId ("\u0073\u0077");if _ebeef !=nil {_de .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ebeef );
return _ebeef ;};_abad ._aacec =_ggee ;};if _dbagg :=_be .Track (_abad ._aacec ,_bdca );_dbagg !=nil {_de .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_dbagg );return _dbagg ;};_fedga :=_ad .NewWriter (w );defer _fedga .Close ();_bgd :=_b .DocTypeSpreadsheet ;
if _cfcb :=_ce .MarshalXML (_fedga ,_b .BaseRelsFilename ,_abad .Rels .X ());_cfcb !=nil {return _cfcb ;};if _ddbf :=_ce .MarshalXMLByType (_fedga ,_bgd ,_b .ExtendedPropertiesType ,_abad .AppProperties .X ());_ddbf !=nil {return _ddbf ;};if _fbdad :=_ce .MarshalXMLByType (_fedga ,_bgd ,_b .CorePropertiesType ,_abad .CoreProperties .X ());
_fbdad !=nil {return _fbdad ;};_gbfc :=_b .AbsoluteFilename (_bgd ,_b .OfficeDocumentType ,0);if _baea :=_ce .MarshalXML (_fedga ,_gbfc ,_abad ._fffe );_baea !=nil {return _baea ;};if _gdbbc :=_ce .MarshalXML (_fedga ,_ce .RelationsPathFor (_gbfc ),_abad ._ggda .X ());
_gdbbc !=nil {return _gdbbc ;};if _cacdb :=_ce .MarshalXMLByType (_fedga ,_bgd ,_b .StylesType ,_abad .StyleSheet .X ());_cacdb !=nil {return _cacdb ;};for _bfaa ,_dacc :=range _abad ._edcgg {if _cdca :=_ce .MarshalXMLByTypeIndex (_fedga ,_bgd ,_b .ThemeType ,_bfaa +1,_dacc );
_cdca !=nil {return _cdca ;};};for _efda ,_eaeec :=range _abad ._fggfc {_eaeec .Dimension .RefAttr =Sheet {_abad ,nil ,_eaeec }.Extents ();_efea :=_b .AbsoluteFilename (_bgd ,_b .WorksheetType ,_efda +1);_ce .MarshalXML (_fedga ,_efea ,_eaeec );_ce .MarshalXML (_fedga ,_ce .RelationsPathFor (_efea ),_abad ._ffdfe [_efda ].X ());
};if _ggfe :=_ce .MarshalXMLByType (_fedga ,_bgd ,_b .SharedStringsType ,_abad .SharedStrings .X ());_ggfe !=nil {return _ggfe ;};if _abad .CustomProperties .X ()!=nil {if _ggfec :=_ce .MarshalXMLByType (_fedga ,_bgd ,_b .CustomPropertiesType ,_abad .CustomProperties .X ());
_ggfec !=nil {return _ggfec ;};};if _abad .Thumbnail !=nil {_eceg :=_b .AbsoluteFilename (_bgd ,_b .ThumbnailType ,0);_edcb ,_fagf :=_fedga .Create (_eceg );if _fagf !=nil {return _fagf ;};if _ccdf :=_a .Encode (_edcb ,_abad .Thumbnail ,nil );_ccdf !=nil {return _ccdf ;
};};for _cgdb ,_ecgcd :=range _abad ._gggb {_egdcc :=_b .AbsoluteFilename (_bgd ,_b .ChartType ,_cgdb +1);_ce .MarshalXML (_fedga ,_egdcc ,_ecgcd );};for _adfc ,_ccdfe :=range _abad ._bbcff {_afbe :=_b .AbsoluteFilename (_bgd ,_b .TableType ,_adfc +1);
_ce .MarshalXML (_fedga ,_afbe ,_ccdfe );};for _dfbe ,_gcce :=range _abad ._ggfge {_daad :=_b .AbsoluteFilename (_bgd ,_b .DrawingType ,_dfbe +1);_ce .MarshalXML (_fedga ,_daad ,_gcce );if !_abad ._aaae [_dfbe ].IsEmpty (){_ce .MarshalXML (_fedga ,_ce .RelationsPathFor (_daad ),_abad ._aaae [_dfbe ].X ());
};};for _ebedf ,_gaeg :=range _abad ._cedfa {_ce .MarshalXML (_fedga ,_b .AbsoluteFilename (_bgd ,_b .VMLDrawingType ,_ebedf +1),_gaeg );};for _geebe ,_baba :=range _abad .Images {if _fgea :=_becg .AddImageToZip (_fedga ,_baba ,_geebe +1,_b .DocTypeSpreadsheet );
_fgea !=nil {return _fgea ;};};if _fdba :=_ce .MarshalXML (_fedga ,_b .ContentTypesFilename ,_abad .ContentTypes .X ());_fdba !=nil {return _fdba ;};for _gfdee ,_eddg :=range _abad ._eebg {if _eddg ==nil {continue ;};_ce .MarshalXML (_fedga ,_b .AbsoluteFilename (_bgd ,_b .CommentsType ,_gfdee +1),_eddg );
};if _dbge :=_abad .WriteExtraFiles (_fedga );_dbge !=nil {return _dbge ;};return _fedga .Close ();};const (DVCompareTypeWholeNumber =DVCompareType (_ec .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_ec .ST_DataValidationTypeDecimal );
DVCompareTypeDate =DVCompareType (_ec .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_ec .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_ec .ST_DataValidationTypeTextLength ););

// SetWidth is a no-op.
func (_edecg TwoCellAnchor )SetWidth (w _bd .Distance ){};

// Type returns the type of anchor
func (_fb AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };

// Sheets returns the sheets from the workbook.
func (_ffeef *Workbook )Sheets ()[]Sheet {_bad :=[]Sheet {};for _ccaaa ,_bbfg :=range _ffeef ._fggfc {_dfcd :=_ffeef ._fffe .Sheets .Sheet [_ccaaa ];_fdcec :=Sheet {_ffeef ,_dfcd ,_bbfg };_bad =append (_bad ,_fdcec );};return _bad ;};

// IsSheetLocked returns whether the sheet is locked.
func (_eagb SheetProtection )IsSheetLocked ()bool {return _eagb ._dabg .SheetAttr !=nil &&*_eagb ._dabg .SheetAttr ;};const _aeebd ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";

// SetError sets the cell type to error and the value to the given error message.
func (_efc Cell )SetError (msg string ){_efc .clearValue ();_efc ._cgd .V =_b .String (msg );_efc ._cgd .TAttr =_ec .ST_CellTypeE ;};

// SetHeight sets the row height in points.
func (_eaf Row )SetHeight (d _bd .Distance ){_eaf ._ccaa .HtAttr =_b .Float64 (float64 (d ));_eaf ._ccaa .CustomHeightAttr =_b .Bool (true );};

// Text returns text from the sheet as one string separated with line breaks.
func (_gdad *SheetText )Text ()string {_becd :=_c .NewBuffer ([]byte {});for _ ,_ebdc :=range _gdad .Cells {if _ebdc .Text !=""{_becd .WriteString (_ebdc .Text );_becd .WriteString ("\u000a");};};return _becd .String ();};

// InitializeDefaults initializes a border to its defaulte empty values.
func (_gda Border )InitializeDefaults (){_gda ._cd .Left =_ec .NewCT_BorderPr ();_gda ._cd .Bottom =_ec .NewCT_BorderPr ();_gda ._cd .Right =_ec .NewCT_BorderPr ();_gda ._cd .Top =_ec .NewCT_BorderPr ();_gda ._cd .Diagonal =_ec .NewCT_BorderPr ();};func (_decd Font )SetColor (c _gd .Color ){_eacd :=_ec .NewCT_Color ();
_cebd :="\u0066\u0066"+*c .AsRGBString ();_eacd .RgbAttr =&_cebd ;_decd ._aagc .Color =[]*_ec .CT_Color {_eacd };};const (DVCompareOpEqual =DVCompareOp (_ec .ST_DataValidationOperatorEqual );DVCompareOpBetween =DVCompareOp (_ec .ST_DataValidationOperatorBetween );
DVCompareOpNotBetween =DVCompareOp (_ec .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_ec .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_ec .ST_DataValidationOperatorGreaterThan );DVCompareOpGreaterEqual =DVCompareOp (_ec .ST_DataValidationOperatorGreaterThanOrEqual );
DVCompareOpLess =DVCompareOp (_ec .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_ec .ST_DataValidationOperatorLessThanOrEqual ););

// GetFont gets a Font from a cell style.
func (_fda CellStyle )GetFont ()*_ec .CT_Font {if _bbdc :=_fda ._gdcd .FontIdAttr ;_bbdc !=nil {_beb :=_fda ._gad .StyleSheet .Fonts ();if int (*_bbdc )< len (_beb ){return _beb [int (*_bbdc )].X ();};};return nil ;};

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_degeg *Sheet )SetDrawing (d Drawing ){var _dgabc _becg .Relationships ;for _dfaa ,_debb :=range _degeg ._dfgf ._fggfc {if _debb ==_degeg ._gfba {_dgabc =_degeg ._dfgf ._ffdfe [_dfaa ];break ;};};var _aagcc string ;for _cada ,_cgaa :=range d ._ddcd ._ggfge {if _cgaa ==d ._ced {_agdcd :=_dgabc .AddAutoRelationship (_b .DocTypeSpreadsheet ,_b .WorksheetType ,_cada +1,_b .DrawingType );
_aagcc =_agdcd .ID ();break ;};};_degeg ._gfba .Drawing =_ec .NewCT_Drawing ();_degeg ._gfba .Drawing .IdAttr =_aagcc ;};func (_dggab StandardFormat )String ()string {switch {case 0<=_dggab &&_dggab <=4:return _ebceb [_gfee [_dggab ]:_gfee [_dggab +1]];
case 9<=_dggab &&_dggab <=22:_dggab -=9;return _eagg [_agfd [_dggab ]:_agfd [_dggab +1]];case 37<=_dggab &&_dggab <=40:_dggab -=37;return _ebba [_dcedd [_dggab ]:_dcedd [_dggab +1]];case 45<=_dggab &&_dggab <=49:_dggab -=45;return _caacf [_beda [_dggab ]:_beda [_dggab +1]];
default:return _ae .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_dggab );};};

// Comments is the container for comments for a single sheet.
type Comments struct{_edf *Workbook ;_bfe *_ec .Comments ;};

// Cell returns the actual cell behind the merged region
func (_cgcc MergedCell )Cell ()Cell {_dgga :=_cgcc .Reference ();if _ecc :=_bg .Index (_cgcc .Reference (),"\u003a");_ecc !=-1{_dgga =_dgga [0:_ecc ];return _cgcc ._gffa .Cell (_dgga );};return Cell {};};var _bcbg =_b .AbsoluteFilename (_b .DocTypeSpreadsheet ,_b .SharedStringsType ,0);


// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_cgdf *evalContext )LastColumn (rowFrom ,rowTo int )string {_bfba :=_cgdf ._ddd ;_fbfc :=1;for _fgda :=rowFrom ;_fgda <=rowTo ;_fgda ++{_eaba :=len (_bfba .Row (uint32 (_fgda )).Cells ());if _eaba > _fbfc {_fbfc =_eaba ;};};return _ggg .IndexToColumn (uint32 (_fbfc -1));
};

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_egec *Sheet )InitialView ()SheetView {if _egec ._gfba .SheetViews ==nil ||len (_egec ._gfba .SheetViews .SheetView )==0{return _egec .AddView ();};return SheetView {_egec ._gfba .SheetViews .SheetView [0]};};

// LockSheet controls the locking of the sheet.
func (_edgd SheetProtection )LockSheet (b bool ){if !b {_edgd ._dabg .SheetAttr =nil ;}else {_edgd ._dabg .SheetAttr =_b .Bool (true );};};

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;

// HasFormula returns true if the cell has an asoociated formula.
func (_acd Cell )HasFormula ()bool {return _acd ._cgd .F !=nil };

// StandardFormat is a standard ECMA 376 number format.
//
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;

// Column returns the cell column
func (_fdf Cell )Column ()(string ,error ){_ege ,_gaf :=_ggg .ParseCellReference (_fdf .Reference ());if _gaf !=nil {return "",_gaf ;};return _ege .Column ,nil ;};func (_eef Border )SetTop (style _ec .ST_BorderStyle ,c _gd .Color ){if _eef ._cd .Top ==nil {_eef ._cd .Top =_ec .NewCT_BorderPr ();
};_eef ._cd .Top .Color =_ec .NewCT_Color ();_eef ._cd .Top .Color .RgbAttr =c .AsRGBAString ();_eef ._cd .Top .StyleAttr =style ;};func (_cgfd DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_cgfd .clear ();_cgfd ._cdg .TypeAttr =_ec .ST_DataValidationType (t );
_cgfd ._cdg .OperatorAttr =_ec .ST_DataValidationOperator (op );return DataValidationCompare {_cgfd ._cdg };};

// SaveToFile writes the workbook out to a file.
func (_fecc *Workbook )SaveToFile (path string )error {_daef ,_gdadf :=_df .Create (path );if _gdadf !=nil {return _gdadf ;};defer _daef .Close ();return _fecc .Save (_daef );};

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_ddcc ConditionalFormattingRule )SetIcons ()IconScale {_ddcc .clear ();_ddcc .SetType (_ec .ST_CfTypeIconSet );_ddcc ._gge .IconSet =_ec .NewCT_IconSet ();_aac :=IconScale {_ddcc ._gge .IconSet };_aac .SetIcons (_ec .ST_IconSetType3TrafficLights1 );
return _aac ;};

// Reference returns the table reference (the cells within the table)
func (_edecd Table )Reference ()string {return _edecd ._ggacd .RefAttr };

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_begc *_ec .CT_DataBar };

// SetFormat sets the number format code.
func (_cedf NumberFormat )SetFormat (f string ){_cedf ._ggd .FormatCodeAttr =f };

// WorkbookText is an array of extracted text items which has some methods for representing extracted text from a workbook.
type WorkbookText struct{Sheets []*SheetText ;};func (_fdce *Sheet )updateAfterRemove (_daba uint32 ,_dcgf _dae .UpdateAction )error {_dfef :=_fdce .Name ();_gdgf :=&_dae .UpdateQuery {UpdateType :_dcgf ,ColumnIdx :_daba ,SheetToUpdate :_dfef };for _ ,_dbbf :=range _fdce ._dfgf .Sheets (){_gdgf .UpdateCurrentSheet =_dfef ==_dbbf .Name ();
for _ ,_fedgf :=range _dbbf .Rows (){for _ ,_ccea :=range _fedgf .Cells (){if _ccea .X ().F !=nil {_abgg :=_ccea .X ().F .Content ;_gdac :=_bec .ParseString (_abgg );if _gdac ==nil {_ccea .SetError ("\u0023\u0052\u0045F\u0021");}else {_dbed :=_gdac .Update (_gdgf );
_ccea .X ().F .Content =_ae .Sprintf ("\u003d\u0025\u0073",_dbed .String ());};};};};};return nil ;};type ConditionalFormattingRule struct{_gge *_ec .CT_CfRule };

// X returns the inner wrapped XML type.
func (_gfce RichTextRun )X ()*_ec .CT_RElt {return _gfce ._fedg };func (_fbf Cell )clearValue (){_fbf ._cgd .F =nil ;_fbf ._cgd .Is =nil ;_fbf ._cgd .V =nil ;_fbf ._cgd .TAttr =_ec .ST_CellTypeUnset ;};

// SetRowOffset sets a column offset in absolute distance.
func (_gff CellMarker )SetRowOffset (m _bd .Distance ){_gff ._efca .RowOff .ST_CoordinateUnqualified =_b .Int64 (int64 (m /_bd .EMU ));};

// IconScale maps values to icons.
type IconScale struct{_dce *_ec .CT_IconSet };

// Tables returns a slice of all defined tables in the workbook.
func (_gaef *Workbook )Tables ()[]Table {if _gaef ._bbcff ==nil {return nil ;};_dead :=[]Table {};for _ ,_cfeb :=range _gaef ._bbcff {_dead =append (_dead ,Table {_cfeb });};return _dead ;};

// SetNumber sets the cell type to number, and the value to the given number
func (_eefa Cell )SetNumber (v float64 ){_eefa .clearValue ();if _cf .IsNaN (v )||_cf .IsInf (v ,0){_eefa ._cgd .TAttr =_ec .ST_CellTypeE ;_eefa ._cgd .V =_b .String ("\u0023\u004e\u0055M\u0021");return ;};_eefa ._cgd .TAttr =_ec .ST_CellTypeN ;_eefa ._cgd .V =_b .String (_ee .FormatFloat (v ,'f',-1,64));
};

// Comments returns the comments for a sheet.
func (_fdcc *Sheet )Comments ()Comments {for _fcaaf ,_geac :=range _fdcc ._dfgf ._fggfc {if _geac ==_fdcc ._gfba {if _fdcc ._dfgf ._eebg [_fcaaf ]==nil {_fdcc ._dfgf ._eebg [_fcaaf ]=_ec .NewComments ();_fdcc ._dfgf ._ffdfe [_fcaaf ].AddAutoRelationship (_b .DocTypeSpreadsheet ,_b .WorksheetType ,_fcaaf +1,_b .CommentsType );
_fdcc ._dfgf .ContentTypes .AddOverride (_b .AbsoluteFilename (_b .DocTypeSpreadsheet ,_b .CommentsType ,_fcaaf +1),_b .CommentsContentType );};if len (_fdcc ._dfgf ._cedfa )==0{_fdcc ._dfgf ._cedfa =append (_fdcc ._dfgf ._cedfa ,_bc .NewCommentDrawing ());
_bdfg :=_fdcc ._dfgf ._ffdfe [_fcaaf ].AddAutoRelationship (_b .DocTypeSpreadsheet ,_b .WorksheetType ,1,_b .VMLDrawingType );if _fdcc ._gfba .LegacyDrawing ==nil {_fdcc ._gfba .LegacyDrawing =_ec .NewCT_LegacyDrawing ();};_fdcc ._gfba .LegacyDrawing .IdAttr =_bdfg .ID ();
};return Comments {_fdcc ._dfgf ,_fdcc ._dfgf ._eebg [_fcaaf ]};};};_de .Log .Debug ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");
return Comments {};};func _cecd (_ebec string )bool {_ebec =_bg .Replace (_ebec ,"\u0024","",-1);if _agcb :=_ddcf .FindStringSubmatch (_bg .ToLower (_ebec ));len (_agcb )> 2{_abag :=_agcb [1];_deea ,_cbd :=_ee .Atoi (_agcb [2]);if _cbd !=nil {return false ;
};return _deea <=1048576&&_abag <="\u007a\u007a";};return false ;};const (StandardFormatGeneral StandardFormat =0;StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;
StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;
StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;
StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;
StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;
);

// Type returns the type of the rule
func (_adcd ConditionalFormattingRule )Type ()_ec .ST_CfType {return _adcd ._gge .TypeAttr };

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_adfd TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_adfd ._gecda .To }};func (_cfgd *Sheet )addNumberedRowFast (_bdfd uint32 )Row {_dbfg :=_ec .NewCT_Row ();_dbfg .RAttr =_b .Uint32 (_bdfd );_cfgd ._gfba .SheetData .Row =append (_cfgd ._gfba .SheetData .Row ,_dbfg );
return Row {_cfgd ._dfgf ,_cfgd ,_dbfg };};

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_egae SheetView )SetZoom (pct uint32 ){_egae ._dgeg .ZoomScaleAttr =&pct };

// SetRowOffset sets the row offset of the top-left anchor.
func (_gged OneCellAnchor )SetRowOffset (m _bd .Distance ){_gged .TopLeft ().SetRowOffset (m )};

// SetValues sets the possible values. This is incompatible with SetRange.
func (_cgdg DataValidationList )SetValues (values []string ){_cgdg ._cgab .Formula1 =_b .String ("\u0022"+_bg .Join (values ,"\u002c")+"\u0022");_cgdg ._cgab .Formula2 =_b .String ("\u0030");};

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_eg Cell )Reference ()string {if _eg ._cgd .RAttr !=nil {return *_eg ._cgd .RAttr ;};return "";};

// SortOrder is a column sort order.
//
//go:generate stringer -type=SortOrder
type SortOrder byte ;func (_geeb *Sheet )setShared (_addb string ,_ddde ,_dgcb _ggg .CellReference ,_eggd string ){_facd :=_geeb .FormulaContext ();_becbd :=_bec .NewEvaluator ();for _bebf :=_ddde .RowIdx ;_bebf <=_dgcb .RowIdx ;_bebf ++{for _eege :=_ddde .ColumnIdx ;
_eege <=_dgcb .ColumnIdx ;_eege ++{_ccc :=_bebf -_ddde .RowIdx ;_eacg :=_eege -_ddde .ColumnIdx ;_facd .SetOffset (_eacg ,_ccc );_gead :=_becbd .Eval (_facd ,_eggd );_eca :=_ae .Sprintf ("\u0025\u0073\u0025\u0064",_ggg .IndexToColumn (_eege ),_bebf );_cebcg :=_geeb .Cell (_eca );
if _gead .Type ==_bec .ResultTypeNumber {_cebcg .X ().TAttr =_ec .ST_CellTypeN ;}else {_cebcg .X ().TAttr =_ec .ST_CellTypeInlineStr ;};_cebcg .X ().V =_b .String (_gead .Value ());};};_ =_becbd ;_ =_facd ;};

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_ccebd *_ec .CT_DataValidation };

// X returns the inner wrapped XML type.
func (_eccgb Table )X ()*_ec .Table {return _eccgb ._ggacd };

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_becae Row )AddNamedCell (col string )Cell {_dgfe :=_ec .NewCT_Cell ();_dgfe .RAttr =_b .Stringf ("\u0025\u0073\u0025\u0064",col ,_becae .RowNumber ());_dbbac :=-1;_becgg :=_ggg .ColumnToIndex (col );for _dgcg ,_gedb :=range _becae ._ccaa .C {_bdaf ,_afed :=_ggg .ParseCellReference (*_gedb .RAttr );
if _afed !=nil {return Cell {};};if _becgg < _bdaf .ColumnIdx {_dbbac =_dgcg ;break ;};};if _dbbac ==-1{_becae ._ccaa .C =append (_becae ._ccaa .C ,_dgfe );}else {_becae ._ccaa .C =append (_becae ._ccaa .C [:_dbbac ],append ([]*_ec .CT_Cell {_dgfe },_becae ._ccaa .C [_dbbac :]...)...);
};return Cell {_becae ._cfddf ,_becae ._aaca ,_becae ._ccaa ,_dgfe };};

// Operator returns the operator for the rule
func (_adb ConditionalFormattingRule )Operator ()_ec .ST_ConditionalFormattingOperator {return _adb ._gge .OperatorAttr ;};

// SetColOffset sets the column offset of the two cell anchor.
func (_bea TwoCellAnchor )SetColOffset (m _bd .Distance ){_faeg :=m -_bea .TopLeft ().ColOffset ();_bea .TopLeft ().SetColOffset (m );_bea .BottomRight ().SetColOffset (_bea .BottomRight ().ColOffset ()+_faeg );};

// SetCol set the column of the cell marker.
func (_dbag CellMarker )SetCol (col int32 ){_dbag ._efca .Col =col };func (_agga DifferentialStyle )Fill ()Fill {if _agga ._dgc .Fill ==nil {_agga ._dgc .Fill =_ec .NewCT_Fill ();};return Fill {_agga ._dgc .Fill ,nil };};

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_gafb Cell )SetCachedFormulaResult (s string ){_gafb ._cgd .V =&s };

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_egb Cell )SetFormulaShared (formulaStr string ,rows ,cols uint32 )error {_dege :=_bec .ParseString (formulaStr );if _dege ==nil {return _da .New (_ae .Sprintf ("\u0043a\u006en\u006f\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0073",formulaStr ));
};_egb .clearValue ();_egb ._cgd .TAttr =_ec .ST_CellTypeStr ;_egb ._cgd .F =_ec .NewCT_CellFormula ();_egb ._cgd .F .TAttr =_ec .ST_CellFormulaTypeShared ;_egb ._cgd .F .Content =formulaStr ;_gdf ,_fc :=_ggg .ParseCellReference (_egb .Reference ());if _fc !=nil {return _fc ;
};_adg :=uint32 (0);for _ ,_egf :=range _egb ._bdd .Rows (){for _ ,_egc :=range _egf ._ccaa .C {if _egc .F !=nil &&_egc .F .SiAttr !=nil &&*_egc .F .SiAttr >=_adg {_adg =*_egc .F .SiAttr ;};};};_adg ++;_ba :=_ae .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_gdf .Column ,_gdf .RowIdx ,_ggg .IndexToColumn (_gdf .ColumnIdx +cols ),_gdf .RowIdx +rows );
_egb ._cgd .F .RefAttr =_b .String (_ba );_egb ._cgd .F .SiAttr =_b .Uint32 (_adg );_ef :=Sheet {_egb ._ggb ,_egb ._bdd ._ade ,_egb ._bdd ._gfba };for _dba :=_gdf .RowIdx ;_dba <=_gdf .RowIdx +rows ;_dba ++{for _bag :=_gdf .ColumnIdx ;_bag <=_gdf .ColumnIdx +cols ;
_bag ++{if _dba ==_gdf .RowIdx &&_bag ==_gdf .ColumnIdx {continue ;};_abc :=_ae .Sprintf ("\u0025\u0073\u0025\u0064",_ggg .IndexToColumn (_bag ),_dba );_ef .Cell (_abc ).Clear ();_ef .Cell (_abc ).X ().F =_ec .NewCT_CellFormula ();_ef .Cell (_abc ).X ().F .TAttr =_ec .ST_CellFormulaTypeShared ;
_ef .Cell (_abc ).X ().F .SiAttr =_b .Uint32 (_adg );};};return nil ;};

// SetMaxLength sets the maximum bar length in percent.
func (_adgbe DataBarScale )SetMaxLength (l uint32 ){_adgbe ._begc .MaxLengthAttr =_b .Uint32 (l )};func (_dga CellStyle )Index ()uint32 {for _bdgd ,_dgd :=range _dga ._dffa .Xf {if _dga ._gdcd ==_dgd {return uint32 (_bdgd );};};return 0;};

// X returns the inner wrapped XML type.
func (_agf Comments )X ()*_ec .Comments {return _agf ._bfe };func (_eeb Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _abdb ,_dcag ,_geddd ,_bgaa uint32 =1,1,0,0;for _ ,_cagg :=range _eeb .Rows (){if _cagg .RowNumber ()< _abdb {_abdb =_cagg .RowNumber ();
}else if _cagg .RowNumber ()> _dcag {_dcag =_cagg .RowNumber ();};for _ ,_agdcg :=range _cagg .Cells (){_abbc ,_aeeg :=_ggg .ParseCellReference (_agdcg .Reference ());if _aeeg ==nil {if _abbc .ColumnIdx < _geddd {_geddd =_abbc .ColumnIdx ;}else if _abbc .ColumnIdx > _bgaa {_bgaa =_abbc .ColumnIdx ;
};};};};return _ggg .IndexToColumn (_geddd ),_abdb ,_ggg .IndexToColumn (_bgaa ),_dcag ;};

// GetFormat returns a cell data format.
func (_gde *evalContext )GetFormat (cellRef string )string {return _gde ._ddd .Cell (cellRef ).getFormat ()};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_gcgg *Sheet )RecalculateFormulas (){_gdcg :=_bec .NewEvaluator ();_ddcda :=_gcgg .FormulaContext ();for _ ,_adae :=range _gcgg .Rows (){for _ ,_cegb :=range _adae .Cells (){if _cegb .X ().F !=nil {_bbee :=_cegb .X ().F .Content ;if _cegb .X ().F .TAttr ==_ec .ST_CellFormulaTypeShared &&len (_bbee )==0{continue ;
};_ceee :=_gdcg .Eval (_ddcda ,_bbee ).AsString ();if _ceee .Type ==_bec .ResultTypeError {_de .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_bbee ,_ceee .ErrorMessage );
_cegb .X ().V =nil ;}else {if _ceee .Type ==_bec .ResultTypeNumber {_cegb .X ().TAttr =_ec .ST_CellTypeN ;}else {_cegb .X ().TAttr =_ec .ST_CellTypeInlineStr ;};_cegb .X ().V =_b .String (_ceee .Value ());if _cegb .X ().F .TAttr ==_ec .ST_CellFormulaTypeArray {if _ceee .Type ==_bec .ResultTypeArray {_gcgg .setArray (_cegb .Reference (),_ceee );
}else if _ceee .Type ==_bec .ResultTypeList {_gcgg .setList (_cegb .Reference (),_ceee );};}else if _cegb .X ().F .TAttr ==_ec .ST_CellFormulaTypeShared &&_cegb .X ().F .RefAttr !=nil {_gcge ,_dfggb ,_gefd :=_ggg .ParseRangeReference (*_cegb .X ().F .RefAttr );
if _gefd !=nil {_de .Log .Debug ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_gefd );continue ;};
_gcgg .setShared (_cegb .Reference (),_gcge ,_dfggb ,_bbee );};};};};};};

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_ffca *Sheet )AddRow ()Row {_bee :=uint32 (0);_bfc :=uint32 (len (_ffca ._gfba .SheetData .Row ));if _bfc > 0&&_ffca ._gfba .SheetData .Row [_bfc -1].RAttr !=nil &&*_ffca ._gfba .SheetData .Row [_bfc -1].RAttr ==_bfc {return _ffca .addNumberedRowFast (_bfc +1);
};for _ ,_fcfg :=range _ffca ._gfba .SheetData .Row {if _fcfg .RAttr !=nil &&*_fcfg .RAttr > _bee {_bee =*_fcfg .RAttr ;};};return _ffca .AddNumberedRow (_bee +1);};

// X returns the inner wrapped XML type.
func (_bbda DifferentialStyle )X ()*_ec .CT_Dxf {return _bbda ._dgc };

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_fedd Drawing )AddImage (img _becg .ImageRef ,at AnchorType )Anchor {_fbda :=0;for _gea ,_ddbg :=range _fedd ._ddcd .Images {if _ddbg ==img {_fbda =_gea +1;break ;};};var _dec string ;for _cedd ,_aged :=range _fedd ._ddcd ._ggfge {if _aged ==_fedd ._ced {_edab :=_ae .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_fbda ,img .Format ());
_abac :=_fedd ._ddcd ._aaae [_cedd ].AddRelationship (_edab ,_b .ImageType );_dec =_abac .ID ();break ;};};var _cfd Anchor ;var _edef *_eeg .CT_Picture ;switch at {case AnchorTypeAbsolute :_cbbg :=_gafbb ();_fedd ._ced .EG_Anchor =append (_fedd ._ced .EG_Anchor ,&_eeg .EG_Anchor {AbsoluteAnchor :_cbbg });
_cbbg .Choice =&_eeg .EG_ObjectChoicesChoice {};_cbbg .Choice .Pic =_eeg .NewCT_Picture ();_cbbg .Pos .XAttr .ST_CoordinateUnqualified =_b .Int64 (0);_cbbg .Pos .YAttr .ST_CoordinateUnqualified =_b .Int64 (0);_edef =_cbbg .Choice .Pic ;_cfd =AbsoluteAnchor {_cbbg };
case AnchorTypeOneCell :_ffgca :=_bcfa ();_fedd ._ced .EG_Anchor =append (_fedd ._ced .EG_Anchor ,&_eeg .EG_Anchor {OneCellAnchor :_ffgca });_ffgca .Choice =&_eeg .EG_ObjectChoicesChoice {};_ffgca .Choice .Pic =_eeg .NewCT_Picture ();_edef =_ffgca .Choice .Pic ;
_cfd =OneCellAnchor {_ffgca };case AnchorTypeTwoCell :_adgd :=_faa ();_fedd ._ced .EG_Anchor =append (_fedd ._ced .EG_Anchor ,&_eeg .EG_Anchor {TwoCellAnchor :_adgd });_adgd .Choice =&_eeg .EG_ObjectChoicesChoice {};_adgd .Choice .Pic =_eeg .NewCT_Picture ();
_edef =_adgd .Choice .Pic ;_cfd =TwoCellAnchor {_adgd };};_edef .NvPicPr .CNvPr .IdAttr =uint32 (len (_fedd ._ced .EG_Anchor ));_edef .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_edef .BlipFill .Blip =_ed .NewCT_Blip ();_edef .BlipFill .Blip .EmbedAttr =_b .String (_dec );
_edef .BlipFill .Stretch =_ed .NewCT_StretchInfoProperties ();_edef .SpPr =_ed .NewCT_ShapeProperties ();_edef .SpPr .Xfrm =_ed .NewCT_Transform2D ();_edef .SpPr .Xfrm .Off =_ed .NewCT_Point2D ();_edef .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_b .Int64 (0);
_edef .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_b .Int64 (0);_edef .SpPr .Xfrm .Ext =_ed .NewCT_PositiveSize2D ();_edef .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_bd .Pixel72 )/_bd .EMU );_edef .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_bd .Pixel72 )/_bd .EMU );
_edef .SpPr .PrstGeom =_ed .NewCT_PresetGeometry2D ();_edef .SpPr .PrstGeom .PrstAttr =_ed .ST_ShapeTypeRect ;_edef .SpPr .Ln =_ed .NewCT_LineProperties ();_edef .SpPr .Ln .NoFill =_ed .NewCT_NoFillProperties ();return _cfd ;};

// ClearFill clears any fill configuration from the cell style.
func (_ebe CellStyle )ClearFill (){_ebe ._gdcd .FillIdAttr =nil ;_ebe ._gdcd .ApplyFillAttr =nil };func (_bdff Sheet )validateRowCellNumbers ()error {_cacc :=map[uint32 ]struct{}{};for _ ,_deacf :=range _bdff ._gfba .SheetData .Row {if _deacf .RAttr !=nil {if _ ,_bgb :=_cacc [*_deacf .RAttr ];
_bgb {return _ae .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_bdff .Name (),*_deacf .RAttr );};_cacc [*_deacf .RAttr ]=struct{}{};};_dfda :=map[string ]struct{}{};for _ ,_bfdf :=range _deacf .C {if _bfdf .RAttr ==nil {continue ;
};if _ ,_bccg :=_dfda [*_bfdf .RAttr ];_bccg {return _ae .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_bdff .Name (),*_bfdf .RAttr );};_dfda [*_bfdf .RAttr ]=struct{}{};};};return nil ;
};

// IsNumber returns true if the cell is a number type cell.
func (_efg Cell )IsNumber ()bool {switch _efg ._cgd .TAttr {case _ec .ST_CellTypeN :return true ;case _ec .ST_CellTypeS ,_ec .ST_CellTypeB :return false ;};return _efg ._cgd .V !=nil &&_db .IsNumber (*_efg ._cgd .V );};

// Content returns the content of the defined range (the range in most cases)/
func (_dacf DefinedName )Content ()string {return _dacf ._efeb .Content };

// IsHidden returns whether the row is hidden or not.
func (_cbfc Row )IsHidden ()bool {return _cbfc ._ccaa .HiddenAttr !=nil &&*_cbfc ._ccaa .HiddenAttr };var _dda []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};


// Clear clears the cell's value and type.
func (_gdb Cell )Clear (){_gdb .clearValue ();_gdb ._cgd .TAttr =_ec .ST_CellTypeUnset };

// SetHeightAuto sets the row height to be automatically determined.
func (_egeb Row )SetHeightAuto (){_egeb ._ccaa .HtAttr =nil ;_egeb ._ccaa .CustomHeightAttr =nil };

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_gbd Cell )SetStyleIndex (idx uint32 ){_gbd ._cgd .SAttr =_b .Uint32 (idx )};func (_dadg Font )SetName (name string ){_dadg ._aagc .Name =[]*_ec .CT_FontName {{ValAttr :name }}};

// IsError returns true if the cell is an error type cell.
func (_eac Cell )IsError ()bool {return _eac ._cgd .TAttr ==_ec .ST_CellTypeE };

// ColOffset returns the offset from the row cell.
func (_aag CellMarker )ColOffset ()_bd .Distance {if _aag ._efca .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _bd .Distance (float64 (*_aag ._efca .ColOff .ST_CoordinateUnqualified )*_bd .EMU );};func (_eedb *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _eedb .getAllCellsInFormulaArrays (false );
};

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_aa AbsoluteAnchor )SetRowOffset (m _bd .Distance ){_aa ._cg .Pos .YAttr .ST_CoordinateUnqualified =_b .Int64 (int64 (m /_bd .EMU ));};

// SetName sets the sheet name.
func (_bbbe *Sheet )SetName (name string ){_bbbe ._ade .NameAttr =name };

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_aaa ,_fbg int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_dg _bd .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_bb int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_gbe _bd .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_bdb int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_cbb _bd .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_gc _bd .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};func (_dabe Sheet )IsValid ()bool {return _dabe ._gfba !=nil };

// StyleSheet is a document style sheet.
type StyleSheet struct{_eecc *Workbook ;_bdbbe *_ec .StyleSheet ;};

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_bf Cell )SetBool (v bool ){_bf .clearValue ();_bf ._cgd .V =_b .String (_ee .Itoa (_gbg (v )));_bf ._cgd .TAttr =_ec .ST_CellTypeB ;};

// ClearBorder clears any border configuration from the cell style.
func (_fbc CellStyle )ClearBorder (){_fbc ._gdcd .BorderIdAttr =nil ;_fbc ._gdcd .ApplyBorderAttr =nil };

// BottomRight is a no-op.
func (_cgad OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};

// MergedCells returns the merged cell regions within the sheet.
func (_edff *Sheet )MergedCells ()[]MergedCell {if _edff ._gfba .MergeCells ==nil {return nil ;};_bcec :=[]MergedCell {};for _ ,_gaea :=range _edff ._gfba .MergeCells .MergeCell {_bcec =append (_bcec ,MergedCell {_edff ._dfgf ,_edff ,_gaea });};return _bcec ;
};

// SetHyperlink sets a hyperlink on a cell.
func (_fac Cell )SetHyperlink (hl _becg .Hyperlink ){_eega :=_fac ._bdd ._gfba ;if _eega .Hyperlinks ==nil {_eega .Hyperlinks =_ec .NewCT_Hyperlinks ();};_ffb :=_becg .Relationship (hl );_dab :=_ec .NewCT_Hyperlink ();_dab .RefAttr =_fac .Reference ();
_dab .IdAttr =_b .String (_ffb .ID ());_eega .Hyperlinks .Hyperlink =append (_eega .Hyperlinks .Hyperlink ,_dab );};

// Row is a row within a spreadsheet.
type Row struct{_cfddf *Workbook ;_aaca *Sheet ;_ccaa *_ec .CT_Row ;};

// AddSheet adds a new sheet to a workbook.
func (_gcae *Workbook )AddSheet ()Sheet {_dagb :=_ec .NewCT_Sheet ();_dagb .SheetIdAttr =1;for _ ,_ccba :=range _gcae ._fffe .Sheets .Sheet {if _dagb .SheetIdAttr <=_ccba .SheetIdAttr {_dagb .SheetIdAttr =_ccba .SheetIdAttr +1;};};_gcae ._fffe .Sheets .Sheet =append (_gcae ._fffe .Sheets .Sheet ,_dagb );
_dagb .NameAttr =_ae .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_dagb .SheetIdAttr );_febf :=_ec .NewWorksheet ();_febf .Dimension =_ec .NewCT_SheetDimension ();_febf .Dimension .RefAttr ="\u0041\u0031";_gcae ._fggfc =append (_gcae ._fggfc ,_febf );
_bded :=_becg .NewRelationships ();_gcae ._ffdfe =append (_gcae ._ffdfe ,_bded );_febf .SheetData =_ec .NewCT_SheetData ();_gcae ._eebg =append (_gcae ._eebg ,nil );_aafd :=_b .DocTypeSpreadsheet ;_dfbb :=_gcae ._ggda .AddAutoRelationship (_aafd ,_b .OfficeDocumentType ,len (_gcae ._fffe .Sheets .Sheet ),_b .WorksheetType );
_dagb .IdAttr =_dfbb .ID ();_gcae .ContentTypes .AddOverride (_b .AbsoluteFilename (_aafd ,_b .WorksheetContentType ,len (_gcae ._fffe .Sheets .Sheet )),_b .WorksheetContentType );return Sheet {_gcae ,_dagb ,_febf };};

// PasswordHash returns the hash of the workbook password.
func (_fgca WorkbookProtection )PasswordHash ()string {if _fgca ._bdbc .WorkbookPasswordAttr ==nil {return "";};return *_fgca ._bdbc .WorkbookPasswordAttr ;};

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_ceg CellStyle )SetNumberFormatStandard (s StandardFormat ){_ceg ._gdcd .NumFmtIdAttr =_b .Uint32 (uint32 (s ));_ceg ._gdcd .ApplyNumberFormatAttr =_b .Bool (true );};

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_acfg PatternFill )SetFgColor (c _gd .Color ){_acfg ._febg .FgColor =_ec .NewCT_Color ();_acfg ._febg .FgColor .RgbAttr =c .AsRGBAString ();};type MergedCell struct{_afdb *Workbook ;_gffa *Sheet ;_bge *_ec .CT_MergeCell ;};func (_bce CellStyle )SetShrinkToFit (b bool ){if _bce ._gdcd .Alignment ==nil {_bce ._gdcd .Alignment =_ec .NewCT_CellAlignment ();
};_bce ._gdcd .ApplyAlignmentAttr =_b .Bool (true );if !b {_bce ._gdcd .Alignment .ShrinkToFitAttr =nil ;}else {_bce ._gdcd .Alignment .ShrinkToFitAttr =_b .Bool (b );};};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_bceec *Sheet )ClearSheetViews (){_bceec ._gfba .SheetViews =nil };func (_eag ConditionalFormattingRule )clear (){_eag ._gge .OperatorAttr =_ec .ST_ConditionalFormattingOperatorUnset ;_eag ._gge .ColorScale =nil ;_eag ._gge .IconSet =nil ;_eag ._gge .Formula =nil ;
};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_acgfb *Workbook )ClearCachedFormulaResults (){for _ ,_edgfg :=range _acgfb .Sheets (){_edgfg .ClearCachedFormulaResults ();};};

// New constructs a new workbook.
func New ()*Workbook {_cgbc :=&Workbook {};_cgbc ._fffe =_ec .NewWorkbook ();_cgbc .AppProperties =_becg .NewAppProperties ();_cgbc .CoreProperties =_becg .NewCoreProperties ();_cgbc .StyleSheet =NewStyleSheet (_cgbc );_cgbc .Rels =_becg .NewRelationships ();
_cgbc ._ggda =_becg .NewRelationships ();_cgbc .Rels .AddRelationship (_b .RelativeFilename (_b .DocTypeSpreadsheet ,"",_b .ExtendedPropertiesType ,0),_b .ExtendedPropertiesType );_cgbc .Rels .AddRelationship (_b .RelativeFilename (_b .DocTypeSpreadsheet ,"",_b .CorePropertiesType ,0),_b .CorePropertiesType );
_cgbc .Rels .AddRelationship (_b .RelativeFilename (_b .DocTypeSpreadsheet ,"",_b .OfficeDocumentType ,0),_b .OfficeDocumentType );_cgbc ._ggda .AddRelationship (_b .RelativeFilename (_b .DocTypeSpreadsheet ,_b .OfficeDocumentType ,_b .StylesType ,0),_b .StylesType );
_cgbc .ContentTypes =_becg .NewContentTypes ();_cgbc .ContentTypes .AddDefault ("\u0076\u006d\u006c",_b .VMLDrawingContentType );_cgbc .ContentTypes .AddOverride (_b .AbsoluteFilename (_b .DocTypeSpreadsheet ,_b .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");
_cgbc .ContentTypes .AddOverride (_b .AbsoluteFilename (_b .DocTypeSpreadsheet ,_b .StylesType ,0),_b .SMLStyleSheetContentType );_cgbc .SharedStrings =NewSharedStrings ();_cgbc .ContentTypes .AddOverride (_b .AbsoluteFilename (_b .DocTypeSpreadsheet ,_b .SharedStringsType ,0),_b .SharedStringsContentType );
_cgbc ._ggda .AddRelationship (_b .RelativeFilename (_b .DocTypeSpreadsheet ,_b .OfficeDocumentType ,_b .SharedStringsType ,0),_b .SharedStringsType );_cgbc ._bae =map[string ]string {};return _cgbc ;};

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_gdgd *Workbook )Uses1904Dates ()bool {if _gdgd ._fffe .WorkbookPr ==nil ||_gdgd ._fffe .WorkbookPr .Date1904Attr ==nil {return false ;};return *_gdgd ._fffe .WorkbookPr .Date1904Attr ;};

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_aca Cell )SetStringByID (id int ){_aca ._ggb .ensureSharedStringsRelationships ();_aca .clearValue ();_aca ._cgd .V =_b .String (_ee .Itoa (id ));_aca ._cgd .TAttr =_ec .ST_CellTypeS ;};

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_abdc *Workbook )RemoveCalcChain (){var _efab string ;for _ ,_bfbff :=range _abdc ._ggda .Relationships (){if _bfbff .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_efab ="\u0078\u006c\u002f"+_bfbff .Target ();
_abdc ._ggda .Remove (_bfbff );break ;};};if _efab ==""{return ;};_abdc .ContentTypes .RemoveOverride (_efab );for _fbgdf ,_caabe :=range _abdc .ExtraFiles {if _caabe .ZipPath ==_efab {_abdc .ExtraFiles [_fbgdf ]=_abdc .ExtraFiles [len (_abdc .ExtraFiles )-1];
_abdc .ExtraFiles =_abdc .ExtraFiles [:len (_abdc .ExtraFiles )-1];return ;};};};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_bgeb *Workbook )GetFilename ()string {return _bgeb ._cage };

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_gdaee *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_egad :=_ec .NewCT_ConditionalFormatting ();_gdaee ._gfba .ConditionalFormatting =append (_gdaee ._gfba .ConditionalFormatting ,_egad );_fagb :=make (_ec .ST_Sqref ,0,0);
_egad .SqrefAttr =&_fagb ;for _ ,_becdc :=range cellRanges {*_egad .SqrefAttr =append (*_egad .SqrefAttr ,_becdc );};return ConditionalFormatting {_egad };};

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_dacd Cell )GetString ()string {switch _dacd ._cgd .TAttr {case _ec .ST_CellTypeInlineStr :if _dacd ._cgd .Is !=nil &&_dacd ._cgd .Is .T !=nil {return *_dacd ._cgd .Is .T ;};if _dacd ._cgd .V !=nil {return *_dacd ._cgd .V ;};case _ec .ST_CellTypeS :if _dacd ._cgd .V ==nil {return "";
};_dfa ,_gce :=_ee .Atoi (*_dacd ._cgd .V );if _gce !=nil {return "";};_fbgd ,_gce :=_dacd ._ggb .SharedStrings .GetString (_dfa );if _gce !=nil {return "";};return _fbgd ;};if _dacd ._cgd .V ==nil {return "";};return *_dacd ._cgd .V ;};

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_gecda *_eeg .CT_TwoCellAnchor };

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_egbd Row )RowNumber ()uint32 {if _egbd ._ccaa .RAttr !=nil {return *_egbd ._ccaa .RAttr ;};return 0;};

// X returns the inner wrapped XML type.
func (_cfac SheetProtection )X ()*_ec .CT_SheetProtection {return _cfac ._dabg };

// AddFill creates a new empty Fill style.
func (_aed Fills )AddFill ()Fill {_ebee :=_ec .NewCT_Fill ();return Fill {_ebee ,_aed ._dag }};

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_acdf *evalContext )LastRow (col string )int {_efd :=_acdf ._ddd ;_dbec :=int (_ggg .ColumnToIndex (col ));_ageb :=1;for _ ,_acfe :=range _efd ._gfba .SheetData .Row {if _acfe .RAttr !=nil {_bdab :=Row {_efd ._dfgf ,_efd ,_acfe };_gecd :=len (_bdab .Cells ());
if _gecd > _dbec {_ageb =int (_bdab .RowNumber ());};};};return _ageb ;};

// X returns the inner wrapped XML type.
func (_aceg MergedCell )X ()*_ec .CT_MergeCell {return _aceg ._bge };

// SetPasswordHash sets the password hash to the input.
func (_cfbeb WorkbookProtection )SetPasswordHash (pwHash string ){_cfbeb ._bdbc .WorkbookPasswordAttr =_b .String (pwHash );};

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_efdf *Sheet )SetFrozen (firstRow ,firstCol bool ){_efdf ._gfba .SheetViews =nil ;_caaa :=_efdf .AddView ();_caaa .SetState (_ec .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_caaa .SetYSplit (1);_caaa .SetXSplit (1);_caaa .SetTopLeft ("\u0042\u0032");
case firstRow :_caaa .SetYSplit (1);_caaa .SetTopLeft ("\u0041\u0032");case firstCol :_caaa .SetXSplit (1);_caaa .SetTopLeft ("\u0042\u0031");};};func (_fcd Cell )getLocked ()bool {if _fcd ._cgd .SAttr ==nil {return false ;};_dff :=*_fcd ._cgd .SAttr ;
_dgg :=_fcd ._ggb .StyleSheet .GetCellStyle (_dff );return *_dgg ._gdcd .Protection .LockedAttr ;};

// Validate attempts to validate the structure of a workbook.
func (_eacf *Workbook )Validate ()error {if _eacf ==nil ||_eacf ._fffe ==nil {return _da .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");
};_fbce :=uint32 (0);for _ ,_caggf :=range _eacf ._fffe .Sheets .Sheet {if _caggf .SheetIdAttr > _fbce {_fbce =_caggf .SheetIdAttr ;};};if _fbce !=uint32 (len (_eacf ._fggfc )){return _ae .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_fbce ,len (_eacf ._fggfc ));
};_dfbce :=map[string ]struct{}{};for _cgedaf ,_beedg :=range _eacf ._fffe .Sheets .Sheet {_bgce :=Sheet {_eacf ,_beedg ,_eacf ._fggfc [_cgedaf ]};if _ ,_gbea :=_dfbce [_bgce .Name ()];_gbea {return _ae .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_cgedaf ,_bgce .Name ());
};_dfbce [_bgce .Name ()]=struct{}{};if _bgac :=_bgce .ValidateWithPath (_ae .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_cgedaf ));_bgac !=nil {return _bgac ;};if _cdedc :=_bgce .Validate ();_cdedc !=nil {return _cdedc ;
};};return nil ;};

// X returns the inner wrapped XML type.
func (_gbbd IconScale )X ()*_ec .CT_IconSet {return _gbbd ._dce };

// GetValueAsNumber retrieves the cell's value as a number
func (_cca Cell )GetValueAsNumber ()(float64 ,error ){if _cca ._cgd .V ==nil &&_cca ._cgd .Is ==nil {return 0,nil ;};if _cca ._cgd .TAttr ==_ec .ST_CellTypeS ||!_db .IsNumber (*_cca ._cgd .V ){return _cf .NaN (),_da .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");
};return _ee .ParseFloat (*_cca ._cgd .V ,64);};

// Index returns the index of the border for use with a cell style.
func (_ebd Border )Index ()uint32 {for _ag ,_aba :=range _ebd ._caf .Border {if _aba ==_ebd ._cd {return uint32 (_ag );};};return 0;};

// IsEmpty returns true if the cell is empty.
func (_bbg Cell )IsEmpty ()bool {return _bbg ._cgd .TAttr ==_ec .ST_CellTypeUnset &&_bbg ._cgd .V ==nil &&_bbg ._cgd .F ==nil ;};func NewPatternFill (fills *_ec .CT_Fills )PatternFill {_cba :=_ec .NewCT_Fill ();_cba .PatternFill =_ec .NewCT_PatternFill ();
return PatternFill {_cba .PatternFill ,_cba };};

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_cbcac *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_bg .Replace (rangeRef ,"\u0024","",-1);_cbcac ._gfba .AutoFilter =_ec .NewCT_AutoFilter ();_cbcac ._gfba .AutoFilter .RefAttr =_b .String (rangeRef );_gefa :="\u0027"+_cbcac .Name ()+"\u0027\u0021";
var _bfcb DefinedName ;for _ ,_abda :=range _cbcac ._dfgf .DefinedNames (){if _abda .Name ()==_aeebd {if _bg .HasPrefix (_abda .Content (),_gefa ){_bfcb =_abda ;_bfcb .SetContent (_cbcac .RangeReference (rangeRef ));break ;};};};if _bfcb .X ()==nil {_bfcb =_cbcac ._dfgf .AddDefinedName (_aeebd ,_cbcac .RangeReference (rangeRef ));
};for _bdgc ,_dagf :=range _cbcac ._dfgf ._fggfc {if _dagf ==_cbcac ._gfba {_bfcb .SetLocalSheetID (uint32 (_bdgc ));};};};var ErrorNotFound =_da .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_gcbe StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_cffag :=range _gcbe .CellStyles (){if _cffag .HasNumberFormat ()&&_cffag .NumberFormat ()==uint32 (f ){return _cffag ;};};_dbdd :=_gcbe .AddCellStyle ();_dbdd .SetNumberFormatStandard (f );
return _dbdd ;};

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _eb .ReaderAt ,size int64 )(*Workbook ,error ){const _ggac ="\u0073\u0070r\u0065\u0061\u0064s\u0068\u0065\u0065\u0074\u003a\u0052\u0065\u0061\u0064";if !_be .GetLicenseKey ().IsLicensed ()&&!_gefac {_ae .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");
_ae .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");
return nil ,_da .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_ggf :=New ();_gdadg ,_gcc :=_be .GenRefId ("\u0073\u0072");if _gcc !=nil {_de .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gcc );
return nil ,_gcc ;};_ggf ._aacec =_gdadg ;if _fff :=_be .Track (_ggf ._aacec ,_ggac );_fff !=nil {_de .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fff );return nil ,_fff ;};_cgge ,_gcc :=_ga .TempDir ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078");
if _gcc !=nil {return nil ,_gcc ;};_ggf .TmpPath =_cgge ;_bgf ,_gcc :=_ad .NewReader (r ,size );if _gcc !=nil {return nil ,_ae .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_gcc );};_adde :=[]*_ad .File {};
_adde =append (_adde ,_bgf .File ...);_cbbf :=false ;for _ ,_deac :=range _adde {if _deac .FileHeader .Name =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_cbbf =true ;break ;};};if _cbbf {_ggf .CreateCustomProperties ();
};_fagg :=_ce .DecodeMap {};_fagg .SetOnNewRelationshipFunc (_ggf .onNewRelationship );_fagg .AddTarget (_b .ContentTypesFilename ,_ggf .ContentTypes .X (),"",0);_fagg .AddTarget (_b .BaseRelsFilename ,_ggf .Rels .X (),"",0);if _bga :=_fagg .Decode (_adde );
_bga !=nil {return nil ,_bga ;};for _ ,_ffeg :=range _adde {if _ffeg ==nil {continue ;};if _aeab :=_ggf .AddExtraFileFromZip (_ffeg );_aeab !=nil {return nil ,_aeab ;};};if _cbbf {_cdgb :=false ;for _ ,_adf :=range _ggf .Rels .X ().Relationship {if _adf .TargetAttr =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_cdgb =true ;
break ;};};if !_cdgb {_ggf .AddCustomRelationships ();};};return _ggf ,nil ;};func (_gggg Border )SetRight (style _ec .ST_BorderStyle ,c _gd .Color ){if _gggg ._cd .Right ==nil {_gggg ._cd .Right =_ec .NewCT_BorderPr ();};_gggg ._cd .Right .Color =_ec .NewCT_Color ();
_gggg ._cd .Right .Color .RgbAttr =c .AsRGBAString ();_gggg ._cd .Right .StyleAttr =style ;};

// IsBool returns true if the cell is a boolean type cell.
func (_daa Cell )IsBool ()bool {return _daa ._cgd .TAttr ==_ec .ST_CellTypeB };

// SetWidth sets the width of the anchored object.
func (_dfbc OneCellAnchor )SetWidth (w _bd .Distance ){_dfbc ._bgge .Ext .CxAttr =int64 (w /_bd .EMU )};

// SetHeightCells is a no-op.
func (_ddaf OneCellAnchor )SetHeightCells (int32 ){};

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_cdd Comparer )LessCells (lhs ,rhs Cell )bool {if _cdd .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_bcgd ,_ace :=lhs .getRawSortValue ();
_bbf ,_cag :=rhs .getRawSortValue ();switch {case _ace &&_cag :_bbbg ,_ :=_ee .ParseFloat (_bcgd ,64);_cfa ,_ :=_ee .ParseFloat (_bbf ,64);return _bbbg < _cfa ;case _ace :return true ;case _cag :return false ;};_bcgd =lhs .GetFormattedValue ();_bbf =rhs .GetFormattedValue ();
return _bcgd < _bbf ;};

// SetTopLeft sets the top left visible cell after the split.
func (_gdcca SheetView )SetTopLeft (cellRef string ){_gdcca .ensurePane ();_gdcca ._dgeg .Pane .TopLeftCellAttr =&cellRef ;};

// DataValidation controls cell validation
type DataValidation struct{_cdg *_ec .CT_DataValidation };

// Col returns the column of the cell marker.
func (_dee CellMarker )Col ()int32 {return _dee ._efca .Col };type PatternFill struct{_febg *_ec .CT_PatternFill ;_fdga *_ec .CT_Fill ;};

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_aggg *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_adfdc :=-1;for _dgeb ,_acfb :=range _aggg .Sheets (){if name ==_acfb .Name (){_adfdc =_dgeb ;break ;};};if _adfdc ==-1{return Sheet {},ErrorNotFound ;};return _aggg .CopySheet (_adfdc ,copiedSheetName );
};

// MaxColumnIdx returns the max used column of the sheet.
func (_bffa Sheet )MaxColumnIdx ()uint32 {_defg :=uint32 (0);for _ ,_fdgb :=range _bffa .Rows (){_dbcc :=_fdgb ._ccaa .C ;if len (_dbcc )> 0{_facg :=_dbcc [len (_dbcc )-1];_fggd ,_ :=_ggg .ParseCellReference (*_facg .RAttr );if _defg < _fggd .ColumnIdx {_defg =_fggd .ColumnIdx ;
};};};return _defg ;};

// GetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_cged CellStyle )GetHorizontalAlignment ()_ec .ST_HorizontalAlignment {if _cged ._gdcd .Alignment ==nil {return _ec .ST_HorizontalAlignmentUnset ;};return _cged ._gdcd .Alignment .HorizontalAttr ;};

// AddMergedCells merges cells within a sheet.
func (_edcga *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _edcga ._gfba .MergeCells ==nil {_edcga ._gfba .MergeCells =_ec .NewCT_MergeCells ();};_bdea :=_ec .NewCT_MergeCell ();_bdea .RefAttr =_ae .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );
_edcga ._gfba .MergeCells .MergeCell =append (_edcga ._gfba .MergeCells .MergeCell ,_bdea );_edcga ._gfba .MergeCells .CountAttr =_b .Uint32 (uint32 (len (_edcga ._gfba .MergeCells .MergeCell )));return MergedCell {_edcga ._dfgf ,_edcga ,_bdea };};

// GetEpoch returns a workbook's time epoch.
func (_acb *evalContext )GetEpoch ()_fd .Time {return _acb ._ddd ._dfgf .Epoch ()};

// SetSize sets the text size for a rich text run.
func (_gcad RichTextRun )SetSize (m _bd .Distance ){_gcad .ensureRpr ();_gcad ._fedg .RPr .Sz =_ec .NewCT_FontSize ();_gcad ._fedg .RPr .Sz .ValAttr =float64 (m /_bd .Point );};

// AddString adds a string to the shared string cache.
func (_dbbbe SharedStrings )AddString (v string )int {if _gdcdg ,_bcaff :=_dbbbe ._eabe [v ];_bcaff {return _gdcdg ;};_dadd :=_ec .NewCT_Rst ();_dadd .T =_b .String (v );_dbbbe ._cbed .Si =append (_dbbbe ._cbed .Si ,_dadd );_ecga :=len (_dbbbe ._cbed .Si )-1;
_dbbbe ._eabe [v ]=_ecga ;_dbbbe ._cbed .CountAttr =_b .Uint32 (uint32 (len (_dbbbe ._cbed .Si )));_dbbbe ._cbed .UniqueCountAttr =_dbbbe ._cbed .CountAttr ;return _ecga ;};func (_agfc Font )SetBold (b bool ){if b {_agfc ._aagc .B =[]*_ec .CT_BooleanProperty {{}};
}else {_agfc ._aagc .B =nil ;};};

// X returns the inner wrapped XML type.
func (_dbab RichText )X ()*_ec .CT_Rst {return _dbab ._afef };

// SetPassword sets the password hash to a hash of the input password.
func (_fee SheetProtection )SetPassword (pw string ){_fee .SetPasswordHash (PasswordHash (pw ))};

// X returns the inner wrapped XML type.
func (_gba CellMarker )X ()*_eeg .CT_Marker {return _gba ._efca };

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_dbef *_ec .CT_Col };func (_ecgec Sheet )validateMergedCells ()error {_dbg :=map[uint64 ]struct{}{};for _ ,_feab :=range _ecgec .MergedCells (){_fdd ,_bcac ,_ega :=_ggg .ParseRangeReference (_feab .Reference ());if _ega !=nil {return _ae .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_ecgec .Name (),_feab .Reference ());
};for _gfe :=_fdd .RowIdx ;_gfe <=_bcac .RowIdx ;_gfe ++{for _acbe :=_fdd .ColumnIdx ;_acbe <=_bcac .ColumnIdx ;_acbe ++{_dcf :=uint64 (_gfe )<<32|uint64 (_acbe );if _ ,_gegb :=_dbg [_dcf ];_gegb {return _ae .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_ecgec .Name ());
};_dbg [_dcf ]=struct{}{};};};};return nil ;};

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_gdfe *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_accg :=range _gdfe .Sheets (){if _accg .Name ()==name {return _accg ,nil ;};};return Sheet {},ErrorNotFound ;};

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_agec *Sheet )Column (idx uint32 )Column {for _ ,_ffbf :=range _agec ._gfba .Cols {for _ ,_fbfb :=range _ffbf .Col {if idx >=_fbfb .MinAttr &&idx <=_fbfb .MaxAttr {return Column {_fbfb };};};};var _abf *_ec .CT_Cols ;if len (_agec ._gfba .Cols )==0{_abf =_ec .NewCT_Cols ();
_agec ._gfba .Cols =append (_agec ._gfba .Cols ,_abf );}else {_abf =_agec ._gfba .Cols [0];};_fcbe :=_ec .NewCT_Col ();_fcbe .MinAttr =idx ;_fcbe .MaxAttr =idx ;_abf .Col =append (_abf .Col ,_fcbe );return Column {_fcbe };};

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_facff *Workbook )Epoch ()_fd .Time {if _facff .Uses1904Dates (){_fd .Date (1904,1,1,0,0,0,0,_fd .UTC );};return _fd .Date (1899,12,30,0,0,0,0,_fd .UTC );};

// CellStyle is a formatting style for a cell. CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_gad *Workbook ;_gdcd *_ec .CT_Xf ;_dffa *_ec .CT_CellXfs ;};

// SetType sets the type of the rule.
func (_cac ConditionalFormattingRule )SetType (t _ec .ST_CfType ){_cac ._gge .TypeAttr =t };

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_defd *Sheet )InsertRow (rowNum int )Row {_egcf :=uint32 (rowNum );for _ ,_cdgbf :=range _defd .Rows (){if _cdgbf ._ccaa .RAttr !=nil &&*_cdgbf ._ccaa .RAttr >=_egcf {*_cdgbf ._ccaa .RAttr ++;for _ ,_accf :=range _cdgbf .Cells (){_cdc ,_gbccc :=_ggg .ParseCellReference (_accf .Reference ());
if _gbccc !=nil {continue ;};_cdc .RowIdx ++;_accf ._cgd .RAttr =_b .String (_cdc .String ());};};};for _ ,_edee :=range _defd .MergedCells (){_adac ,_gcfc ,_cbgg :=_ggg .ParseRangeReference (_edee .Reference ());if _cbgg !=nil {continue ;};if int (_adac .RowIdx )>=rowNum {_adac .RowIdx ++;
};if int (_gcfc .RowIdx )>=rowNum {_gcfc .RowIdx ++;};_dfab :=_ae .Sprintf ("\u0025\u0073\u003a%\u0073",_adac ,_gcfc );_edee .SetReference (_dfab );};return _defd .AddNumberedRow (_egcf );};

// Themes returns the array of workbook dml.Theme.
func (_fcca *Workbook )Themes ()[]*_ed .Theme {return _fcca ._edcgg };

// SetFont sets the font name for a rich text run.
func (_bbcfa RichTextRun )SetFont (s string ){_bbcfa .ensureRpr ();_bbcfa ._fedg .RPr .RFont =_ec .NewCT_FontName ();_bbcfa ._fedg .RPr .RFont .ValAttr =s ;};

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_ec .Comments )Comments {return Comments {w ,x }};

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_cbace SheetView )SetState (st _ec .ST_PaneState ){_cbace .ensurePane ();_cbace ._dgeg .Pane .StateAttr =st ;};

// IsWindowLocked returns whether the workbook windows are locked.
func (_ddef WorkbookProtection )IsWindowLocked ()bool {return _ddef ._bdbc .LockWindowsAttr !=nil &&*_ddef ._bdbc .LockWindowsAttr ;};

// SetConditionValue sets the condition value to be used for style applicaton.
func (_bggad ConditionalFormattingRule )SetConditionValue (v string ){_bggad ._gge .Formula =[]string {v };};func (_dede StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));};
for _ ,_ebca :=range _dede ._bdbbe .NumFmts .NumFmt {if _ebca .NumFmtIdAttr ==id {return NumberFormat {_dede ._eecc ,_ebca };};};return NumberFormat {};};func NewFills ()Fills {return Fills {_ec .NewCT_Fills ()}};

// ClearProtection clears all workbook protections.
func (_aacaf *Workbook )ClearProtection (){_aacaf ._fffe .WorkbookProtection =nil };

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_aaf Cell )SetFormulaRaw (s string ){_caa :=_bec .ParseString (s );if _caa ==nil {return ;};_aaf .clearValue ();_aaf ._cgd .TAttr =_ec .ST_CellTypeStr ;_aaf ._cgd .F =_ec .NewCT_CellFormula ();_aaf ._cgd .F .Content =s ;};

// GetVerticalAlignment sets the vertical alignment of a cell style.
func (_cfgc CellStyle )GetVerticalAlignment ()_ec .ST_VerticalAlignment {if _cfgc ._gdcd .Alignment ==nil {return _ec .ST_VerticalAlignmentUnset ;};return _cfgc ._gdcd .Alignment .VerticalAttr ;};

// SetWidthCells is a no-op.
func (_bdbe OneCellAnchor )SetWidthCells (int32 ){};

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_fedg *_ec .CT_RElt };func (_dgcac Sheet )validateSheetNames ()error {_acgd :=len ([]rune (_dgcac .Name ()));if _acgd > 31{return _ae .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_dgcac .Name (),_acgd );
};return nil ;};

// LockStructure controls the locking of the workbook structure.
func (_dcca WorkbookProtection )LockStructure (b bool ){if !b {_dcca ._bdbc .LockStructureAttr =nil ;}else {_dcca ._bdbc .LockStructureAttr =_b .Bool (true );};};

// GetString retrieves a string from the shared strings table by index.
func (_gab SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_ae .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );
};if id > len (_gab ._cbed .Si )-1{return "",_ae .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_gab ._cbed .Si ));
};_cfe :=_gab ._cbed .Si [id ];if _cfe .T !=nil {return *_cfe .T ,nil ;};_fgg :="";for _ ,_gfbe :=range _cfe .R {if _gfbe .T !=""{_fgg +=_gfbe .T ;};};return _fgg ,nil ;};

// SetDateWithStyle sets a date with the default date style applied.
func (_ecd Cell )SetDateWithStyle (d _fd .Time ){_ecd .SetDate (d );for _ ,_fae :=range _ecd ._ggb .StyleSheet .CellStyles (){if _fae .HasNumberFormat ()&&_fae .NumberFormat ()==uint32 (StandardFormatDate ){_ecd .SetStyle (_fae );return ;};};_gbb :=_ecd ._ggb .StyleSheet .AddCellStyle ();
_gbb .SetNumberFormatStandard (StandardFormatDate );_ecd .SetStyle (_gbb );};

// SetLocked sets cell locked or not.
func (_cfc *evalContext )SetLocked (cellRef string ,locked bool ){_cfc ._ddd .Cell (cellRef ).setLocked (locked );};

// SetHeight is a nop-op.
func (_dbee TwoCellAnchor )SetHeight (h _bd .Distance ){};

// SetRow set the row of the cell marker.
func (_fbgde CellMarker )SetRow (row int32 ){_fbgde ._efca .Row =row };

// GetFormat sets the number format code.
func (_acdfg NumberFormat )GetFormat ()string {return _acdfg ._ggd .FormatCodeAttr };

// HasNumberFormat returns true if the cell style has a number format applied.
func (_fdbb CellStyle )HasNumberFormat ()bool {return _fdbb ._gdcd .NumFmtIdAttr !=nil &&_fdbb ._gdcd .ApplyNumberFormatAttr !=nil &&*_fdbb ._gdcd .ApplyNumberFormatAttr ;};func (_cecb PatternFill )ClearBgColor (){_cecb ._febg .BgColor =nil };func (_ffgc Cell )setLocked (_bba bool ){_cfb :=_ffgc ._cgd .SAttr ;
if _cfb !=nil {_dbaa :=_ffgc ._ggb .StyleSheet .GetCellStyle (*_cfb );if _dbaa ._gdcd .Protection ==nil {_dbaa ._gdcd .Protection =_ec .NewCT_CellProtection ();};_dbaa ._gdcd .Protection .LockedAttr =&_bba ;};};func (_dbfd PatternFill )SetBgColor (c _gd .Color ){_dbfd ._febg .BgColor =_ec .NewCT_Color ();
_dbfd ._febg .BgColor .RgbAttr =c .AsRGBAString ();};

// Borders returns the list of borders defined in the stylesheet.
func (_acbd StyleSheet )Borders ()[]Border {_efac :=[]Border {};for _ ,_dcbc :=range _acbd ._bdbbe .Borders .Border {_efac =append (_efac ,Border {_cd :_dcbc });};return _efac ;};

// SetHidden hides or unhides the row
func (_bbab Row )SetHidden (hidden bool ){if !hidden {_bbab ._ccaa .HiddenAttr =nil ;}else {_bbab ._ccaa .HiddenAttr =_b .Bool (true );};};type DifferentialStyle struct{_dgc *_ec .CT_Dxf ;_becc *Workbook ;_ffbd *_ec .CT_Dxfs ;};

// SetColOffset sets a column offset in absolute distance.
func (_edc CellMarker )SetColOffset (m _bd .Distance ){_edc ._efca .ColOff .ST_CoordinateUnqualified =_b .Int64 (int64 (m /_bd .EMU ));};

// X returns the inner wrapped XML type.
func (_faff DataValidation )X ()*_ec .CT_DataValidation {return _faff ._cdg };

// GetValueAsBool retrieves the cell's value as a boolean
func (_bgg Cell )GetValueAsBool ()(bool ,error ){if _bgg ._cgd .TAttr !=_ec .ST_CellTypeB {return false ,_da .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");
};if _bgg ._cgd .V ==nil {return false ,_da .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _ee .ParseBool (*_bgg ._cgd .V );};

// SetShowValue controls if the cell value is displayed.
func (_dfe DataBarScale )SetShowValue (b bool ){_dfe ._begc .ShowValueAttr =_b .Bool (b )};func (_eda ConditionalFormattingRule )InitializeDefaults (){_eda .SetType (_ec .ST_CfTypeCellIs );_eda .SetOperator (_ec .ST_ConditionalFormattingOperatorGreaterThan );
_eda .SetPriority (1);};

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_cbed :_ec .NewSst (),_eabe :make (map[string ]int )};};func (_aga DataValidation )SetList ()DataValidationList {_aga .clear ();_aga ._cdg .TypeAttr =_ec .ST_DataValidationTypeList ;_aga ._cdg .OperatorAttr =_ec .ST_DataValidationOperatorEqual ;
return DataValidationList {_aga ._cdg };};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_ebad *Workbook )SetActiveSheetIndex (idx uint32 ){if _ebad ._fffe .BookViews ==nil {_ebad ._fffe .BookViews =_ec .NewCT_BookViews ();};if len (_ebad ._fffe .BookViews .WorkbookView )==0{_ebad ._fffe .BookViews .WorkbookView =append (_ebad ._fffe .BookViews .WorkbookView ,_ec .NewCT_BookView ());
};_ebad ._fffe .BookViews .WorkbookView [0].ActiveTabAttr =_b .Uint32 (idx );};

// Name returns the name of the table
func (_acbc Table )Name ()string {if _acbc ._ggacd .NameAttr !=nil {return *_acbc ._ggacd .NameAttr ;};return "";};const (_ebceb ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";
_eagg ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";
_ebba ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";
_caacf ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";
);

// SetInlineString adds a string inline instead of in the shared strings table.
func (_deg Cell )SetInlineString (s string ){_deg .clearValue ();_deg ._cgd .Is =_ec .NewCT_Rst ();_deg ._cgd .Is .T =_b .String (s );_deg ._cgd .TAttr =_ec .ST_CellTypeInlineStr ;};

// SetColOffset sets the column offset of the top-left anchor.
func (_bdgdd OneCellAnchor )SetColOffset (m _bd .Distance ){_bdgdd .TopLeft ().SetColOffset (m )};func (_bdc PatternFill )X ()*_ec .CT_PatternFill {return _bdc ._febg };

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_dbb Cell )SetTime (d _fd .Time ){_dbb .clearValue ();d =_cad (d );_fbe :=_dbb ._ggb .Epoch ();if d .Before (_fbe ){_de .Log .Debug ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");
return ;};_gf :=d .Sub (_fbe );_gdc :=new (_dfd .Float );_bbd :=new (_dfd .Float );_bbd .SetPrec (128);_bbd .SetUint64 (uint64 (_gf ));_fa :=new (_dfd .Float );_fa .SetUint64 (24*60*60*1e9);_gdc .Quo (_bbd ,_fa );_dbb ._cgd .V =_b .String (_gdc .Text ('g',20));
};

// Type returns the type of anchor
func (_fedge TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };func (_fe Border )SetLeft (style _ec .ST_BorderStyle ,c _gd .Color ){if _fe ._cd .Left ==nil {_fe ._cd .Left =_ec .NewCT_BorderPr ();};_fe ._cd .Left .Color =_ec .NewCT_Color ();
_fe ._cd .Left .Color .RgbAttr =c .AsRGBAString ();_fe ._cd .Left .StyleAttr =style ;};

// SetUnderline controls if the run is underlined.
func (_bcgdf RichTextRun )SetUnderline (u _ec .ST_UnderlineValues ){_bcgdf .ensureRpr ();_bcgdf ._fedg .RPr .U =_ec .NewCT_UnderlineProperty ();_bcgdf ._fedg .RPr .U .ValAttr =u ;};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_bdg CellStyle )NumberFormat ()uint32 {if _bdg ._gdcd .NumFmtIdAttr ==nil {return 0;};return *_bdg ._gdcd .NumFmtIdAttr ;};

// SetXSplit sets the column split point
func (_cdeda SheetView )SetXSplit (v float64 ){_cdeda .ensurePane ();_cdeda ._dgeg .Pane .XSplitAttr =_b .Float64 (v );};

// SetWrapped configures the cell to wrap text.
func (_fcdcf CellStyle )SetWrapped (b bool ){if _fcdcf ._gdcd .Alignment ==nil {_fcdcf ._gdcd .Alignment =_ec .NewCT_CellAlignment ();};if !b {_fcdcf ._gdcd .Alignment .WrapTextAttr =nil ;}else {_fcdcf ._gdcd .Alignment .WrapTextAttr =_b .Bool (true );
_fcdcf ._gdcd .ApplyAlignmentAttr =_b .Bool (true );};};func (_fcgba *Sheet )slideCellsLeft (_ebac []*_ec .CT_Cell )[]*_ec .CT_Cell {for _ ,_fffd :=range _ebac {_bab ,_efbb :=_ggg .ParseCellReference (*_fffd .RAttr );if _efbb !=nil {return _ebac ;};_ffdc :=_bab .ColumnIdx -1;
_aacfb :=_ggg .IndexToColumn (_ffdc )+_ae .Sprintf ("\u0025\u0064",_bab .RowIdx );_fffd .RAttr =&_aacfb ;};return _ebac ;};func (_daag *Sheet )setArray (_febc string ,_eee _bec .Result )error {_gcfd ,_dbeg :=_ggg .ParseCellReference (_febc );if _dbeg !=nil {return _dbeg ;
};for _edd ,_ecaa :=range _eee .ValueArray {_eefg :=_daag .Row (_gcfd .RowIdx +uint32 (_edd ));for _bdec ,_aeec :=range _ecaa {_fada :=_eefg .Cell (_ggg .IndexToColumn (_gcfd .ColumnIdx +uint32 (_bdec )));if _aeec .Type !=_bec .ResultTypeEmpty {if _aeec .IsBoolean {_fada .SetBool (_aeec .ValueNumber !=0);
}else {_fada .SetCachedFormulaResult (_aeec .String ());};};};};return nil ;};

// SetAllowBlank controls if blank values are accepted.
func (_fdfd DataValidation )SetAllowBlank (b bool ){if !b {_fdfd ._cdg .AllowBlankAttr =nil ;}else {_fdfd ._cdg .AllowBlankAttr =_b .Bool (true );};};const (DVOpGreater =_ec .ST_DataValidationOperatorGreaterThanOrEqual ;);

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_bbb *_ec .CT_ColorScale };

// AddHyperlink creates and sets a hyperlink on a cell.
func (_bgga Cell )AddHyperlink (url string ){for _efe ,_cebg :=range _bgga ._ggb ._fggfc {if _cebg ==_bgga ._bdd ._gfba {_bgga .SetHyperlink (_bgga ._ggb ._ffdfe [_efe ].AddHyperlink (url ));return ;};};};type evalContext struct{_ddd *Sheet ;_dbfc ,_eea uint32 ;
_dbbb map[string ]struct{};};

// SetProtectedAndHidden sets protected and hidden for given cellStyle
func (_fbef CellStyle )SetProtection (protected bool ,hidden bool ){_fbef ._gdcd .Protection =&_ec .CT_CellProtection {LockedAttr :&protected ,HiddenAttr :&hidden };};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_dgeg *_ec .CT_SheetView };

// AddCell adds a cell to a spreadsheet.
func (_cdbd Row )AddCell ()Cell {_fge :=uint32 (len (_cdbd ._ccaa .C ));var _cbg *string ;if _fge > 0{_fafa :=_b .Stringf ("\u0025\u0073\u0025\u0064",_ggg .IndexToColumn (_fge -1),_cdbd .RowNumber ());if _cdbd ._ccaa .C [_fge -1].RAttr !=nil &&*_cdbd ._ccaa .C [_fge -1].RAttr ==*_fafa {_cbg =_b .Stringf ("\u0025\u0073\u0025\u0064",_ggg .IndexToColumn (_fge ),_cdbd .RowNumber ());
};};_cbgb :=_ec .NewCT_Cell ();_cdbd ._ccaa .C =append (_cdbd ._ccaa .C ,_cbgb );if _cbg ==nil {_affe :=uint32 (0);for _ ,_cebc :=range _cdbd ._ccaa .C {if _cebc .RAttr !=nil {_gebb ,_ :=_ggg .ParseCellReference (*_cebc .RAttr );if _gebb .ColumnIdx >=_affe {_affe =_gebb .ColumnIdx +1;
};};};_cbg =_b .Stringf ("\u0025\u0073\u0025\u0064",_ggg .IndexToColumn (_affe ),_cdbd .RowNumber ());};_cbgb .RAttr =_cbg ;return Cell {_cdbd ._cfddf ,_cdbd ._aaca ,_cdbd ._ccaa ,_cbgb };};

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_cgab *_ec .CT_DataValidation };

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_ccg *Sheet )RemoveMergedCell (mc MergedCell ){for _acgf ,_bgc :=range _ccg ._gfba .MergeCells .MergeCell {if _bgc ==mc .X (){copy (_ccg ._gfba .MergeCells .MergeCell [_acgf :],_ccg ._gfba .MergeCells .MergeCell [_acgf +1:]);_ccg ._gfba .MergeCells .MergeCell [len (_ccg ._gfba .MergeCells .MergeCell )-1]=nil ;
_ccg ._gfba .MergeCells .MergeCell =_ccg ._gfba .MergeCells .MergeCell [:len (_ccg ._gfba .MergeCells .MergeCell )-1];};};};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_fdgf Comment )CellReference ()string {return _fdgf ._fecad .RefAttr };

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_bfce *Workbook )RecalculateFormulas (){for _ ,_fcabe :=range _bfce .Sheets (){_fcabe .RecalculateFormulas ();};};

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_bagc Cell )SetString (s string )int {_bagc ._ggb .ensureSharedStringsRelationships ();_bagc .clearValue ();_agg :=_bagc ._ggb .SharedStrings .AddString (s );_bagc ._cgd .V =_b .String (_ee .Itoa (_agg ));_bagc ._cgd .TAttr =_ec .ST_CellTypeS ;return _agg ;
};

// SetText sets the text to be displayed.
func (_fcdb RichTextRun )SetText (s string ){_fcdb ._fedg .T =s };

// Index returns the index of the differential style.
func (_cgeda DifferentialStyle )Index ()uint32 {for _abg ,_edb :=range _cgeda ._ffbd .Dxf {if _cgeda ._dgc ==_edb {return uint32 (_abg );};};return 0;};func (_bffe Row )renumberAs (_egbf uint32 ){_bffe ._ccaa .RAttr =_b .Uint32 (_egbf );for _ ,_dge :=range _bffe .Cells (){_bcee ,_bbag :=_ggg .ParseCellReference (_dge .Reference ());
if _bbag ==nil {_abef :=_ae .Sprintf ("\u0025\u0073\u0025\u0064",_bcee .Column ,_egbf );_dge ._cgd .RAttr =_b .String (_abef );};};};

// IsDBCS returns if a workbook's default language is among DBCS.
func (_eage *evalContext )IsDBCS ()bool {_bda :=_eage ._ddd ._dfgf .CoreProperties .X ().Language ;if _bda ==nil {return false ;};_cfbf :=string (_bda .Data );for _ ,_fedf :=range _dda {if _cfbf ==_fedf {return true ;};};return false ;};

// AnchorType is the type of anchor.
type AnchorType byte ;

// SetWidth sets the width of the anchored object.
func (_gb AbsoluteAnchor )SetWidth (w _bd .Distance ){_gb ._cg .Ext .CxAttr =int64 (w /_bd .EMU )};

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_bdgb *Sheet )Row (rowNum uint32 )Row {for _ ,_faed :=range _bdgb ._gfba .SheetData .Row {if _faed .RAttr !=nil &&*_faed .RAttr ==rowNum {return Row {_bdgb ._dfgf ,_bdgb ,_faed };};};return _bdgb .AddNumberedRow (rowNum );};func (_ead *evalContext )Cell (ref string ,ev _bec .Evaluator )_bec .Result {if !_cecd (ref ){return _bec .MakeErrorResultType (_bec .ErrorTypeName ,"");
};_efb :=_ead ._ddd .Name ()+"\u0021"+ref ;if _cbbe ,_gdfa :=ev .GetFromCache (_efb );_gdfa {return _cbbe ;};_dbba ,_cebe :=_ggg .ParseCellReference (ref );if _cebe !=nil {return _bec .MakeErrorResult (_ae .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_cebe ));
};if _ead ._dbfc !=0&&!_dbba .AbsoluteColumn {_dbba .ColumnIdx +=_ead ._dbfc ;_dbba .Column =_ggg .IndexToColumn (_dbba .ColumnIdx );};if _ead ._eea !=0&&!_dbba .AbsoluteRow {_dbba .RowIdx +=_ead ._eea ;};_fdad :=_ead ._ddd .Cell (_dbba .String ());if _fdad .HasFormula (){if _ ,_cbca :=_ead ._dbbb [ref ];
_cbca {return _bec .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );
};_ead ._dbbb [ref ]=struct{}{};_dfga :=ev .Eval (_ead ,_fdad .GetFormula ());delete (_ead ._dbbb ,ref );ev .SetCache (_efb ,_dfga );return _dfga ;};if _fdad .IsEmpty (){_aef :=_bec .MakeEmptyResult ();ev .SetCache (_efb ,_aef );return _aef ;}else if _fdad .IsNumber (){_bcgb ,_ :=_fdad .GetValueAsNumber ();
_becaf :=_bec .MakeNumberResult (_bcgb );ev .SetCache (_efb ,_becaf );return _becaf ;}else if _fdad .IsBool (){_agee ,_ :=_fdad .GetValueAsBool ();_agd :=_bec .MakeBoolResult (_agee );ev .SetCache (_efb ,_agd );return _agd ;};_gdcdd ,_ :=_fdad .GetRawValue ();
if _fdad .IsError (){_ebed :=_bec .MakeErrorResult ("");_ebed .ValueString =_gdcdd ;ev .SetCache (_efb ,_ebed );return _ebed ;};_aab :=_bec .MakeStringResult (_gdcdd );ev .SetCache (_efb ,_aab );return _aab ;};

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_ceeg *Workbook )AddDrawing ()Drawing {_ebedff :=_eeg .NewWsDr ();_ceeg ._ggfge =append (_ceeg ._ggfge ,_ebedff );_adaeb :=_b .AbsoluteFilename (_b .DocTypeSpreadsheet ,_b .DrawingType ,len (_ceeg ._ggfge ));_ceeg .ContentTypes .AddOverride (_adaeb ,_b .DrawingContentType );
_ceeg ._aaae =append (_ceeg ._aaae ,_becg .NewRelationships ());return Drawing {_ceeg ,_ebedff };};

// SetStyle applies a style to a cell avoiding redundancy. The function checks if the given style
// already exists in the saved styles. If found, the existing style is reused; otherwise,
// the new style is added to the saved styles collection. The style is then applied to the cell.
// This style is referenced in the generated XML via CellStyle.Index().
func (_ceb Cell )SetStyle (cs CellStyle ){_gdae :=cs ._dffa .Xf ;for _ ,_fdb :=range _gdae {if _dfg .DeepEqual (_fdb ,cs ._gdcd ){cs ._gdcd =_fdb ;_ceb .SetStyleIndex (cs .Index ());return ;};};cs ._dffa .Xf =append (cs ._dffa .Xf ,cs ._gdcd );cs ._dffa .CountAttr =_b .Uint32 (uint32 (len (cs ._dffa .Xf )));
_ceb .SetStyleIndex (cs .Index ());};

// SetIcons sets the icon set to use for display.
func (_cade IconScale )SetIcons (t _ec .ST_IconSetType ){_cade ._dce .IconSetAttr =t };

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_ddcd *Workbook ;_ced *_eeg .WsDr ;};

// Author returns the author of the comment
func (_bde Comment )Author ()string {if _bde ._fecad .AuthorIdAttr < uint32 (len (_bde ._cced .Authors .Author )){return _bde ._cced .Authors .Author [_bde ._fecad .AuthorIdAttr ];};return "";};const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;
AnchorTypeTwoCell ;);func _faa ()*_eeg .CT_TwoCellAnchor {_fbb :=_eeg .NewCT_TwoCellAnchor ();_fbb .EditAsAttr =_eeg .ST_EditAsOneCell ;_fbb .From .Col =5;_fbb .From .Row =0;_fbb .From .ColOff .ST_CoordinateUnqualified =_b .Int64 (0);_fbb .From .RowOff .ST_CoordinateUnqualified =_b .Int64 (0);
_fbb .To .Col =10;_fbb .To .Row =20;_fbb .To .ColOff .ST_CoordinateUnqualified =_b .Int64 (0);_fbb .To .RowOff .ST_CoordinateUnqualified =_b .Int64 (0);return _fbb ;};func _dfae (_cgbcf string ,_gebf uint32 ,_ggcg bool )string {_aaef ,_eafa ,_fece :=_ggg .ParseRangeReference (_cgbcf );
if _fece ==nil {_bgcg ,_gadg :=_aaef .ColumnIdx ,_eafa .ColumnIdx ;if _gebf >=_bgcg &&_gebf <=_gadg {if _bgcg ==_gadg {if _ggcg {return "";}else {return _cgbcf ;};}else {_ceba :=_eafa .Update (_dae .UpdateActionRemoveColumn );return _ae .Sprintf ("\u0025\u0073\u003a%\u0073",_aaef .String (),_ceba .String ());
};}else if _gebf < _bgcg {_eagag :=_aaef .Update (_dae .UpdateActionRemoveColumn );_cgabc :=_eafa .Update (_dae .UpdateActionRemoveColumn );return _ae .Sprintf ("\u0025\u0073\u003a%\u0073",_eagag .String (),_cgabc .String ());};}else {_aagdf ,_caaaa ,_dbbge :=_ggg .ParseColumnRangeReference (_cgbcf );
if _dbbge !=nil {return "";};_ccf ,_eed :=_aagdf .ColumnIdx ,_caaaa .ColumnIdx ;if _gebf >=_ccf &&_gebf <=_eed {if _ccf ==_eed {if _ggcg {return "";}else {return _cgbcf ;};}else {_ecec :=_caaaa .Update (_dae .UpdateActionRemoveColumn );return _ae .Sprintf ("\u0025\u0073\u003a%\u0073",_aagdf .String (),_ecec .String ());
};}else if _gebf < _ccf {_dddf :=_aagdf .Update (_dae .UpdateActionRemoveColumn );_begaa :=_caaaa .Update (_dae .UpdateActionRemoveColumn );return _ae .Sprintf ("\u0025\u0073\u003a%\u0073",_dddf .String (),_begaa .String ());};};return "";};

// SetStyle sets the style to be used for conditional rules
func (_gffg ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_gffg ._gge .DxfIdAttr =_b .Uint32 (d .Index ());};func (_cfde Font )Index ()uint32 {for _bfd ,_fbfg :=range _cfde ._fbbf .Fonts .Font {if _cfde ._aagc ==_fbfg {return uint32 (_bfd );
};};return 0;};

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_aagc *_ec .CT_Font ;_fbbf *_ec .StyleSheet ;};func (_aee Border )SetBottom (style _ec .ST_BorderStyle ,c _gd .Color ){if _aee ._cd .Bottom ==nil {_aee ._cd .Bottom =_ec .NewCT_BorderPr ();};_aee ._cd .Bottom .Color =_ec .NewCT_Color ();
_aee ._cd .Bottom .Color .RgbAttr =c .AsRGBAString ();_aee ._cd .Bottom .StyleAttr =style ;};

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_cgfa Cell )GetFormattedValue ()string {_cbe :=_cgfa .getFormat ();switch _cgfa ._cgd .TAttr {case _ec .ST_CellTypeB :_cce ,_ :=_cgfa .GetValueAsBool ();if _cce {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _ec .ST_CellTypeN :_aeeb ,_ :=_cgfa .GetValueAsNumber ();
return _db .Number (_aeeb ,_cbe );case _ec .ST_CellTypeE :if _cgfa ._cgd .V !=nil {return *_cgfa ._cgd .V ;};return "";case _ec .ST_CellTypeS ,_ec .ST_CellTypeInlineStr :return _db .String (_cgfa .GetString (),_cbe );case _ec .ST_CellTypeStr :_edg :=_cgfa .GetString ();
if _db .IsNumber (_edg ){_efa ,_ :=_ee .ParseFloat (_edg ,64);return _db .Number (_efa ,_cbe );};return _db .String (_edg ,_cbe );case _ec .ST_CellTypeUnset :fallthrough;default:_fdg ,_ :=_cgfa .GetRawValue ();if len (_fdg )==0{return "";};_ffc ,_dd :=_cgfa .GetValueAsNumber ();
if _dd ==nil {return _db .Number (_ffc ,_cbe );};return _db .String (_fdg ,_cbe );};};

// X returns the inner wrapped XML type.
func (_bbbd Drawing )X ()*_eeg .WsDr {return _bbbd ._ced };

// SetHeight sets the height of the anchored object.
func (_gbcb OneCellAnchor )SetHeight (h _bd .Distance ){_gbcb ._bgge .Ext .CyAttr =int64 (h /_bd .EMU )};func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_fdc :=NumberFormat {_ggd :_ec .NewCT_NumFmt ()};_fdc ._ggd .NumFmtIdAttr =uint32 (id );
_fdc ._ggd .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";switch id {case StandardFormat0 :_fdc ._ggd .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_fdc ._ggd .FormatCodeAttr ="\u0030";case StandardFormat2 :_fdc ._ggd .FormatCodeAttr ="\u0030\u002e\u0030\u0030";
case StandardFormat3 :_fdc ._ggd .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";case StandardFormat4 :_fdc ._ggd .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";case StandardFormat9 :_fdc ._ggd .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_fdc ._ggd .FormatCodeAttr ="\u0030\u002e\u00300\u0025";
case StandardFormat11 :_fdc ._ggd .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";case StandardFormat12 :_fdc ._ggd .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_fdc ._ggd .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";
case StandardFormat14 :_fdc ._ggd .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";case StandardFormat15 :_fdc ._ggd .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_fdc ._ggd .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";
case StandardFormat17 :_fdc ._ggd .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat18 :_fdc ._ggd .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_fdc ._ggd .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";
case StandardFormat20 :_fdc ._ggd .FormatCodeAttr ="\u0068\u003a\u006d\u006d";case StandardFormat21 :_fdc ._ggd .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_fdc ._ggd .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";
case StandardFormat37 :_fdc ._ggd .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";case StandardFormat38 :_fdc ._ggd .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";
case StandardFormat39 :_fdc ._ggd .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat40 :_fdc ._ggd .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";
case StandardFormat45 :_fdc ._ggd .FormatCodeAttr ="\u006d\u006d\u003as\u0073";case StandardFormat46 :_fdc ._ggd .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_fdc ._ggd .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";
case StandardFormat48 :_fdc ._ggd .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";case StandardFormat49 :_fdc ._ggd .FormatCodeAttr ="\u0040";};return _fdc ;};

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_eefc *Sheet )SheetViews ()[]SheetView {if _eefc ._gfba .SheetViews ==nil {return nil ;};_fddf :=[]SheetView {};for _ ,_aacf :=range _eefc ._gfba .SheetViews .SheetView {_fddf =append (_fddf ,SheetView {_aacf });};return _fddf ;};

// GetBorder gets a Border from a cell style.
func (_ecg CellStyle )GetBorder ()*_ec .CT_Border {if _bfb :=_ecg ._gdcd .BorderIdAttr ;_bfb !=nil {_aea :=_ecg ._gad .StyleSheet .Borders ();if int (*_bfb )< len (_aea ){return _aea [int (*_bfb )].X ();};};return nil ;};type WorkbookProtection struct{_bdbc *_ec .CT_WorkbookProtection };


// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_geca *evalContext )GetLabelPrefix (cellRef string )string {return _geca ._ddd .Cell (cellRef ).getLabelPrefix ();};

// Protection allows control over the workbook protections.
func (_ebdf *Workbook )Protection ()WorkbookProtection {if _ebdf ._fffe .WorkbookProtection ==nil {_ebdf ._fffe .WorkbookProtection =_ec .NewCT_WorkbookProtection ();};return WorkbookProtection {_ebdf ._fffe .WorkbookProtection };};

// HasFormula returns true if the cell contains formula.
func (_ede *evalContext )HasFormula (cellRef string )bool {return _ede ._ddd .Cell (cellRef ).HasFormula ()};func (_dfcf DataValidation )clear (){_dfcf ._cdg .Formula1 =_b .String ("\u0030");_dfcf ._cdg .Formula2 =_b .String ("\u0030");};

// Workbook returns sheet's parent workbook.
func (_fggf *Sheet )Workbook ()*Workbook {return _fggf ._dfgf };

// CellStyles returns the list of defined cell styles
func (_gbga StyleSheet )CellStyles ()[]CellStyle {_bgba :=[]CellStyle {};for _ ,_cbea :=range _gbga ._bdbbe .CellXfs .Xf {_bgba =append (_bgba ,CellStyle {_gbga ._eecc ,_cbea ,_gbga ._bdbbe .CellXfs });};return _bgba ;};

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_dc Cell )SetFormulaArray (s string ){_bcaf :=_bec .ParseString (s );if _bcaf ==nil {return ;};_dc .clearValue ();_dc ._cgd .TAttr =_ec .ST_CellTypeStr ;_dc ._cgd .F =_ec .NewCT_CellFormula ();_dc ._cgd .F .TAttr =_ec .ST_CellFormulaTypeArray ;_dc ._cgd .F .Content =s ;
};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_cfgda Sheet )RangeReference (n string )string {_agda :=_bg .Split (n ,"\u003a");_abde ,_ :=_ggg .ParseCellReference (_agda [0]);_bbe :=_ae .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_abde .Column ,_abde .RowIdx );if len (_agda )==1{return _ae .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_cfgda .Name (),_bbe );
};_cdfg ,_ :=_ggg .ParseCellReference (_agda [1]);_feddd :=_ae .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_cdfg .Column ,_cdfg .RowIdx );return _ae .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_cfgda .Name (),_bbe ,_feddd );
};

// Reference returns the region of cells that are merged.
func (_agde MergedCell )Reference ()string {return _agde ._bge .RefAttr };

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};func (_bece StyleSheet )appendBorder ()Border {_edbd :=_ec .NewCT_Border ();_bece ._bdbbe .Borders .Border =append (_bece ._bdbbe .Borders .Border ,_edbd );_bece ._bdbbe .Borders .CountAttr =_b .Uint32 (uint32 (len (_bece ._bdbbe .Borders .Border )));
return Border {_edbd ,_bece ._bdbbe .Borders };};func (_cdb Cell )getFormat ()string {if _cdb ._cgd .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_ecf :=*_cdb ._cgd .SAttr ;_egd :=_cdb ._ggb .StyleSheet .GetCellStyle (_ecf );_dbc :=_cdb ._ggb .StyleSheet .GetNumberFormat (_egd .NumberFormat ());
return _dbc .GetFormat ();};

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_dgfb Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_gfcb :=[]Cell {};for _eabf :=uint32 (0);_eabf <=lastColIdx ;_eabf ++{_fcab :=_dgfb .Cell (_ggg .IndexToColumn (_eabf ));_gfcb =append (_gfcb ,_fcab );};return _gfcb ;};var _cdedd =[...]uint8 {0,18,37};
func _cad (_cff _fd .Time )_fd .Time {_cff =_cff .Local ();return _fd .Date (_cff .Year (),_cff .Month (),_cff .Day (),_cff .Hour (),_cff .Minute (),_cff .Second (),_cff .Nanosecond (),_fd .UTC );};

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_cbbfa *Workbook )AddImage (i _becg .Image )(_becg .ImageRef ,error ){_ffed :=_becg .MakeImageRef (i ,&_cbbfa .DocBase ,_cbbfa ._ggda );if i .Data ==nil &&i .Path ==""{return _ffed ,_da .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");
};if i .Format ==""{return _ffed ,_da .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _ffed ,_da .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");
};if i .Path !=""{_gggd :=_ga .Add (i .Path );if _gggd !=nil {return _ffed ,_gggd ;};};_cbbfa .Images =append (_cbbfa .Images ,_ffed );return _ffed ,nil ;};

// ClearAutoFilter removes the autofilters from the sheet.
func (_cadc *Sheet )ClearAutoFilter (){_cadc ._gfba .AutoFilter =nil ;_acgb :="\u0027"+_cadc .Name ()+"\u0027\u0021";for _ ,_bebe :=range _cadc ._dfgf .DefinedNames (){if _bebe .Name ()==_aeebd {if _bg .HasPrefix (_bebe .Content (),_acgb ){_cadc ._dfgf .RemoveDefinedName (_bebe );
break ;};};};};func (_acad DataValidationCompare )SetValue2 (v string ){_acad ._ccebd .Formula2 =&v };func (_geg Cell )getRawSortValue ()(string ,bool ){if _geg .HasFormula (){_fad :=_geg .GetCachedFormulaResult ();return _fad ,_db .IsNumber (_fad );};
_agc ,_ :=_geg .GetRawValue ();return _agc ,_db .IsNumber (_agc );};

// SetPriority sets the rule priority
func (_fadb ConditionalFormattingRule )SetPriority (p int32 ){_fadb ._gge .PriorityAttr =p };func _egda (_bcaag *Sheet )*evalContext {return &evalContext {_ddd :_bcaag ,_dbbb :make (map[string ]struct{})};};

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_aaba Sheet )Validate ()error {_gcec :=[]func ()error {_aaba .validateRowCellNumbers ,_aaba .validateMergedCells ,_aaba .validateSheetNames };for _ ,_dgdc :=range _gcec {if _aeg :=_dgdc ();_aeg !=nil {return _aeg ;};};if _adgdg :=_aaba ._gfba .Validate ();
_adgdg !=nil {return _adgdg ;};return _aaba ._gfba .Validate ();};func (_ggfcd *Workbook )onNewRelationship (_ecba *_ce .DecodeMap ,_faga ,_gggae string ,_gcagf []*_ad .File ,_fdccg *_dfb .Relationship ,_bacf _ce .Target )error {_cbfeg :=_b .DocTypeSpreadsheet ;
switch _gggae {case _b .OfficeDocumentType :_ggfcd ._fffe =_ec .NewWorkbook ();_ecba .AddTarget (_faga ,_ggfcd ._fffe ,_gggae ,0);_ggfcd ._ggda =_becg .NewRelationships ();_ecba .AddTarget (_ce .RelationsPathFor (_faga ),_ggfcd ._ggda .X (),_gggae ,0);
_fdccg .TargetAttr =_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,0);case _b .CorePropertiesType :_ecba .AddTarget (_faga ,_ggfcd .CoreProperties .X (),_gggae ,0);_fdccg .TargetAttr =_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,0);case _b .CustomPropertiesType :_ecba .AddTarget (_faga ,_ggfcd .CustomProperties .X (),_gggae ,0);
_fdccg .TargetAttr =_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,0);case _b .ExtendedPropertiesType :_ecba .AddTarget (_faga ,_ggfcd .AppProperties .X (),_gggae ,0);_fdccg .TargetAttr =_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,0);case _b .WorksheetType :_aacgc :=_ec .NewWorksheet ();
_gegfc ,_defga :=_dfgg .StringToNumbers (_faga );if !_defga {_gegfc =len (_ggfcd ._fggfc );};_ecba .AddTarget (_faga ,_aacgc ,_gggae ,uint32 (_gegfc ));_egecg :=_becg .NewRelationships ();_ecba .AddTarget (_ce .RelationsPathFor (_faga ),_egecg .X (),_gggae ,0);
_ggfcd ._ffdfe =append (_ggfcd ._ffdfe ,_egecg );_ggfcd ._eebg =append (_ggfcd ._eebg ,nil );_fdccg .TargetAttr =_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,_gegfc );if _ggfcd ._fffe .Sheets !=nil {if len (_ggfcd ._fggfc )< 1{_ggfcd ._fggfc =make ([]*_ec .Worksheet ,len (_ggfcd ._fffe .Sheets .Sheet ));
};for _cggb ,_adgc :=range _ggfcd ._fffe .Sheets .Sheet {if _adgc .IdAttr ==_fdccg .IdAttr {_ggfcd ._fggfc [_cggb ]=_aacgc ;};};}else {_ggfcd ._fggfc =append (_ggfcd ._fggfc ,_aacgc );};case _b .StylesType :_ggfcd .StyleSheet =NewStyleSheet (_ggfcd );_ecba .AddTarget (_faga ,_ggfcd .StyleSheet .X (),_gggae ,0);
_fdccg .TargetAttr =_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,0);case _b .ThemeType :_fggb :=_ed .NewTheme ();_ggfcd ._edcgg =append (_ggfcd ._edcgg ,_fggb );_ecba .AddTarget (_faga ,_fggb ,_gggae ,0);_fdccg .TargetAttr =_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,len (_ggfcd ._edcgg ));
case _b .SharedStringsType :_ggfcd .SharedStrings =NewSharedStrings ();_ecba .AddTarget (_faga ,_ggfcd .SharedStrings .X (),_gggae ,0);_fdccg .TargetAttr =_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,0);case _b .ThumbnailType :for _fbgg ,_eedf :=range _gcagf {if _eedf ==nil {continue ;
};if _eedf .Name ==_faga {_cbbgd ,_dgdca :=_eedf .Open ();if _dgdca !=nil {return _ae .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_dgdca );};_ggfcd .Thumbnail ,_ ,_dgdca =_d .Decode (_cbbgd );
_cbbgd .Close ();if _dgdca !=nil {return _ae .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_dgdca );};_gcagf [_fbgg ]=nil ;};};case _b .ImageType :for _bfcga ,_aaeb :=range _ggfcd ._bae {_efad :=_f .Clean (_faga );
if _efad ==_bfcga {_fdccg .TargetAttr =_aaeb ;return nil ;};};_aedg :=_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,len (_ggfcd .Images )+1);for _ffce ,_bcgba :=range _gcagf {if _bcgba ==nil {continue ;};if _bcgba .Name ==_f .Clean (_faga ){_beec ,_fdbc :=_ce .ExtractToDiskTmp (_bcgba ,_ggfcd .TmpPath );
if _fdbc !=nil {return _fdbc ;};_dgge ,_fdbc :=_becg .ImageFromStorage (_beec );if _fdbc !=nil {return _fdbc ;};_aeae :=_becg .MakeImageRef (_dgge ,&_ggfcd .DocBase ,_ggfcd ._ggda );_aeae .SetTarget (_aedg );_ggfcd ._bae [_bcgba .Name ]=_aedg ;_ggfcd .Images =append (_ggfcd .Images ,_aeae );
_gcagf [_ffce ]=nil ;};};_fdccg .TargetAttr =_aedg ;case _b .DrawingType :_fbdcc :=_eeg .NewWsDr ();_bdfb :=uint32 (len (_ggfcd ._ggfge ));_ecba .AddTarget (_faga ,_fbdcc ,_gggae ,_bdfb );_ggfcd ._ggfge =append (_ggfcd ._ggfge ,_fbdcc );_eccc :=_becg .NewRelationships ();
_ecba .AddTarget (_ce .RelationsPathFor (_faga ),_eccc .X (),_gggae ,_bdfb );_ggfcd ._aaae =append (_ggfcd ._aaae ,_eccc );_fdccg .TargetAttr =_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,len (_ggfcd ._ggfge ));case _b .VMLDrawingType :_becdg :=_bc .NewContainer ();
_fegcc :=uint32 (len (_ggfcd ._cedfa ));_ecba .AddTarget (_faga ,_becdg ,_gggae ,_fegcc );_ggfcd ._cedfa =append (_ggfcd ._cedfa ,_becdg );case _b .CommentsType :_ggfcd ._eebg [_bacf .Index ]=_ec .NewComments ();_ecba .AddTarget (_faga ,_ggfcd ._eebg [_bacf .Index ],_gggae ,_bacf .Index );
_fdccg .TargetAttr =_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,len (_ggfcd ._eebg ));case _b .ChartType :_cacf :=_ff .NewChartSpace ();_agb :=uint32 (len (_ggfcd ._gggb ));_ecba .AddTarget (_faga ,_cacf ,_gggae ,_agb );_ggfcd ._gggb =append (_ggfcd ._gggb ,_cacf );
_fdccg .TargetAttr =_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,len (_ggfcd ._gggb ));if _ggfcd ._bbdd ==nil {_ggfcd ._bbdd =make (map[string ]*_ff .ChartSpace );};_ggfcd ._bbdd [_fdccg .TargetAttr ]=_cacf ;case _b .TableType :_fga :=_ec .NewTable ();
_afc :=uint32 (len (_ggfcd ._bbcff ));_ecba .AddTarget (_faga ,_fga ,_gggae ,_afc );_ggfcd ._bbcff =append (_ggfcd ._bbcff ,_fga );_fdccg .TargetAttr =_b .RelativeFilename (_cbfeg ,_bacf .Typ ,_gggae ,len (_ggfcd ._bbcff ));default:_de .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_faga ,_gggae );
};return nil ;};

// RemoveDefinedName removes an existing defined name.
func (_caba *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _da .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");
};for _dbcb ,_aded :=range _caba ._fffe .DefinedNames .DefinedName {if _aded ==dn .X (){copy (_caba ._fffe .DefinedNames .DefinedName [_dbcb :],_caba ._fffe .DefinedNames .DefinedName [_dbcb +1:]);_caba ._fffe .DefinedNames .DefinedName [len (_caba ._fffe .DefinedNames .DefinedName )-1]=nil ;
_caba ._fffe .DefinedNames .DefinedName =_caba ._fffe .DefinedNames .DefinedName [:len (_caba ._fffe .DefinedNames .DefinedName )-1];return nil ;};};return _da .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");
};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_feabg Sheet )ValidateWithPath (path string )error {return _feabg ._gfba .ValidateWithPath (path )};

// SetItalic causes the text to be displayed in italic.
func (_gfb RichTextRun )SetItalic (b bool ){_gfb .ensureRpr ();_gfb ._fedg .RPr .I =_ec .NewCT_BooleanProperty ();_gfb ._fedg .RPr .I .ValAttr =_b .Bool (b );};

// ExtractText returns text from the workbook as a WorkbookText object.
func (_cfdd *Workbook )ExtractText ()*WorkbookText {_dgdb :=[]*SheetText {};for _ ,_gced :=range _cfdd .Sheets (){_dgdb =append (_dgdb ,&SheetText {Cells :_gced .ExtractText ().Cells });};return &WorkbookText {Sheets :_dgdb };};func (_bbaa Comments )getOrCreateAuthor (_gcee string )uint32 {for _daae ,_ddee :=range _bbaa ._bfe .Authors .Author {if _ddee ==_gcee {return uint32 (_daae );
};};_dca :=uint32 (len (_bbaa ._bfe .Authors .Author ));_bbaa ._bfe .Authors .Author =append (_bbaa ._bfe .Authors .Author ,_gcee );return _dca ;};

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_edcf *Workbook )RemoveSheetByName (name string )error {_faedd :=-1;for _acfgf ,_eff :=range _edcf .Sheets (){if name ==_eff .Name (){_faedd =_acfgf ;break ;};};if _faedd ==-1{return ErrorNotFound ;};return _edcf .RemoveSheet (_faedd );};var _fefe =_b .RelativeFilename (_b .DocTypeSpreadsheet ,_b .OfficeDocumentType ,_b .SharedStringsType ,0);


// SetNumberFormat applies a number format to a cell style avoiding redundancy. The function checks if the given string
// already exists in the saved number formats. If found, the existing number format is reused; otherwise,
// the new number format is added to the saved number formats collection. The number format is then applied to the cell style,
// affecting all styles that reference it by index.
func (_fcg CellStyle )SetNumberFormat (s string ){var _gca NumberFormat ;if _fcg ._gad .StyleSheet ._bdbbe .NumFmts ==nil {_fcg ._gad .StyleSheet ._bdbbe .NumFmts =_ec .NewCT_NumFmts ();};_dgf :=_fcg ._gad .StyleSheet ._bdbbe .NumFmts .NumFmt ;for _ ,_ffd :=range _dgf {if _dfg .DeepEqual (_ffd .FormatCodeAttr ,s ){_gca =NumberFormat {_fcg ._gad ,_ffd };
_fcg ._gdcd .ApplyNumberFormatAttr =_b .Bool (true );_fcg ._gdcd .NumFmtIdAttr =_b .Uint32 (_gca .ID ());return ;};};_eba :=_ec .NewCT_NumFmt ();_eba .NumFmtIdAttr =uint32 (200+len (_fcg ._gad .StyleSheet ._bdbbe .NumFmts .NumFmt ));_fcg ._gad .StyleSheet ._bdbbe .NumFmts .NumFmt =append (_fcg ._gad .StyleSheet ._bdbbe .NumFmts .NumFmt ,_eba );
_fcg ._gad .StyleSheet ._bdbbe .NumFmts .CountAttr =_b .Uint32 (uint32 (len (_fcg ._gad .StyleSheet ._bdbbe .NumFmts .NumFmt )));_gca =NumberFormat {_fcg ._gad ,_eba };_gca ._ggd .FormatCodeAttr =s ;_fcg ._gdcd .ApplyNumberFormatAttr =_b .Bool (true );
_fcg ._gdcd .NumFmtIdAttr =_b .Uint32 (_gca .ID ());};

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_ebcg TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_ebcg ._gecda .From }};func (_acac RichTextRun )ensureRpr (){if _acac ._fedg .RPr ==nil {_acac ._fedg .RPr =_ec .NewCT_RPrElt ();};};

// X returns the inner wrapped XML type.
func (_ffgf WorkbookProtection )X ()*_ec .CT_WorkbookProtection {return _ffgf ._bdbc };

// AddCellStyle creates a new empty cell style.
func (_bcgec StyleSheet )AddCellStyle ()CellStyle {_gecdf :=_ec .NewCT_Xf ();return CellStyle {_bcgec ._eecc ,_gecdf ,_bcgec ._bdbbe .CellXfs };};

// SetRotation configures the cell to be rotated.
func (_feca CellStyle )SetRotation (deg uint8 ){if _feca ._gdcd .Alignment ==nil {_feca ._gdcd .Alignment =_ec .NewCT_CellAlignment ();};_feca ._gdcd .ApplyAlignmentAttr =_b .Bool (true );_feca ._gdcd .Alignment .TextRotationAttr =_b .Uint8 (deg );};

// SetReference sets the regin of cells that the merged cell applies to.
func (_edgf MergedCell )SetReference (ref string ){_edgf ._bge .RefAttr =ref };

// X returns the inner wrapped XML type.
func (_deb ConditionalFormattingRule )X ()*_ec .CT_CfRule {return _deb ._gge };

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_cec Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_cec .SetNumber (v );_cec .SetStyle (_cec ._ggb .StyleSheet .GetOrCreateStandardNumberFormat (f ));};

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_dbda *Workbook )Close ()error {if _dbda .TmpPath !=""{return _ga .RemoveAll (_dbda .TmpPath );};return nil ;};

// SetHidden marks the defined name as hidden.
func (_fbfa DefinedName )SetHidden (b bool ){_fbfa ._efeb .HiddenAttr =_b .Bool (b )};type Table struct{_ggacd *_ec .Table };

// SetRowOffset sets the row offset of the two cell anchor
func (_fbfge TwoCellAnchor )SetRowOffset (m _bd .Distance ){_deeg :=m -_fbfge .TopLeft ().RowOffset ();_fbfge .TopLeft ().SetRowOffset (m );_fbfge .BottomRight ().SetRowOffset (_fbfge .BottomRight ().RowOffset ()+_deeg );};

// AddBorder creates a new empty Border style.
func (_fbba StyleSheet )AddBorder ()Border {_cef :=_ec .NewCT_Border ();return Border {_cef ,_fbba ._bdbbe .Borders };};

// MoveTo moves the top-left of the anchored object.
func (_gaa OneCellAnchor )MoveTo (col ,row int32 ){_gaa .TopLeft ().SetCol (col );_gaa .TopLeft ().SetRow (row );};

// Comment is a single comment within a sheet.
type Comment struct{_eaa *Workbook ;_fecad *_ec .CT_Comment ;_cced *_ec .Comments ;};

// X returns the inner wrapped XML type.
func (_dad DataBarScale )X ()*_ec .CT_DataBar {return _dad ._begc };

// X returns the inner wrapped XML type.
func (_fcb ConditionalFormatting )X ()*_ec .CT_ConditionalFormatting {return _fcb ._egg };

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_aagd Comment )SetAuthor (author string ){_aagd ._fecad .AuthorIdAttr =Comments {_aagd ._eaa ,_aagd ._cced }.getOrCreateAuthor (author );};

// X returns the inner wrapped XML type.
func (_ddbe Row )X ()*_ec .CT_Row {return _ddbe ._ccaa };

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_bed IconScale )AddFormatValue (t _ec .ST_CfvoType ,val string ){_fdgd :=_ec .NewCT_Cfvo ();_fdgd .TypeAttr =t ;_fdgd .ValAttr =_b .String (val );_bed ._dce .Cfvo =append (_bed ._dce .Cfvo ,_fdgd );};

// SetYSplit sets the row split point
func (_aadg SheetView )SetYSplit (v float64 ){_aadg .ensurePane ();_aadg ._dgeg .Pane .YSplitAttr =_b .Float64 (v );};

// X returns the inner wrapped XML type.
func (_acc NumberFormat )X ()*_ec .CT_NumFmt {return _acc ._ggd };

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_cg *_eeg .CT_AbsoluteAnchor };

// RemoveSheet removes the sheet with the given index from the workbook.
func (_decdg *Workbook )RemoveSheet (ind int )error {if _decdg .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_dabgc :=range _decdg ._ggda .Relationships (){if _dabgc .ID ()==_decdg ._fffe .Sheets .Sheet [ind ].IdAttr {_decdg ._ggda .Remove (_dabgc );
break ;};};_decdg .ContentTypes .RemoveOverride (_b .AbsoluteFilename (_b .DocTypeSpreadsheet ,_b .WorksheetContentType ,ind +1));copy (_decdg ._fggfc [ind :],_decdg ._fggfc [ind +1:]);_decdg ._fggfc =_decdg ._fggfc [:len (_decdg ._fggfc )-1];_dcfb :=_decdg ._fffe .Sheets .Sheet [ind ];
copy (_decdg ._fffe .Sheets .Sheet [ind :],_decdg ._fffe .Sheets .Sheet [ind +1:]);_decdg ._fffe .Sheets .Sheet =_decdg ._fffe .Sheets .Sheet [:len (_decdg ._fffe .Sheets .Sheet )-1];for _fba :=range _decdg ._fffe .Sheets .Sheet {if _decdg ._fffe .Sheets .Sheet [_fba ].SheetIdAttr > _dcfb .SheetIdAttr {_decdg ._fffe .Sheets .Sheet [_fba ].SheetIdAttr --;
};};copy (_decdg ._ffdfe [ind :],_decdg ._ffdfe [ind +1:]);_decdg ._ffdfe =_decdg ._ffdfe [:len (_decdg ._ffdfe )-1];copy (_decdg ._eebg [ind :],_decdg ._eebg [ind +1:]);_decdg ._eebg =_decdg ._eebg [:len (_decdg ._eebg )-1];return nil ;};func (_gcf PatternFill )ClearFgColor (){_gcf ._febg .FgColor =nil };
func (_cfaa StyleSheet )GetCellStyle (id uint32 )CellStyle {for _ddafg ,_dfbcb :=range _cfaa ._bdbbe .CellXfs .Xf {if uint32 (_ddafg )==id {return CellStyle {_cfaa ._eecc ,_dfbcb ,_cfaa ._bdbbe .CellXfs };};};return CellStyle {};};

// GetFormula returns the formula for a cell.
func (_fbgb Cell )GetFormula ()string {if _fbgb ._cgd .F !=nil {return _fbgb ._cgd .F .Content ;};return "";};

// X returns the inner wrapped XML type.
func (_gade *Workbook )X ()*_ec .Workbook {return _gade ._fffe };func (_dcc Font )SetSize (size float64 ){_dcc ._aagc .Sz =[]*_ec .CT_FontSize {{ValAttr :size }}};

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_gbfa StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _gbfa ._bdbbe .Dxfs ==nil {_gbfa ._bdbbe .Dxfs =_ec .NewCT_Dxfs ();};_bedc :=_ec .NewCT_Dxf ();_gbfa ._bdbbe .Dxfs .Dxf =append (_gbfa ._bdbbe .Dxfs .Dxf ,_bedc );_gbfa ._bdbbe .Dxfs .CountAttr =_b .Uint32 (uint32 (len (_gbfa ._bdbbe .Dxfs .Dxf )));
return DifferentialStyle {_bedc ,_gbfa ._eecc ,_gbfa ._bdbbe .Dxfs };};func (_cded SheetView )ensurePane (){if _cded ._dgeg .Pane ==nil {_cded ._dgeg .Pane =_ec .NewCT_Pane ();_cded ._dgeg .Pane .ActivePaneAttr =_ec .ST_PaneBottomLeft ;};};func (_acaa Font )SetItalic (b bool ){if b {_acaa ._aagc .I =[]*_ec .CT_BooleanProperty {{}};
}else {_acaa ._aagc .I =nil ;};};type Fills struct{_dag *_ec .CT_Fills };

// ClearProtection removes any protections applied to teh sheet.
func (_fegc *Sheet )ClearProtection (){_fegc ._gfba .SheetProtection =nil };func (_ebb *evalContext )Sheet (name string )_bec .Context {for _ ,_fafd :=range _ebb ._ddd ._dfgf .Sheets (){if _fafd .Name ()==name {return _fafd .FormulaContext ();};};return _bec .InvalidReferenceContext ;
};

// SetContent sets the defined name content.
func (_ecb DefinedName )SetContent (s string ){_ecb ._efeb .Content =s };

// GetWidth returns a worksheet's column width.
func (_fgc *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_gdbd :=range _fgc ._ddd .X ().Cols [0].Col {if int (_gdbd .MinAttr )<=colIdx &&colIdx <=int (_gdbd .MaxAttr ){return float64 (int (*_gdbd .WidthAttr ));};};return 0;};

// SetColor sets the text color.
func (_cbac RichTextRun )SetColor (c _gd .Color ){_cbac .ensureRpr ();_cbac ._fedg .RPr .Color =_ec .NewCT_Color ();_ecgc :="\u0066\u0066"+*c .AsRGBString ();_cbac ._fedg .RPr .Color .RgbAttr =&_ecgc ;};

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_adgb Cell )GetValueAsTime ()(_fd .Time ,error ){if _adgb ._cgd .TAttr !=_ec .ST_CellTypeUnset {return _fd .Time {},_da .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");
};if _adgb ._cgd .V ==nil {return _fd .Time {},_da .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_gafa ,_ ,_fg :=_dfd .ParseFloat (*_adgb ._cgd .V ,10,128,_dfd .ToNearestEven );if _fg !=nil {return _fd .Time {},_fg ;
};_afb :=new (_dfd .Float );_afb .SetUint64 (uint64 (24*_fd .Hour ));_gafa .Mul (_gafa ,_afb );_fbd ,_ :=_gafa .Uint64 ();_fec :=_adgb ._ggb .Epoch ().Add (_fd .Duration (_fbd ));return _gec (_fec ),nil ;};

// SheetText is an array of extracted text items which has some methods for representing extracted text from a sheet.
type SheetText struct{Cells []CellText ;};

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_fcaf *Workbook ;_ggd *_ec .CT_NumFmt ;};

// SetBold causes the text to be displayed in bold.
func (_gbec RichTextRun )SetBold (b bool ){_gbec .ensureRpr ();_gbec ._fedg .RPr .B =_ec .NewCT_BooleanProperty ();_gbec ._fedg .RPr .B .ValAttr =_b .Bool (b );};

// TopLeft is a no-op.
func (_cb AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};const _ecdd ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";


// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_beca Comments )AddComment (cellRef string ,author string )RichText {_gadb :=_ec .NewCT_Comment ();_beca ._bfe .CommentList .Comment =append (_beca ._bfe .CommentList .Comment ,_gadb );_gadb .RefAttr =cellRef ;_gadb .AuthorIdAttr =_beca .getOrCreateAuthor (author );
_gadb .Text =_ec .NewCT_Rst ();return RichText {_gadb .Text };};var _ddcf *_af .Regexp =_af .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");

// LockObject controls the locking of the sheet objects.
func (_aaeg SheetProtection )LockObject (b bool ){if !b {_aaeg ._dabg .ObjectsAttr =nil ;}else {_aaeg ._dabg .ObjectsAttr =_b .Bool (true );};};

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_gbfb StyleSheet )Fills ()Fills {return Fills {_gbfb ._bdbbe .Fills }};

// SetShowRuler controls the visibility of the ruler
func (_fafdf SheetView )SetShowRuler (b bool ){if !b {_fafdf ._dgeg .ShowRulerAttr =_b .Bool (false );}else {_fafdf ._dgeg .ShowRulerAttr =nil ;};};

// AddRun adds a new run of text to the cell.
func (_efgdf RichText )AddRun ()RichTextRun {_dgb :=_ec .NewCT_RElt ();_efgdf ._afef .R =append (_efgdf ._afef .R ,_dgb );return RichTextRun {_dgb };};func _gbg (_fcdc bool )int {if _fcdc {return 1;};return 0;};

// X returns the inner wrapped XML type.
func (_ecgee SheetView )X ()*_ec .CT_SheetView {return _ecgee ._dgeg };

// IsSheetLocked returns whether the sheet objects are locked.
func (_ebeb SheetProtection )IsObjectLocked ()bool {return _ebeb ._dabg .ObjectsAttr !=nil &&*_ebeb ._dabg .ObjectsAttr ;};

// SetHeightCells is a no-op.
func (_ca AbsoluteAnchor )SetHeightCells (int32 ){};func (_faae *Sheet )removeColumnFromMergedCells (_aacg uint32 )error {if _faae ._gfba .MergeCells ==nil ||_faae ._gfba .MergeCells .MergeCell ==nil {return nil ;};_efbab :=[]*_ec .CT_MergeCell {};for _ ,_cbfge :=range _faae .MergedCells (){_fbbg :=_dfae (_cbfge .Reference (),_aacg ,true );
if _fbbg !=""{_cbfge .SetReference (_fbbg );_efbab =append (_efbab ,_cbfge .X ());};};_faae ._gfba .MergeCells .MergeCell =_efbab ;return nil ;};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_dfbd ,_ecfe :=_df .Open (filename );if _ecfe !=nil {return nil ,_ae .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_ecfe );};defer _dfbd .Close ();
_dgca ,_ecfe :=_df .Stat (filename );if _ecfe !=nil {return nil ,_ae .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_ecfe );};_dega ,_ecfe :=Read (_dfbd ,_dgca .Size ());if _ecfe !=nil {return nil ,_ecfe ;
};_fabd ,_ :=_ac .Abs (_ac .Dir (filename ));_dega ._cage =_ac .Join (_fabd ,filename );return _dega ,nil ;};

// MoveTo repositions the anchor without changing the objects size.
func (_aadbe TwoCellAnchor )MoveTo (col ,row int32 ){_eadc :=_aadbe .TopLeft ();_dcfe :=_aadbe .BottomRight ();_fffc :=_dcfe .Col ()-_eadc .Col ();_edeg :=_dcfe .Row ()-_eadc .Row ();_eadc .SetCol (col );_eadc .SetRow (row );_dcfe .SetCol (col +_fffc );
_dcfe .SetRow (row +_edeg );};

// SetWidthCells is a no-op.
func (_ggga AbsoluteAnchor )SetWidthCells (int32 ){};

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_affb NumberFormat )ID ()uint32 {return _affb ._ggd .NumFmtIdAttr };type Fill struct{_fcc *_ec .CT_Fill ;_fdfc *_ec .CT_Fills ;};func _gafbb ()*_eeg .CT_AbsoluteAnchor {_agdc :=_eeg .NewCT_AbsoluteAnchor ();return _agdc };

// Text returns text from the workbook as one string separated with line breaks.
func (_gedd *WorkbookText )Text ()string {_gdcc :=_c .NewBuffer ([]byte {});for _ ,_cacd :=range _gedd .Sheets {_gdcc .WriteString (_cacd .Text ());};return _gdcc .String ();};

// Rows returns all of the rows in a sheet.
func (_bcb *Sheet )Rows ()[]Row {_adef :=[]Row {};for _ ,_fade :=range _bcb ._gfba .SheetData .Row {_adef =append (_adef ,Row {_bcb ._dfgf ,_bcb ,_fade });};return _adef ;};

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_daf Row )Cell (col string )Cell {_gcda :=_ae .Sprintf ("\u0025\u0073\u0025\u0064",col ,_daf .RowNumber ());for _ ,_aaab :=range _daf ._ccaa .C {if _aaab .RAttr !=nil &&*_aaab .RAttr ==_gcda {return Cell {_daf ._cfddf ,_daf ._aaca ,_daf ._ccaa ,_aaab };
};};return _daf .AddNamedCell (col );};

// Cell is a single cell within a sheet.
type Cell struct{_ggb *Workbook ;_bdd *Sheet ;_dbf *_ec .CT_Row ;_cgd *_ec .CT_Cell ;};

// AddFormatValue adds a format value (databars require two).
func (_fca DataBarScale )AddFormatValue (t _ec .ST_CfvoType ,val string ){_aefa :=_ec .NewCT_Cfvo ();_aefa .TypeAttr =t ;_aefa .ValAttr =_b .String (val );_fca ._begc .Cfvo =append (_fca ._begc .Cfvo ,_aefa );};

// X returns the inner XML entity for a stylesheet.
func (_fcce StyleSheet )X ()*_ec .StyleSheet {return _fcce ._bdbbe };