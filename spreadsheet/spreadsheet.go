//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_ee "archive/zip";_g "bytes";_cda "errors";_d "fmt";_f "github.com/unidoc/unioffice";_cgc "github.com/unidoc/unioffice/chart";_de "github.com/unidoc/unioffice/color";_fg "github.com/unidoc/unioffice/common";_db "github.com/unidoc/unioffice/common/logger";
_fdg "github.com/unidoc/unioffice/common/tempstorage";_dc "github.com/unidoc/unioffice/internal/formatutils";_fd "github.com/unidoc/unioffice/internal/license";_ad "github.com/unidoc/unioffice/measurement";_gbb "github.com/unidoc/unioffice/schema/soo/dml";
_bb "github.com/unidoc/unioffice/schema/soo/dml/chart";_ac "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing";_gf "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_bf "github.com/unidoc/unioffice/schema/soo/sml";_eda "github.com/unidoc/unioffice/spreadsheet/format";
_ca "github.com/unidoc/unioffice/spreadsheet/formula";_dg "github.com/unidoc/unioffice/spreadsheet/reference";_cf "github.com/unidoc/unioffice/spreadsheet/update";_ce "github.com/unidoc/unioffice/vmldrawing";_gb "github.com/unidoc/unioffice/zippkg";_b "image";
_c "image/jpeg";_cc "io";_eg "math";_fa "math/big";_ed "os";_e "path";_bd "path/filepath";_cgg "reflect";_eb "regexp";_cd "sort";_ff "strconv";_cb "strings";_cg "time";);

// SetAllowBlank controls if blank values are accepted.
func (_fcaf DataValidation )SetAllowBlank (b bool ){if !b {_fcaf ._aabc .AllowBlankAttr =nil ;}else {_fcaf ._aabc .AllowBlankAttr =_f .Bool (true );};};var _acc *_eb .Regexp =_eb .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");


// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_dacdd *Workbook )RecalculateFormulas (){for _ ,_ffge :=range _dacdd .Sheets (){_ffge .RecalculateFormulas ();};};var _dcdag =_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,_f .SharedStringsType ,0);type WorkbookProtection struct{_afbb *_bf .CT_WorkbookProtection };


// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_bdgf *Workbook )Uses1904Dates ()bool {if _bdgf ._gceg .WorkbookPr ==nil ||_bdgf ._gceg .WorkbookPr .Date1904Attr ==nil {return false ;};return *_bdgf ._gceg .WorkbookPr .Date1904Attr ;};

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_beb Cell )SetBool (v bool ){_beb .clearValue ();_beb ._faa .V =_f .String (_ff .Itoa (_dcd (v )));_beb ._faa .TAttr =_bf .ST_CellTypeB ;};

// SetStyle sets the style to be used for conditional rules
func (_cfb ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_cfb ._aecc .DxfIdAttr =_f .Uint32 (d .Index ());};

// SetItalic causes the text to be displayed in italic.
func (_gcee RichTextRun )SetItalic (b bool ){_gcee .ensureRpr ();_gcee ._ded .RPr .I =_bf .NewCT_BooleanProperty ();_gcee ._ded .RPr .I .ValAttr =_f .Bool (b );};

// Content returns the content of the defined range (the range in most cases)/
func (_cff DefinedName )Content ()string {return _cff ._dcce .Content };func (_affg Fills )appendFill ()Fill {_cfdec :=_bf .NewCT_Fill ();_affg ._dccc .Fill =append (_affg ._dccc .Fill ,_cfdec );_affg ._dccc .CountAttr =_f .Uint32 (uint32 (len (_affg ._dccc .Fill )));
return Fill {_cfdec ,_affg ._dccc };};

// IsEmpty returns true if the cell is empty.
func (_ccb Cell )IsEmpty ()bool {return _ccb ._faa .TAttr ==_bf .ST_CellTypeUnset &&_ccb ._faa .V ==nil &&_ccb ._faa .F ==nil ;};func _bbfc ()*_ac .CT_OneCellAnchor {_gbbf :=_ac .NewCT_OneCellAnchor ();return _gbbf };

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_bf .Comments )Comments {return Comments {w ,x }};

// GetFormula returns the formula for a cell.
func (_bca Cell )GetFormula ()string {if _bca ._faa .F !=nil {return _bca ._faa .F .Content ;};return "";};const (DVCompareOpEqual =DVCompareOp (_bf .ST_DataValidationOperatorEqual );DVCompareOpBetween =DVCompareOp (_bf .ST_DataValidationOperatorBetween );
DVCompareOpNotBetween =DVCompareOp (_bf .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_bf .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_bf .ST_DataValidationOperatorGreaterThan );DVCompareOpGreaterEqual =DVCompareOp (_bf .ST_DataValidationOperatorGreaterThanOrEqual );
DVCompareOpLess =DVCompareOp (_bf .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_bf .ST_DataValidationOperatorLessThanOrEqual ););

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_gdfd *_bf .CT_Col };func (_fbf Cell )getRawSortValue ()(string ,bool ){if _fbf .HasFormula (){_ebd :=_fbf .GetCachedFormulaResult ();return _ebd ,_eda .IsNumber (_ebd );};_ecf ,_ :=_fbf .GetRawValue ();return _ecf ,_eda .IsNumber (_ecf );
};func (_dbeb DataValidation )clear (){_dbeb ._aabc .Formula1 =_f .String ("\u0030");_dbeb ._aabc .Formula2 =_f .String ("\u0030");};

// Type returns the type of anchor
func (_feeg OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };

// SetBorder applies a border to a cell style avoiding redundancy. The function checks if the given border
// already exists in the saved borders. If found, the existing border is reused; otherwise,
// the new border is added to the saved borders collection. The border is then applied to the cell style,
// affecting all styles that reference it by index.
func (_caf CellStyle )SetBorder (b Border ){_gbdd :=b ._dgb .Border ;for _ ,_feba :=range _gbdd {if _cgg .DeepEqual (_feba ,b ._bee ){b ._bee =_feba ;_caf ._cag .BorderIdAttr =_f .Uint32 (b .Index ());_caf ._cag .ApplyBorderAttr =_f .Bool (true );return ;
};};b ._dgb .Border =append (b ._dgb .Border ,b ._bee );b ._dgb .CountAttr =_f .Uint32 (uint32 (len (b ._dgb .Border )));_caf ._cag .BorderIdAttr =_f .Uint32 (b .Index ());_caf ._cag .ApplyBorderAttr =_f .Bool (true );};

// GetFormat sets the number format code.
func (_cdabb NumberFormat )GetFormat ()string {return _cdabb ._badc .FormatCodeAttr };func (_ecd Cell )getFormat ()string {if _ecd ._faa .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_acf :=*_ecd ._faa .SAttr ;_fad :=_ecd ._aef .StyleSheet .GetCellStyle (_acf );
_ea :=_ecd ._aef .StyleSheet .GetNumberFormat (_fad .NumberFormat ());return _ea .GetFormat ();};

// ClearFill clears any fill configuration from the cell style.
func (_faff CellStyle )ClearFill (){_faff ._cag .FillIdAttr =nil ;_faff ._cag .ApplyFillAttr =nil };

// SetContent sets the defined name content.
func (_dgg DefinedName )SetContent (s string ){_dgg ._dcce .Content =s };

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_ebba Row )Cells ()[]Cell {_baf :=[]Cell {};_gggf :=-1;_aggd :=append ([]*_bf .CT_Cell {},_ebba ._bgb .C ...);for _ ,_fcad :=range _aggd {if _fcad .RAttr ==nil {_db .Log .Debug ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
continue ;};_ccfe ,_adde :=_dg .ParseCellReference (*_fcad .RAttr );if _adde !=nil {_db .Log .Debug ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_fcad .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
continue ;};_dge :=int (_ccfe .ColumnIdx );if _dge -_gggf > 1{for _cdbca :=_gggf +1;_cdbca < _dge ;_cdbca ++{_baf =append (_baf ,_ebba .Cell (_dg .IndexToColumn (uint32 (_cdbca ))));};};_gggf =_dge ;_baf =append (_baf ,Cell {_ebba ._gdc ,_ebba ._ade ,_ebba ._bgb ,_fcad });
};return _baf ;};

// GetBorder gets a Border from a cell style.
func (_ecfb CellStyle )GetBorder ()*_bf .CT_Border {if _def :=_ecfb ._cag .BorderIdAttr ;_def !=nil {_cacb :=_ecfb ._dd .StyleSheet .Borders ();if int (*_def )< len (_cacb ){return _cacb [int (*_def )].X ();};};return nil ;};

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_caa Cell )SetFormulaArray (s string ){_ec :=_ca .ParseString (s );if _ec ==nil {return ;};_caa .clearValue ();_caa ._faa .TAttr =_bf .ST_CellTypeStr ;_caa ._faa .F =_bf .NewCT_CellFormula ();_caa ._faa .F .TAttr =_bf .ST_CellFormulaTypeArray ;_caa ._faa .F .Content =s ;
};func (_cbg Cell )setLocked (_cde bool ){_egda :=_cbg ._faa .SAttr ;if _egda !=nil {_dac :=_cbg ._aef .StyleSheet .GetCellStyle (*_egda );if _dac ._cag .Protection ==nil {_dac ._cag .Protection =_bf .NewCT_CellProtection ();};_dac ._cag .Protection .LockedAttr =&_cde ;
};};func (_gcb DifferentialStyle )Fill ()Fill {if _gcb ._fgc .Fill ==nil {_gcb ._fgc .Fill =_bf .NewCT_Fill ();};return Fill {_gcb ._fgc .Fill ,nil };};

// BottomRight is a no-op.
func (_ccfd OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};

// ClearProtection removes any protections applied to teh sheet.
func (_eaae *Sheet )ClearProtection (){_eaae ._gfae .SheetProtection =nil };func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_ege :=NumberFormat {_badc :_bf .NewCT_NumFmt ()};_ege ._badc .NumFmtIdAttr =uint32 (id );_ege ._badc .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";
switch id {case StandardFormat0 :_ege ._badc .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_ege ._badc .FormatCodeAttr ="\u0030";case StandardFormat2 :_ege ._badc .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_ege ._badc .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";
case StandardFormat4 :_ege ._badc .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";case StandardFormat9 :_ege ._badc .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_ege ._badc .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_ege ._badc .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";
case StandardFormat12 :_ege ._badc .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_ege ._badc .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_ege ._badc .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";
case StandardFormat15 :_ege ._badc .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_ege ._badc .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_ege ._badc .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";
case StandardFormat18 :_ege ._badc .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_ege ._badc .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_ege ._badc .FormatCodeAttr ="\u0068\u003a\u006d\u006d";
case StandardFormat21 :_ege ._badc .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_ege ._badc .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_ege ._badc .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";
case StandardFormat38 :_ege ._badc .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_ege ._badc .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";
case StandardFormat40 :_ege ._badc .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_ege ._badc .FormatCodeAttr ="\u006d\u006d\u003as\u0073";
case StandardFormat46 :_ege ._badc .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_ege ._badc .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_ege ._badc .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";
case StandardFormat49 :_ege ._badc .FormatCodeAttr ="\u0040";};return _ege ;};

// SetHeightCells is a no-op.
func (_be AbsoluteAnchor )SetHeightCells (int32 ){};

// HasNumberFormat returns true if the cell style has a number format applied.
func (_bdab CellStyle )HasNumberFormat ()bool {return _bdab ._cag .NumFmtIdAttr !=nil &&_bdab ._cag .ApplyNumberFormatAttr !=nil &&*_bdab ._cag .ApplyNumberFormatAttr ;};

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_ebcg *Workbook )RemoveCalcChain (){var _gebgc string ;for _ ,_fbafb :=range _ebcg ._dfbgc .Relationships (){if _fbafb .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_gebgc ="\u0078\u006c\u002f"+_fbafb .Target ();
_ebcg ._dfbgc .Remove (_fbafb );break ;};};if _gebgc ==""{return ;};_ebcg .ContentTypes .RemoveOverride (_gebgc );for _eaab ,_gggb :=range _ebcg .ExtraFiles {if _gggb .ZipPath ==_gebgc {_ebcg .ExtraFiles [_eaab ]=_ebcg .ExtraFiles [len (_ebcg .ExtraFiles )-1];
_ebcg .ExtraFiles =_ebcg .ExtraFiles [:len (_ebcg .ExtraFiles )-1];return ;};};};

// GetChartByTargetId returns the array of workbook crt.ChartSpace.
func (_cfae *Workbook )GetChartByTargetId (targetAttr string )*_bb .ChartSpace {return _cfae ._ggda [targetAttr ];};

// Border is a cell border configuraton.
type Border struct{_bee *_bf .CT_Border ;_dgb *_bf .CT_Borders ;};func (_dfbg Font )SetBold (b bool ){if b {_dfbg ._ggc .B =[]*_bf .CT_BooleanProperty {{}};}else {_dfbg ._ggc .B =nil ;};};

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_fg .DocBase ;_gceg *_bf .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_gbfe []*_bf .Comments ;_bfbb []*_bf .Worksheet ;_cfac []_fg .Relationships ;_dfbgc _fg .Relationships ;_accb []*_gbb .Theme ;_gaffb []*_ac .WsDr ;
_effga []_fg .Relationships ;_dcefg []*_ce .Container ;_ebfc []*_bb .ChartSpace ;_efege []*_bf .Table ;_ceaec string ;_edga map[string ]string ;_ggda map[string ]*_bb .ChartSpace ;_fcec string ;};

// LockObject controls the locking of the sheet objects.
func (_cgaa SheetProtection )LockObject (b bool ){if !b {_cgaa ._aege .ObjectsAttr =nil ;}else {_cgaa ._aege .ObjectsAttr =_f .Bool (true );};};

// SetRow set the row of the cell marker.
func (_bbbd CellMarker )SetRow (row int32 ){_bbbd ._dbc .Row =row };func (_bcfgb *evalContext )Sheet (name string )_ca .Context {for _ ,_ebgc :=range _bcfgb ._gaa ._fdcd .Sheets (){if _ebgc .Name ()==name {return _ebgc .FormulaContext ();};};return _ca .InvalidReferenceContext ;
};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_dbba *_bf .CT_SheetView };func (_ccac Font )Index ()uint32 {for _cgfg ,_fegb :=range _ccac ._bcdfc .Fonts .Font {if _ccac ._ggc ==_fegb {return uint32 (_cgfg );};};return 0;};func (_dfb Fills )X ()*_bf .CT_Fills {return _dfb ._dccc };


// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_eafa SheetView )SetZoom (pct uint32 ){_eafa ._dbba .ZoomScaleAttr =&pct };

// SetFont applies a font to a cell style avoiding redundancy. The function checks if the given font
// already exists in the saved fonts. If found, the existing font is reused; otherwise,
// the new font is added to the saved fonts collection. The font is then applied to the cell style,
// affecting all styles that reference it by index.
func (_fcc CellStyle )SetFont (f Font ){_fbd :=f ._bcdfc .Fonts .Font ;for _ ,_agb :=range _fbd {if _cgg .DeepEqual (_agb ,f ._ggc ){f ._ggc =_agb ;_fcc ._cag .FontIdAttr =_f .Uint32 (f .Index ());_fcc ._cag .ApplyFontAttr =_f .Bool (true );return ;};};
f ._bcdfc .Fonts .Font =append (f ._bcdfc .Fonts .Font ,f ._ggc );f ._bcdfc .Fonts .CountAttr =_f .Uint32 (uint32 (len (f ._bcdfc .Fonts .Font )));_fcc ._cag .FontIdAttr =_f .Uint32 (f .Index ());_fcc ._cag .ApplyFontAttr =_f .Bool (true );};

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_ag Cell )SetFormulaShared (formulaStr string ,rows ,cols uint32 )error {_gd :=_ca .ParseString (formulaStr );if _gd ==nil {return _cda .New (_d .Sprintf ("\u0043a\u006en\u006f\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0073",formulaStr ));
};_ag .clearValue ();_ag ._faa .TAttr =_bf .ST_CellTypeStr ;_ag ._faa .F =_bf .NewCT_CellFormula ();_ag ._faa .F .TAttr =_bf .ST_CellFormulaTypeShared ;_ag ._faa .F .Content =formulaStr ;_afg ,_aefe :=_dg .ParseCellReference (_ag .Reference ());if _aefe !=nil {return _aefe ;
};_gfa :=uint32 (0);for _ ,_dcg :=range _ag ._bbc .Rows (){for _ ,_ga :=range _dcg ._bgb .C {if _ga .F !=nil &&_ga .F .SiAttr !=nil &&*_ga .F .SiAttr >=_gfa {_gfa =*_ga .F .SiAttr ;};};};_gfa ++;_fdbd :=_d .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_afg .Column ,_afg .RowIdx ,_dg .IndexToColumn (_afg .ColumnIdx +cols ),_afg .RowIdx +rows );
_ag ._faa .F .RefAttr =_f .String (_fdbd );_ag ._faa .F .SiAttr =_f .Uint32 (_gfa );_cca :=Sheet {_ag ._aef ,_ag ._bbc ._fggga ,_ag ._bbc ._gfae };for _df :=_afg .RowIdx ;_df <=_afg .RowIdx +rows ;_df ++{for _ccc :=_afg .ColumnIdx ;_ccc <=_afg .ColumnIdx +cols ;
_ccc ++{if _df ==_afg .RowIdx &&_ccc ==_afg .ColumnIdx {continue ;};_bcb :=_d .Sprintf ("\u0025\u0073\u0025\u0064",_dg .IndexToColumn (_ccc ),_df );_cca .Cell (_bcb ).Clear ();_cca .Cell (_bcb ).X ().F =_bf .NewCT_CellFormula ();_cca .Cell (_bcb ).X ().F .TAttr =_bf .ST_CellFormulaTypeShared ;
_cca .Cell (_bcb ).X ().F .SiAttr =_f .Uint32 (_gfa );};};return nil ;};

// Protection controls the protection on an individual sheet.
func (_efgd *Sheet )Protection ()SheetProtection {if _efgd ._gfae .SheetProtection ==nil {_efgd ._gfae .SheetProtection =_bf .NewCT_SheetProtection ();};return SheetProtection {_efgd ._gfae .SheetProtection };};

// SetStyle applies a style to a cell avoiding redundancy. The function checks if the given style
// already exists in the saved styles. If found, the existing style is reused; otherwise,
// the new style is added to the saved styles collection. The style is then applied to the cell.
// This style is referenced in the generated XML via CellStyle.Index().
func (_gdd Cell )SetStyle (cs CellStyle ){_cdae :=cs ._fcf .Xf ;for _ ,_ceee :=range _cdae {if _cgg .DeepEqual (_ceee ,cs ._cag ){cs ._cag =_ceee ;_gdd .SetStyleIndex (cs .Index ());return ;};};cs ._fcf .Xf =append (cs ._fcf .Xf ,cs ._cag );cs ._fcf .CountAttr =_f .Uint32 (uint32 (len (cs ._fcf .Xf )));
_gdd .SetStyleIndex (cs .Index ());};

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_bgcb Row )AddNamedCell (col string )Cell {_agf :=_bf .NewCT_Cell ();_agf .RAttr =_f .Stringf ("\u0025\u0073\u0025\u0064",col ,_bgcb .RowNumber ());_bdde :=-1;_dggc :=_dg .ColumnToIndex (col );for _acbd ,_ccgd :=range _bgcb ._bgb .C {_ggcc ,_ebag :=_dg .ParseCellReference (*_ccgd .RAttr );
if _ebag !=nil {return Cell {};};if _dggc < _ggcc .ColumnIdx {_bdde =_acbd ;break ;};};if _bdde ==-1{_bgcb ._bgb .C =append (_bgcb ._bgb .C ,_agf );}else {_bgcb ._bgb .C =append (_bgcb ._bgb .C [:_bdde ],append ([]*_bf .CT_Cell {_agf },_bgcb ._bgb .C [_bdde :]...)...);
};return Cell {_bgcb ._gdc ,_bgcb ._ade ,_bgcb ._bgb ,_agf };};

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_dda Row )Cell (col string )Cell {_ddede :=_d .Sprintf ("\u0025\u0073\u0025\u0064",col ,_dda .RowNumber ());for _ ,_eddc :=range _dda ._bgb .C {if _eddc .RAttr !=nil &&*_eddc .RAttr ==_ddede {return Cell {_dda ._gdc ,_dda ._ade ,_dda ._bgb ,_eddc };
};};return _dda .AddNamedCell (col );};

// ColOffset returns the offset from the row cell.
func (_feb CellMarker )ColOffset ()_ad .Distance {if _feb ._dbc .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _ad .Distance (float64 (*_feb ._dbc .ColOff .ST_CoordinateUnqualified )*_ad .EMU );};func (_ggce Sheet )IsValid ()bool {return _ggce ._gfae !=nil };


// BottomRight is a no-op.
func (_gfc AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};type evalContext struct{_gaa *Sheet ;_adcd ,_ge uint32 ;_gef map[string ]struct{};};func (_cdbd ConditionalFormattingRule )InitializeDefaults (){_cdbd .SetType (_bf .ST_CfTypeCellIs );
_cdbd .SetOperator (_bf .ST_ConditionalFormattingOperatorGreaterThan );_cdbd .SetPriority (1);};func _cec (_gff _cg .Time )_cg .Time {_gff =_gff .UTC ();return _cg .Date (_gff .Year (),_gff .Month (),_gff .Day (),_gff .Hour (),_gff .Minute (),_gff .Second (),_gff .Nanosecond (),_cg .Local );
};

// X returns the inner wrapped XML type.
func (_bff ConditionalFormattingRule )X ()*_bf .CT_CfRule {return _bff ._aecc };

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_eege *_bf .CT_ConditionalFormatting };

// StyleSheet is a document style sheet.
type StyleSheet struct{_faceb *Workbook ;_cafe *_bf .StyleSheet ;};

// SetInlineString adds a string inline instead of in the shared strings table.
func (_da Cell )SetInlineString (s string ){_da .clearValue ();_da ._faa .Is =_bf .NewCT_Rst ();_da ._faa .Is .T =_f .String (s );_da ._faa .TAttr =_bf .ST_CellTypeInlineStr ;};

// AddCommentWithStyle adds a new comment styled in a default way
func (_abac Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_cegd :=_abac .AddComment (cellRef ,author );_ddf :=_cegd .AddRun ();_ddf .SetBold (true );_ddf .SetSize (10);_ddf .SetColor (_de .Black );_ddf .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");
_ddf .SetText (author +"\u003a");_ddf =_cegd .AddRun ();_ddf .SetSize (10);_ddf .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_ddf .SetColor (_de .Black );_ddf .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_gaf ,_gcec :=_dg .ParseCellReference (cellRef );
if _gcec !=nil {return _gcec ;};_abac ._eac ._dcefg [0].Shape =append (_abac ._eac ._dcefg [0].Shape ,_ce .NewCommentShape (int64 (_gaf .ColumnIdx ),int64 (_gaf .RowIdx -1)));return nil ;};func (_gaee *evalContext )NamedRange (ref string )_ca .Reference {for _ ,_gccg :=range _gaee ._gaa ._fdcd .DefinedNames (){if _gccg .Name ()==ref {return _ca .MakeRangeReference (_gccg .Content ());
};};for _ ,_fgdb :=range _gaee ._gaa ._fdcd .Tables (){if _fgdb .Name ()==ref {return _ca .MakeRangeReference (_d .Sprintf ("\u0025\u0073\u0021%\u0073",_gaee ._gaa .Name (),_fgdb .Reference ()));};};return _ca .ReferenceInvalid ;};

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_ddg Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_ceff :=[]Cell {};for _acbe :=uint32 (0);_acbe <=lastColIdx ;_acbe ++{_aga :=_ddg .Cell (_dg .IndexToColumn (_acbe ));_ceff =append (_ceff ,_aga );};return _ceff ;};

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_eeg AbsoluteAnchor )SetColOffset (m _ad .Distance ){_eeg ._ace .Pos .XAttr .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_ad .EMU ));};func (_edc ConditionalFormattingRule )clear (){_edc ._aecc .OperatorAttr =_bf .ST_ConditionalFormattingOperatorUnset ;
_edc ._aecc .ColorScale =nil ;_edc ._aecc .IconSet =nil ;_edc ._aecc .Formula =nil ;};

// GetDrawing return the worksheet drawing and its relationships if exists.
func (_fegga *Sheet )GetDrawing ()(*_ac .WsDr ,_fg .Relationships ){if _dbb :=_fegga ._gfae .Drawing ;_dbb !=nil {_ccdb :=0;for _ ,_cgab :=range _fegga ._fdcd ._bfbb {if _cfff :=_cgab .Drawing ;_cfff !=nil {if _cgab ==_fegga ._gfae {return _fegga ._fdcd ._gaffb [_ccdb ],_fegga ._fdcd ._effga [_ccdb ];
};_ccdb ++;};};};return nil ,_fg .Relationships {};};

// IsError returns true if the cell is an error type cell.
func (_eabf Cell )IsError ()bool {return _eabf ._faa .TAttr ==_bf .ST_CellTypeE };

// SetXSplit sets the column split point
func (_fddb SheetView )SetXSplit (v float64 ){_fddb .ensurePane ();_fddb ._dbba .Pane .XSplitAttr =_f .Float64 (v );};func (_eadb DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_eadb .clear ();_eadb ._aabc .TypeAttr =_bf .ST_DataValidationType (t );
_eadb ._aabc .OperatorAttr =_bf .ST_DataValidationOperator (op );return DataValidationCompare {_eadb ._aabc };};

// Index returns the index of the border for use with a cell style.
func (_gge Border )Index ()uint32 {for _bcc ,_gbf :=range _gge ._dgb .Border {if _gbf ==_gge ._bee {return uint32 (_bcc );};};return 0;};

// X returns the inner wrapped XML type.
func (_fbgd SharedStrings )X ()*_bf .Sst {return _fbgd ._cgac };

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_geba TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_geba ._fbbg .From }};

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_ddb Comment )SetAuthor (author string ){_ddb ._cdeg .AuthorIdAttr =Comments {_ddb ._ffb ,_ddb ._bdb }.getOrCreateAuthor (author );};func (_cga Border )SetTop (style _bf .ST_BorderStyle ,c _de .Color ){if _cga ._bee .Top ==nil {_cga ._bee .Top =_bf .NewCT_BorderPr ();
};_cga ._bee .Top .Color =_bf .NewCT_Color ();_cga ._bee .Top .Color .RgbAttr =c .AsRGBAString ();_cga ._bee .Top .StyleAttr =style ;};

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_gcc ConditionalFormattingRule )SetIcons ()IconScale {_gcc .clear ();_gcc .SetType (_bf .ST_CfTypeIconSet );_gcc ._aecc .IconSet =_bf .NewCT_IconSet ();_gcda :=IconScale {_gcc ._aecc .IconSet };_gcda .SetIcons (_bf .ST_IconSetType3TrafficLights1 );
return _gcda ;};

// SetReference sets the regin of cells that the merged cell applies to.
func (_gfgb MergedCell )SetReference (ref string ){_gfgb ._beef .RefAttr =ref };

// SetHeight sets the row height in points.
func (_edfc Row )SetHeight (d _ad .Distance ){_edfc ._bgb .HtAttr =_f .Float64 (float64 (d ));_edfc ._bgb .CustomHeightAttr =_f .Bool (true );};const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;AnchorTypeTwoCell ;);

// AddString adds a string to the shared string cache.
func (_ffd SharedStrings )AddString (v string )int {if _caeb ,_cceb :=_ffd ._dedg [v ];_cceb {return _caeb ;};_bdbe :=_bf .NewCT_Rst ();_bdbe .T =_f .String (v );_ffd ._cgac .Si =append (_ffd ._cgac .Si ,_bdbe );_cfbb :=len (_ffd ._cgac .Si )-1;_ffd ._dedg [v ]=_cfbb ;
_ffd ._cgac .CountAttr =_f .Uint32 (uint32 (len (_ffd ._cgac .Si )));_ffd ._cgac .UniqueCountAttr =_ffd ._cgac .CountAttr ;return _cfbb ;};

// GetValueAsNumber retrieves the cell's value as a number
func (_fe Cell )GetValueAsNumber ()(float64 ,error ){if _fe ._faa .V ==nil &&_fe ._faa .Is ==nil {return 0,nil ;};if _fe ._faa .TAttr ==_bf .ST_CellTypeS ||!_eda .IsNumber (*_fe ._faa .V ){return _eg .NaN (),_cda .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");
};return _ff .ParseFloat (*_fe ._faa .V ,64);};

// X returns the inner wrapped XML type.
func (_ced Border )X ()*_bf .CT_Border {return _ced ._bee };

// SetHyperlink sets a hyperlink on a cell.
func (_dea Cell )SetHyperlink (hl _fg .Hyperlink ){_ebg :=_dea ._bbc ._gfae ;if _ebg .Hyperlinks ==nil {_ebg .Hyperlinks =_bf .NewCT_Hyperlinks ();};_dcfb :=_fg .Relationship (hl );_bceg :=_bf .NewCT_Hyperlink ();_bceg .RefAttr =_dea .Reference ();_bceg .IdAttr =_f .String (_dcfb .ID ());
_ebg .Hyperlinks .Hyperlink =append (_ebg .Hyperlinks .Hyperlink ,_bceg );};

// SetWidthCells is a no-op.
func (_cagd OneCellAnchor )SetWidthCells (int32 ){};

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_ecb *Workbook ;_adg *_ac .WsDr ;};

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_afee *Sheet )InitialView ()SheetView {if _afee ._gfae .SheetViews ==nil ||len (_afee ._gfae .SheetViews .SheetView )==0{return _afee .AddView ();};return SheetView {_afee ._gfae .SheetViews .SheetView [0]};};func (_baaa StandardFormat )String ()string {switch {case 0<=_baaa &&_baaa <=4:return _abbff [_deab [_baaa ]:_deab [_baaa +1]];
case 9<=_baaa &&_baaa <=22:_baaa -=9;return _bacf [_cbefa [_baaa ]:_cbefa [_baaa +1]];case 37<=_baaa &&_baaa <=40:_baaa -=37;return _abecc [_afca [_baaa ]:_afca [_baaa +1]];case 45<=_baaa &&_baaa <=49:_baaa -=45;return _baeb [_ddgf [_baaa ]:_ddgf [_baaa +1]];
default:return _d .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_baaa );};};

// X returns the inner wrapped XML type.
func (_dcfg Drawing )X ()*_ac .WsDr {return _dcfg ._adg };

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_adab *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _adab .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _eabfa _fg .Relationship ;for _ ,_fag :=range _adab ._dfbgc .Relationships (){if _fag .ID ()==_adab ._gceg .Sheets .Sheet [ind ].IdAttr {var _efded bool ;
if _eabfa ,_efded =_adab ._dfbgc .CopyRelationship (_fag .ID ());!_efded {return Sheet {},ErrorNotFound ;};break ;};};_adab .ContentTypes .CopyOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .WorksheetContentType ,ind +1),_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .WorksheetContentType ,len (_adab .ContentTypes .X ().Override )));
_ecae :=*_adab ._bfbb [ind ];_adab ._bfbb =append (_adab ._bfbb ,&_ecae );var _abad uint32 =0;for _ ,_cdacb :=range _adab ._gceg .Sheets .Sheet {if _cdacb .SheetIdAttr > _abad {_abad =_cdacb .SheetIdAttr ;};};_abad ++;_dacd :=*_adab ._gceg .Sheets .Sheet [ind ];
_dacd .IdAttr =_eabfa .ID ();_dacd .NameAttr =copiedSheetName ;_dacd .SheetIdAttr =_abad ;_adab ._gceg .Sheets .Sheet =append (_adab ._gceg .Sheets .Sheet ,&_dacd );_gaef :=_fg .NewRelationshipsCopy (_adab ._cfac [ind ]);_adab ._cfac =append (_adab ._cfac ,_gaef );
_bbde :=_adab ._gbfe [ind ];if _bbde ==nil {_adab ._gbfe =append (_adab ._gbfe ,nil );}else {_fdee :=*_bbde ;_adab ._gbfe =append (_adab ._gbfe ,&_fdee );};_fcda :=Sheet {_adab ,&_dacd ,&_ecae };return _fcda ,nil ;};

// Author returns the author of the comment
func (_fgbe Comment )Author ()string {if _fgbe ._cdeg .AuthorIdAttr < uint32 (len (_fgbe ._bdb .Authors .Author )){return _fgbe ._bdb .Authors .Author [_fgbe ._cdeg .AuthorIdAttr ];};return "";};

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_gefbg StyleSheet )Fills ()Fills {return Fills {_gefbg ._cafe .Fills }};

// AddRun adds a new run of text to the cell.
func (_egg RichText )AddRun ()RichTextRun {_gbcg :=_bf .NewCT_RElt ();_egg ._bggb .R =append (_egg ._bggb .R ,_gbcg );return RichTextRun {_gbcg };};

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_gabb *Sheet )Row (rowNum uint32 )Row {for _ ,_cfdd :=range _gabb ._gfae .SheetData .Row {if _cfdd .RAttr !=nil &&*_cfdd .RAttr ==rowNum {return Row {_gabb ._fdcd ,_gabb ,_cfdd };};};return _gabb .AddNumberedRow (rowNum );};

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_bebc Drawing )AddImage (img _fg .ImageRef ,at AnchorType )Anchor {_efbb :=0;for _bfcb ,_bef :=range _bebc ._ecb .Images {if _bef ==img {_efbb =_bfcb +1;break ;};};var _edfg string ;for _eaca ,_fcfg :=range _bebc ._ecb ._gaffb {if _fcfg ==_bebc ._adg {_dbf :=_d .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_efbb ,img .Format ());
_gdg :=_bebc ._ecb ._effga [_eaca ].AddRelationship (_dbf ,_f .ImageType );_edfg =_gdg .ID ();break ;};};var _febc Anchor ;var _edge *_ac .CT_Picture ;switch at {case AnchorTypeAbsolute :_ccce :=_eaef ();_bebc ._adg .EG_Anchor =append (_bebc ._adg .EG_Anchor ,&_ac .EG_Anchor {AbsoluteAnchor :_ccce });
_ccce .Choice =&_ac .EG_ObjectChoicesChoice {};_ccce .Choice .Pic =_ac .NewCT_Picture ();_ccce .Pos .XAttr .ST_CoordinateUnqualified =_f .Int64 (0);_ccce .Pos .YAttr .ST_CoordinateUnqualified =_f .Int64 (0);_edge =_ccce .Choice .Pic ;_febc =AbsoluteAnchor {_ccce };
case AnchorTypeOneCell :_caab :=_bbfc ();_bebc ._adg .EG_Anchor =append (_bebc ._adg .EG_Anchor ,&_ac .EG_Anchor {OneCellAnchor :_caab });_caab .Choice =&_ac .EG_ObjectChoicesChoice {};_caab .Choice .Pic =_ac .NewCT_Picture ();_edge =_caab .Choice .Pic ;
_febc =OneCellAnchor {_caab };case AnchorTypeTwoCell :_cdbdg :=_dfdg ();_bebc ._adg .EG_Anchor =append (_bebc ._adg .EG_Anchor ,&_ac .EG_Anchor {TwoCellAnchor :_cdbdg });_cdbdg .Choice =&_ac .EG_ObjectChoicesChoice {};_cdbdg .Choice .Pic =_ac .NewCT_Picture ();
_edge =_cdbdg .Choice .Pic ;_febc =TwoCellAnchor {_cdbdg };};_edge .NvPicPr .CNvPr .IdAttr =uint32 (len (_bebc ._adg .EG_Anchor ));_edge .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_edge .BlipFill .Blip =_gbb .NewCT_Blip ();_edge .BlipFill .Blip .EmbedAttr =_f .String (_edfg );
_edge .BlipFill .Stretch =_gbb .NewCT_StretchInfoProperties ();_edge .SpPr =_gbb .NewCT_ShapeProperties ();_edge .SpPr .Xfrm =_gbb .NewCT_Transform2D ();_edge .SpPr .Xfrm .Off =_gbb .NewCT_Point2D ();_edge .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_f .Int64 (0);
_edge .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_f .Int64 (0);_edge .SpPr .Xfrm .Ext =_gbb .NewCT_PositiveSize2D ();_edge .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_ad .Pixel72 )/_ad .EMU );_edge .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_ad .Pixel72 )/_ad .EMU );
_edge .SpPr .PrstGeom =_gbb .NewCT_PresetGeometry2D ();_edge .SpPr .PrstGeom .PrstAttr =_gbb .ST_ShapeTypeRect ;_edge .SpPr .Ln =_gbb .NewCT_LineProperties ();_edge .SpPr .Ln .NoFill =_gbb .NewCT_NoFillProperties ();return _febc ;};

// Tables returns a slice of all defined tables in the workbook.
func (_acbae *Workbook )Tables ()[]Table {if _acbae ._efege ==nil {return nil ;};_gdcf :=[]Table {};for _ ,_bfgc :=range _acbae ._efege {_gdcf =append (_gdcf ,Table {_bfgc });};return _gdcf ;};

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_bgcca *Workbook )AddDefinedName (name ,ref string )DefinedName {if _bgcca ._gceg .DefinedNames ==nil {_bgcca ._gceg .DefinedNames =_bf .NewCT_DefinedNames ();};_deffb :=_bf .NewCT_DefinedName ();_deffb .Content =ref ;_deffb .NameAttr =name ;_bgcca ._gceg .DefinedNames .DefinedName =append (_bgcca ._gceg .DefinedNames .DefinedName ,_deffb );
return DefinedName {_deffb };};

// Name returns the sheet name
func (_bbe Sheet )Name ()string {return _bbe ._fggga .NameAttr };

// IsBool returns true if the cell is a boolean type cell.
func (_bfd Cell )IsBool ()bool {return _bfd ._faa .TAttr ==_bf .ST_CellTypeB };

// AddFormatValue adds a format value to be used to determine the cell background.
func (_fegg ColorScale )AddFormatValue (t _bf .ST_CfvoType ,val string ){_efb :=_bf .NewCT_Cfvo ();_efb .TypeAttr =t ;_efb .ValAttr =_f .String (val );_fegg ._bcce .Cfvo =append (_fegg ._bcce .Cfvo ,_efb );};

// X returns the inner wrapped XML type.
func (_acef NumberFormat )X ()*_bf .CT_NumFmt {return _acef ._badc };func (_bbcd Sheet )validateSheetNames ()error {_dfa :=len ([]rune (_bbcd .Name ()));if _dfa > 31{return _d .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_bbcd .Name (),_dfa );
};return nil ;};

// X returns the inner wrapped XML type.
func (_cea DifferentialStyle )X ()*_bf .CT_Dxf {return _cea ._fgc };

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_caabf :=uint16 (0);if len (s )> 0{for _fea :=len (s )-1;_fea >=0;_fea --{_dggb :=s [_fea ];_caabf =((_caabf >>14)&0x01)|((_caabf <<1)&0x7fff);_caabf ^=uint16 (_dggb );};_caabf =((_caabf >>14)&0x01)|((_caabf <<1)&0x7fff);
_caabf ^=uint16 (len (s ));_caabf ^=(0x8000|('N'<<8)|'K');};return _d .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_caabf ));};

// Row is a row within a spreadsheet.
type Row struct{_gdc *Workbook ;_ade *Sheet ;_bgb *_bf .CT_Row ;};func (_ceffb *Workbook )onNewRelationship (_bdacb *_gb .DecodeMap ,_gcce ,_gcfd string ,_baeg []*_ee .File ,_ecag *_gf .Relationship ,_dddea _gb .Target )error {_caddb :=_f .DocTypeSpreadsheet ;
switch _gcfd {case _f .OfficeDocumentType :_ceffb ._gceg =_bf .NewWorkbook ();_bdacb .AddTarget (_gcce ,_ceffb ._gceg ,_gcfd ,0);_ceffb ._dfbgc =_fg .NewRelationships ();_bdacb .AddTarget (_gb .RelationsPathFor (_gcce ),_ceffb ._dfbgc .X (),_gcfd ,0);_ecag .TargetAttr =_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,0);
case _f .CorePropertiesType :_bdacb .AddTarget (_gcce ,_ceffb .CoreProperties .X (),_gcfd ,0);_ecag .TargetAttr =_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,0);case _f .CustomPropertiesType :_bdacb .AddTarget (_gcce ,_ceffb .CustomProperties .X (),_gcfd ,0);
_ecag .TargetAttr =_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,0);case _f .ExtendedPropertiesType :_bdacb .AddTarget (_gcce ,_ceffb .AppProperties .X (),_gcfd ,0);_ecag .TargetAttr =_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,0);case _f .WorksheetType :_fgbcg :=_bf .NewWorksheet ();
_bcba ,_bddeg :=_dc .StringToNumbers (_gcce );if !_bddeg {_bcba =len (_ceffb ._bfbb );};_bdacb .AddTarget (_gcce ,_fgbcg ,_gcfd ,uint32 (_bcba ));_efea :=_fg .NewRelationships ();_bdacb .AddTarget (_gb .RelationsPathFor (_gcce ),_efea .X (),_gcfd ,0);_ceffb ._cfac =append (_ceffb ._cfac ,_efea );
_ceffb ._gbfe =append (_ceffb ._gbfe ,nil );_ecag .TargetAttr =_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,_bcba );if _ceffb ._gceg .Sheets !=nil {if len (_ceffb ._bfbb )< 1{_ceffb ._bfbb =make ([]*_bf .Worksheet ,len (_ceffb ._gceg .Sheets .Sheet ));
};for _dgcga ,_ecdfc :=range _ceffb ._gceg .Sheets .Sheet {if _ecdfc .IdAttr ==_ecag .IdAttr {_ceffb ._bfbb [_dgcga ]=_fgbcg ;};};}else {_ceffb ._bfbb =append (_ceffb ._bfbb ,_fgbcg );};case _f .StylesType :_ceffb .StyleSheet =NewStyleSheet (_ceffb );_bdacb .AddTarget (_gcce ,_ceffb .StyleSheet .X (),_gcfd ,0);
_ecag .TargetAttr =_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,0);case _f .ThemeType :_cdgg :=_gbb .NewTheme ();_ceffb ._accb =append (_ceffb ._accb ,_cdgg );_bdacb .AddTarget (_gcce ,_cdgg ,_gcfd ,0);_ecag .TargetAttr =_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,len (_ceffb ._accb ));
case _f .SharedStringsType :_ceffb .SharedStrings =NewSharedStrings ();_bdacb .AddTarget (_gcce ,_ceffb .SharedStrings .X (),_gcfd ,0);_ecag .TargetAttr =_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,0);case _f .ThumbnailType :for _dgga ,_gcbg :=range _baeg {if _gcbg ==nil {continue ;
};if _gcbg .Name ==_gcce {_cfdeb ,_cdga :=_gcbg .Open ();if _cdga !=nil {return _d .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_cdga );};_ceffb .Thumbnail ,_ ,_cdga =_b .Decode (_cfdeb );
_cfdeb .Close ();if _cdga !=nil {return _d .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_cdga );};_baeg [_dgga ]=nil ;};};case _f .ImageType :for _fafab ,_caac :=range _ceffb ._edga {_dabe :=_e .Clean (_gcce );
if _dabe ==_fafab {_ecag .TargetAttr =_caac ;return nil ;};};_bec :=_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,len (_ceffb .Images )+1);for _bcff ,_dbaef :=range _baeg {if _dbaef ==nil {continue ;};if _dbaef .Name ==_e .Clean (_gcce ){_cdda ,_edfe :=_gb .ExtractToDiskTmp (_dbaef ,_ceffb .TmpPath );
if _edfe !=nil {return _edfe ;};_ddca ,_edfe :=_fg .ImageFromStorage (_cdda );if _edfe !=nil {return _edfe ;};_acae :=_fg .MakeImageRef (_ddca ,&_ceffb .DocBase ,_ceffb ._dfbgc );_acae .SetTarget (_bec );_ceffb ._edga [_dbaef .Name ]=_bec ;_ceffb .Images =append (_ceffb .Images ,_acae );
_baeg [_bcff ]=nil ;};};_ecag .TargetAttr =_bec ;case _f .DrawingType :_bcag :=_ac .NewWsDr ();_bfgf :=uint32 (len (_ceffb ._gaffb ));_bdacb .AddTarget (_gcce ,_bcag ,_gcfd ,_bfgf );_ceffb ._gaffb =append (_ceffb ._gaffb ,_bcag );_ecff :=_fg .NewRelationships ();
_bdacb .AddTarget (_gb .RelationsPathFor (_gcce ),_ecff .X (),_gcfd ,_bfgf );_ceffb ._effga =append (_ceffb ._effga ,_ecff );_ecag .TargetAttr =_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,len (_ceffb ._gaffb ));case _f .VMLDrawingType :_baba :=_ce .NewContainer ();
_bfaef :=uint32 (len (_ceffb ._dcefg ));_bdacb .AddTarget (_gcce ,_baba ,_gcfd ,_bfaef );_ceffb ._dcefg =append (_ceffb ._dcefg ,_baba );case _f .CommentsType :_ceffb ._gbfe [_dddea .Index ]=_bf .NewComments ();_bdacb .AddTarget (_gcce ,_ceffb ._gbfe [_dddea .Index ],_gcfd ,_dddea .Index );
_ecag .TargetAttr =_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,len (_ceffb ._gbfe ));case _f .ChartType :_bbdc :=_bb .NewChartSpace ();_ebaef :=uint32 (len (_ceffb ._ebfc ));_bdacb .AddTarget (_gcce ,_bbdc ,_gcfd ,_ebaef );_ceffb ._ebfc =append (_ceffb ._ebfc ,_bbdc );
_ecag .TargetAttr =_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,len (_ceffb ._ebfc ));if _ceffb ._ggda ==nil {_ceffb ._ggda =make (map[string ]*_bb .ChartSpace );};_ceffb ._ggda [_ecag .TargetAttr ]=_bbdc ;case _f .TableType :_gcga :=_bf .NewTable ();
_eadbf :=uint32 (len (_ceffb ._efege ));_bdacb .AddTarget (_gcce ,_gcga ,_gcfd ,_eadbf );_ceffb ._efege =append (_ceffb ._efege ,_gcga );_ecag .TargetAttr =_f .RelativeFilename (_caddb ,_dddea .Typ ,_gcfd ,len (_ceffb ._efege ));default:_db .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_gcce ,_gcfd );
};return nil ;};func (_cfc *evalContext )SetOffset (col ,row uint32 ){_cfc ._adcd =col ;_cfc ._ge =row };

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_cabg *_bf .CT_DataValidation };

// X returns the inner wrapped XML type.
func (_agdb Row )X ()*_bf .CT_Row {return _agdb ._bgb };

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;

// Sheet is a single sheet within a workbook.
type Sheet struct{_fdcd *Workbook ;_fggga *_bf .CT_Sheet ;_gfae *_bf .Worksheet ;};func (_fb Border )SetRight (style _bf .ST_BorderStyle ,c _de .Color ){if _fb ._bee .Right ==nil {_fb ._bee .Right =_bf .NewCT_BorderPr ();};_fb ._bee .Right .Color =_bf .NewCT_Color ();
_fb ._bee .Right .Color .RgbAttr =c .AsRGBAString ();_fb ._bee .Right .StyleAttr =style ;};func (_bebb PatternFill )ClearFgColor (){_bebb ._cafb .FgColor =nil };

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_aee Cell )SetStringByID (id int ){_aee ._aef .ensureSharedStringsRelationships ();_aee .clearValue ();_aee ._faa .V =_f .String (_ff .Itoa (id ));_aee ._faa .TAttr =_bf .ST_CellTypeS ;};

// X returns the inner wrapped XML type.
func (_efbbg *Workbook )X ()*_bf .Workbook {return _efbbg ._gceg };

// ExtractText returns text from the workbook as a WorkbookText object.
func (_fffc *Workbook )ExtractText ()*WorkbookText {_febg :=[]*SheetText {};for _ ,_ebad :=range _fffc .Sheets (){_febg =append (_febg ,&SheetText {Cells :_ebad .ExtractText ().Cells });};return &WorkbookText {Sheets :_febg };};

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_ded *_bf .CT_RElt };

// Name returns the name of the table
func (_gdda Table )Name ()string {if _gdda ._gfbgg .NameAttr !=nil {return *_gdda ._gfbgg .NameAttr ;};return "";};

// SortOrder is a column sort order.
//
//go:generate stringer -type=SortOrder
type SortOrder byte ;

// StandardFormat is a standard ECMA 376 number format.
//
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_dga Cell )Reference ()string {if _dga ._faa .RAttr !=nil {return *_dga ._faa .RAttr ;};return "";};

// SetWidthCells is a no-op.
func (_af AbsoluteAnchor )SetWidthCells (int32 ){};

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_gbdga StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_baef :=range _gbdga .CellStyles (){if _baef .HasNumberFormat ()&&_baef .NumberFormat ()==uint32 (f ){return _baef ;};};_bdfg :=_gbdga .AddCellStyle ();_bdfg .SetNumberFormatStandard (f );
return _bdfg ;};

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_dcb CellStyle )SetNumberFormatStandard (s StandardFormat ){_dcb ._cag .NumFmtIdAttr =_f .Uint32 (uint32 (s ));_dcb ._cag .ApplyNumberFormatAttr =_f .Bool (true );};

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_ceffe Sheet )Extents ()string {_ecbcb ,_efbbc ,_fece ,_abfb :=_ceffe .ExtentsIndex ();return _d .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_ecbcb ,_efbbc ,_fece ,_abfb );};

// Validate attempts to validate the structure of a workbook.
func (_acabf *Workbook )Validate ()error {if _acabf ==nil ||_acabf ._gceg ==nil {return _cda .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");
};_dgfc :=uint32 (0);for _ ,_adfe :=range _acabf ._gceg .Sheets .Sheet {if _adfe .SheetIdAttr > _dgfc {_dgfc =_adfe .SheetIdAttr ;};};if _dgfc !=uint32 (len (_acabf ._bfbb )){return _d .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_dgfc ,len (_acabf ._bfbb ));
};_bdgg :=map[string ]struct{}{};for _cfeg ,_aacab :=range _acabf ._gceg .Sheets .Sheet {_dbdg :=Sheet {_acabf ,_aacab ,_acabf ._bfbb [_cfeg ]};if _ ,_ddcf :=_bdgg [_dbdg .Name ()];_ddcf {return _d .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_cfeg ,_dbdg .Name ());
};_bdgg [_dbdg .Name ()]=struct{}{};if _gfbd :=_dbdg .ValidateWithPath (_d .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_cfeg ));_gfbd !=nil {return _gfbd ;};if _dfbb :=_dbdg .Validate ();_dfbb !=nil {return _dfbb ;
};};return nil ;};

// SetHidden marks the defined name as hidden.
func (_aag DefinedName )SetLocalSheetID (id uint32 ){_aag ._dcce .LocalSheetIdAttr =_f .Uint32 (id )};

// Comments is the container for comments for a single sheet.
type Comments struct{_eac *Workbook ;_fca *_bf .Comments ;};

// SetPriority sets the rule priority
func (_eegee ConditionalFormattingRule )SetPriority (p int32 ){_eegee ._aecc .PriorityAttr =p };

// SetHeightAuto sets the row height to be automatically determined.
func (_cae Row )SetHeightAuto (){_cae ._bgb .HtAttr =nil ;_cae ._bgb .CustomHeightAttr =nil };

// SetWidth is a no-op.
func (_bbed TwoCellAnchor )SetWidth (w _ad .Distance ){};

// LockStructure controls the locking of the workbook structure.
func (_fdec WorkbookProtection )LockStructure (b bool ){if !b {_fdec ._afbb .LockStructureAttr =nil ;}else {_fdec ._afbb .LockStructureAttr =_f .Bool (true );};};

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_bbgf *Sheet )AddHyperlink (url string )_fg .Hyperlink {for _eeed ,_ccbe :=range _bbgf ._fdcd ._bfbb {if _ccbe ==_bbgf ._gfae {return _bbgf ._fdcd ._cfac [_eeed ].AddHyperlink (url );};};return _fg .Hyperlink {};};

// SetProtectedAndHidden sets protected and hidden for given cellStyle
func (_dbe CellStyle )SetProtection (protected bool ,hidden bool ){_dbe ._cag .Protection =&_bf .CT_CellProtection {LockedAttr :&protected ,HiddenAttr :&hidden };};func (_cgd Cell )getLabelPrefix ()string {if _cgd ._faa .SAttr ==nil {return "";};_cedd :=*_cgd ._faa .SAttr ;
_bfb :=_cgd ._aef .StyleSheet .GetCellStyle (_cedd );switch _bfb ._cag .Alignment .HorizontalAttr {case _bf .ST_HorizontalAlignmentLeft :return "\u0027";case _bf .ST_HorizontalAlignmentRight :return "\u0022";case _bf .ST_HorizontalAlignmentCenter :return "\u005e";
case _bf .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};

// Text returns text from the sheet as one string separated with line breaks.
func (_gaff *SheetText )Text ()string {_cffc :=_g .NewBuffer ([]byte {});for _ ,_dcab :=range _gaff .Cells {if _dcab .Text !=""{_cffc .WriteString (_dcab .Text );_cffc .WriteString ("\u000a");};};return _cffc .String ();};

// SetPattern sets the pattern of the fill.
func (_aeca PatternFill )SetPattern (p _bf .ST_PatternType ){_aeca ._cafb .PatternTypeAttr =p };

// X returns the inner wrapped XML type.
func (_fcag ConditionalFormatting )X ()*_bf .CT_ConditionalFormatting {return _fcag ._eege };

// SetValues sets the possible values. This is incompatible with SetRange.
func (_cdac DataValidationList )SetValues (values []string ){_cdac ._cabg .Formula1 =_f .String ("\u0022"+_cb .Join (values ,"\u002c")+"\u0022");_cdac ._cabg .Formula2 =_f .String ("\u0030");};func (_fac DataValidationCompare )SetValue2 (v string ){_fac ._bbga .Formula2 =&v };
func (_faef *Sheet )removeColumnFromNamedRanges (_ccbd uint32 )error {for _ ,_dddd :=range _faef ._fdcd .DefinedNames (){_bfea :=_dddd .Name ();_aeba :=_dddd .Content ();_abdaf :=_cb .Split (_aeba ,"\u0021");if len (_abdaf )!=2{return _cda .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_aeba );
};_fdbe :=_abdaf [0];if _faef .Name ()==_fdbe {_fced :=_faef ._fdcd .RemoveDefinedName (_dddd );if _fced !=nil {return _fced ;};_acba :=_gdfc (_abdaf [1],_ccbd ,true );if _acba !=""{_addg :=_fdbe +"\u0021"+_acba ;_faef ._fdcd .AddDefinedName (_bfea ,_addg );
};};};_gddec :=0;if _faef ._gfae .TableParts !=nil &&_faef ._gfae .TableParts .TablePart !=nil {_gddec =len (_faef ._gfae .TableParts .TablePart );};if _gddec !=0{_bddd :=0;for _ ,_ffcbg :=range _faef ._fdcd .Sheets (){if _ffcbg .Name ()==_faef .Name (){break ;
}else {if _ffcbg ._gfae .TableParts !=nil &&_ffcbg ._gfae .TableParts .TablePart !=nil {_bddd +=len (_ffcbg ._gfae .TableParts .TablePart );};};};_bdcbb :=_faef ._fdcd ._efege [_bddd :_bddd +_gddec ];for _cbde ,_gaab :=range _bdcbb {_gcbb :=_gaab ;_gcbb .RefAttr =_gdfc (_gcbb .RefAttr ,_ccbd ,false );
_faef ._fdcd ._efege [_bddd +_cbde ]=_gcbb ;};};return nil ;};

// IsHidden returns whether the row is hidden or not.
func (_abbb Row )IsHidden ()bool {return _abbb ._bgb .HiddenAttr !=nil &&*_abbb ._bgb .HiddenAttr };

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_bcfc *Workbook )ClearCachedFormulaResults (){for _ ,_cfgc :=range _bcfc .Sheets (){_cfgc .ClearCachedFormulaResults ();};};

// Sheets returns the sheets from the workbook.
func (_beffe *Workbook )Sheets ()[]Sheet {_cbed :=[]Sheet {};for _agdag ,_gdea :=range _beffe ._bfbb {_egge :=_beffe ._gceg .Sheets .Sheet [_agdag ];if _egge .StateAttr ==_bf .ST_SheetStateHidden ||_egge .StateAttr ==_bf .ST_SheetStateVeryHidden {continue ;
};_effce :=Sheet {_beffe ,_egge ,_gdea };_cbed =append (_cbed ,_effce );};return _cbed ;};func (_afbg *Sheet )setList (_fgdf string ,_gaaa _ca .Result )error {_bbgdd ,_abcg :=_dg .ParseCellReference (_fgdf );if _abcg !=nil {return _abcg ;};_caffd :=_afbg .Row (_bbgdd .RowIdx );
for _eabfe ,_abbfd :=range _gaaa .ValueList {_abaaf :=_caffd .Cell (_dg .IndexToColumn (_bbgdd .ColumnIdx +uint32 (_eabfe )));if _abbfd .Type !=_ca .ResultTypeEmpty {if _abbfd .IsBoolean {_abaaf .SetBool (_abbfd .ValueNumber !=0);}else {_abaaf .SetCachedFormulaResult (_abbfd .String ());
};};};return nil ;};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_ffcb Comment )CellReference ()string {return _ffcb ._cdeg .RefAttr };

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_cad Comments )AddComment (cellRef string ,author string )RichText {_bcf :=_bf .NewCT_Comment ();_cad ._fca .CommentList .Comment =append (_cad ._fca .CommentList .Comment ,_bcf );_bcf .RefAttr =cellRef ;_bcf .AuthorIdAttr =_cad .getOrCreateAuthor (author );
_bcf .Text =_bf .NewCT_Rst ();return RichText {_bcf .Text };};

// Themes returns the array of workbook dml.Theme.
func (_ccfbga *Workbook )Themes ()[]*_gbb .Theme {return _ccfbga ._accb };

// X returns the inner wrapped XML type.
func (_dgf DataBarScale )X ()*_bf .CT_DataBar {return _dgf ._gbc };

// SetPassword sets the password hash to a hash of the input password.
func (_fgggac WorkbookProtection )SetPassword (pw string ){_fgggac .SetPasswordHash (PasswordHash (pw ))};func (_ggdf Border )SetDiagonal (style _bf .ST_BorderStyle ,c _de .Color ,up ,down bool ){if _ggdf ._bee .Diagonal ==nil {_ggdf ._bee .Diagonal =_bf .NewCT_BorderPr ();
};_ggdf ._bee .Diagonal .Color =_bf .NewCT_Color ();_ggdf ._bee .Diagonal .Color .RgbAttr =c .AsRGBAString ();_ggdf ._bee .Diagonal .StyleAttr =style ;if up {_ggdf ._bee .DiagonalUpAttr =_f .Bool (true );};if down {_ggdf ._bee .DiagonalDownAttr =_f .Bool (true );
};};

// Comment is a single comment within a sheet.
type Comment struct{_ffb *Workbook ;_cdeg *_bf .CT_Comment ;_bdb *_bf .Comments ;};

// SetRowOffset sets the row offset of the two cell anchor
func (_gfed TwoCellAnchor )SetRowOffset (m _ad .Distance ){_ecdc :=m -_gfed .TopLeft ().RowOffset ();_gfed .TopLeft ().SetRowOffset (m );_gfed .BottomRight ().SetRowOffset (_gfed .BottomRight ().RowOffset ()+_ecdc );};func (_deacc StyleSheet )appendBorder ()Border {_ggcbc :=_bf .NewCT_Border ();
_deacc ._cafe .Borders .Border =append (_deacc ._cafe .Borders .Border ,_ggcbc );_deacc ._cafe .Borders .CountAttr =_f .Uint32 (uint32 (len (_deacc ._cafe .Borders .Border )));return Border {_ggcbc ,_deacc ._cafe .Borders };};

// Reference returns the region of cells that are merged.
func (_fgga MergedCell )Reference ()string {return _fgga ._beef .RefAttr };

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_afb Cell )SetFormulaRaw (s string ){_bg :=_ca .ParseString (s );if _bg ==nil {return ;};_afb .clearValue ();_afb ._faa .TAttr =_bf .ST_CellTypeStr ;_afb ._faa .F =_bf .NewCT_CellFormula ();_afb ._faa .F .Content =s ;};

// LockWindow controls the locking of the workbook windows.
func (_afbbf WorkbookProtection )LockWindow (b bool ){if !b {_afbbf ._afbb .LockWindowsAttr =nil ;}else {_afbbf ._afbb .LockWindowsAttr =_f .Bool (true );};};

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_cgb Cell )SetRichTextString ()RichText {_cgb .clearValue ();_cgb ._faa .Is =_bf .NewCT_Rst ();_cgb ._faa .TAttr =_bf .ST_CellTypeInlineStr ;return RichText {_cgb ._faa .Is };};

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_aadb *Sheet )Column (idx uint32 )Column {for _ ,_daffe :=range _aadb ._gfae .Cols {for _ ,_begc :=range _daffe .Col {if idx >=_begc .MinAttr &&idx <=_begc .MaxAttr {return Column {_begc };};};};var _ffcd *_bf .CT_Cols ;if len (_aadb ._gfae .Cols )==0{_ffcd =_bf .NewCT_Cols ();
_aadb ._gfae .Cols =append (_aadb ._gfae .Cols ,_ffcd );}else {_ffcd =_aadb ._gfae .Cols [0];};_fdfb :=_bf .NewCT_Col ();_fdfb .MinAttr =idx ;_fdfb .MaxAttr =idx ;_ffcd .Col =append (_ffcd .Col ,_fdfb );return Column {_fdfb };};

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_cefd *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_cb .Replace (rangeRef ,"\u0024","",-1);_cefd ._gfae .AutoFilter =_bf .NewCT_AutoFilter ();_cefd ._gfae .AutoFilter .RefAttr =_f .String (rangeRef );_efe :="\u0027"+_cefd .Name ()+"\u0027\u0021";
var _fbbd DefinedName ;for _ ,_ebbf :=range _cefd ._fdcd .DefinedNames (){if _ebbf .Name ()==_bfg {if _cb .HasPrefix (_ebbf .Content (),_efe ){_fbbd =_ebbf ;_fbbd .SetContent (_cefd .RangeReference (rangeRef ));break ;};};};if _fbbd .X ()==nil {_fbbd =_cefd ._fdcd .AddDefinedName (_bfg ,_cefd .RangeReference (rangeRef ));
};for _aedae ,_dfbf :=range _cefd ._fdcd ._bfbb {if _dfbf ==_cefd ._gfae {_fbbd .SetLocalSheetID (uint32 (_aedae ));};};};func (_cfbf *Workbook )ensureSharedStringsRelationships (){_ggbcea :=false ;for _ ,_dgge :=range _cfbf .ContentTypes .X ().Override {if _dgge .ContentTypeAttr ==_f .SharedStringsContentType {_ggbcea =true ;
break ;};};if !_ggbcea {_cfbf .ContentTypes .AddOverride (_ebcd ,_f .SharedStringsContentType );};_cfce :=false ;for _ ,_fddc :=range _cfbf ._dfbgc .Relationships (){if _fddc .X ().TargetAttr ==_dcdag {_cfce =true ;break ;};};if !_cfce {_cfbf ._dfbgc .AddRelationship (_dcdag ,_f .SharedStringsType );
};};

// SetHidden hides or unhides the row
func (_ddded Row )SetHidden (hidden bool ){if !hidden {_ddded ._bgb .HiddenAttr =nil ;}else {_ddded ._bgb .HiddenAttr =_f .Bool (true );};};func (_ggd Border )SetBottom (style _bf .ST_BorderStyle ,c _de .Color ){if _ggd ._bee .Bottom ==nil {_ggd ._bee .Bottom =_bf .NewCT_BorderPr ();
};_ggd ._bee .Bottom .Color =_bf .NewCT_Color ();_ggd ._bee .Bottom .Color .RgbAttr =c .AsRGBAString ();_ggd ._bee .Bottom .StyleAttr =style ;};

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_dfbgd StyleSheet )RemoveFont (f Font )error {for _ceaf ,_gbbb :=range _dfbgd ._cafe .Fonts .Font {if _gbbb ==f .X (){_dfbgd ._cafe .Fonts .Font =append (_dfbgd ._cafe .Fonts .Font [:_ceaf ],_dfbgd ._cafe .Fonts .Font [_ceaf +1:]...);return nil ;
};};return _cda .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// GetFont gets a Font from a cell style.
func (_ddd CellStyle )GetFont ()*_bf .CT_Font {if _fga :=_ddd ._cag .FontIdAttr ;_fga !=nil {_feg :=_ddd ._dd .StyleSheet .Fonts ();if int (*_fga )< len (_feg ){return _feg [int (*_fga )].X ();};};return nil ;};

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_bggb *_bf .CT_Rst };func NewPatternFill (fills *_bf .CT_Fills )PatternFill {_fbcd :=_bf .NewCT_Fill ();_fbcd .PatternFill =_bf .NewCT_PatternFill ();return PatternFill {_fbcd .PatternFill ,_fbcd };};

// Operator returns the operator for the rule
func (_abbg ConditionalFormattingRule )Operator ()_bf .ST_ConditionalFormattingOperator {return _abbg ._aecc .OperatorAttr ;};

// SetWidth controls the width of a column.
func (_eaff Column )SetWidth (w _ad .Distance ){_eaff ._gdfd .WidthAttr =_f .Float64 (float64 (w /_ad .Character ));};

// PasswordHash returns the hash of the workbook password.
func (_bbedg WorkbookProtection )PasswordHash ()string {if _bbedg ._afbb .WorkbookPasswordAttr ==nil {return "";};return *_bbedg ._afbb .WorkbookPasswordAttr ;};

// Rows returns all of the rows in a sheet.
func (_fdaf *Sheet )Rows ()[]Row {_cdca :=[]Row {};for _ ,_cggd :=range _fdaf ._gfae .SheetData .Row {_cdca =append (_cdca ,Row {_fdaf ._fdcd ,_fdaf ,_cggd });};return _cdca ;};

// ClearProtection clears all workbook protections.
func (_acbad *Workbook )ClearProtection (){_acbad ._gceg .WorkbookProtection =nil };func (_bgcg Comments )getOrCreateAuthor (_efg string )uint32 {for _bdbd ,_cgcb :=range _bgcg ._fca .Authors .Author {if _cgcb ==_efg {return uint32 (_bdbd );};};_dde :=uint32 (len (_bgcg ._fca .Authors .Author ));
_bgcg ._fca .Authors .Author =append (_bgcg ._fca .Authors .Author ,_efg );return _dde ;};func (_agda *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _agda .getAllCellsInFormulaArrays (false );};

// X returns the inner wrapped XML type.
func (_aaag RichText )X ()*_bf .CT_Rst {return _aaag ._bggb };func (_cedc Font )SetSize (size float64 ){_cedc ._ggc .Sz =[]*_bf .CT_FontSize {{ValAttr :size }}};

// X returns the inner wrapped XML type.
func (_bceb Font )X ()*_bf .CT_Font {return _bceb ._ggc };

// SetUnderline controls if the run is underlined.
func (_gagd RichTextRun )SetUnderline (u _bf .ST_UnderlineValues ){_gagd .ensureRpr ();_gagd ._ded .RPr .U =_bf .NewCT_UnderlineProperty ();_gagd ._ded .RPr .U .ValAttr =u ;};func (_fdef RichTextRun )ensureRpr (){if _fdef ._ded .RPr ==nil {_fdef ._ded .RPr =_bf .NewCT_RPrElt ();
};};func (_gdf Cell )getLocked ()bool {if _gdf ._faa .SAttr ==nil {return false ;};_aba :=*_gdf ._faa .SAttr ;_bda :=_gdf ._aef .StyleSheet .GetCellStyle (_aba );return *_bda ._cag .Protection .LockedAttr ;};

// X returns the inner wrapped XML type.
func (_aacd Table )X ()*_bf .Table {return _aacd ._gfbgg };

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _cc .ReaderAt ,size int64 )(*Workbook ,error ){const _dacg ="\u0073\u0070r\u0065\u0061\u0064s\u0068\u0065\u0065\u0074\u003a\u0052\u0065\u0061\u0064";if !_fd .GetLicenseKey ().IsLicensed ()&&!_dfbge {_d .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");
_d .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");
return nil ,_cda .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_eafg :="\u0075n\u006b\u006e\u006f\u0077\u006e";if _eadf ,_fabc :=r .(*_ed .File );
_fabc {_eafg =_eadf .Name ();};_fdce :=New ();_ecdd ,_gac :=_fd .GenRefId ("\u0073\u0072");if _gac !=nil {_db .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gac );return nil ,_gac ;};_fdce ._fcec =_ecdd ;if _ccfb :=_fd .Track (_fdce ._fcec ,_dacg ,_eafg );
_ccfb !=nil {_db .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ccfb );return nil ,_ccfb ;};_addf ,_gac :=_fdg .TempDir ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078");if _gac !=nil {return nil ,_gac ;};
_fdce .TmpPath =_addf ;_efaa ,_gac :=_ee .NewReader (r ,size );if _gac !=nil {return nil ,_d .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_gac );};_dbfb :=[]*_ee .File {};_dbfb =append (_dbfb ,_efaa .File ...);
_acdb :=false ;for _ ,_cfa :=range _dbfb {if _cfa .FileHeader .Name =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_acdb =true ;break ;};};if _acdb {_fdce .CreateCustomProperties ();};_cdaed :=_gb .DecodeMap {};
_cdaed .SetOnNewRelationshipFunc (_fdce .onNewRelationship );_cdaed .AddTarget (_f .ContentTypesFilename ,_fdce .ContentTypes .X (),"",0);_cdaed .AddTarget (_f .BaseRelsFilename ,_fdce .Rels .X (),"",0);if _bcaa :=_cdaed .Decode (_dbfb );_bcaa !=nil {return nil ,_bcaa ;
};for _ ,_fec :=range _dbfb {if _fec ==nil {continue ;};if _cfdf :=_fdce .AddExtraFileFromZip (_fec );_cfdf !=nil {return nil ,_cfdf ;};};if _acdb {_efaf :=false ;for _ ,_bged :=range _fdce .Rels .X ().Relationship {if _bged .TargetAttr =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_efaf =true ;
break ;};};if !_efaf {_fdce .AddCustomRelationships ();};};return _fdce ,nil ;};const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);func (_ddbe Fill )Index ()uint32 {if _ddbe ._abca ==nil {return 0;};for _eff ,_gddc :=range _ddbe ._abca .Fill {if _ddbe ._fgcc ==_gddc {return uint32 (_eff );
};};return 0;};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_fgfg *Workbook )SetActiveSheetIndex (idx uint32 ){if _fgfg ._gceg .BookViews ==nil {_fgfg ._gceg .BookViews =_bf .NewCT_BookViews ();};if len (_fgfg ._gceg .BookViews .WorkbookView )==0{_fgfg ._gceg .BookViews .WorkbookView =append (_fgfg ._gceg .BookViews .WorkbookView ,_bf .NewCT_BookView ());
};_fgfg ._gceg .BookViews .WorkbookView [0].ActiveTabAttr =_f .Uint32 (idx );};

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_ace *_ac .CT_AbsoluteAnchor };

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_acbc IconScale )AddFormatValue (t _bf .ST_CfvoType ,val string ){_cdba :=_bf .NewCT_Cfvo ();_cdba .TypeAttr =t ;_cdba .ValAttr =_f .String (val );_acbc ._cfbdc .Cfvo =append (_acbc ._cfbdc .Cfvo ,_cdba );};

// ClearNumberFormat removes any number formatting from the style.
func (_eeb CellStyle )ClearNumberFormat (){_eeb ._cag .NumFmtIdAttr =nil ;_eeb ._cag .ApplyNumberFormatAttr =nil ;};

// MoveTo moves the top-left of the anchored object.
func (_cgfa OneCellAnchor )MoveTo (col ,row int32 ){_cgfa .TopLeft ().SetCol (col );_cgfa .TopLeft ().SetRow (row );};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_dbadf *Sheet )ClearCachedFormulaResults (){for _ ,_ccff :=range _dbadf .Rows (){for _ ,_acgg :=range _ccff .Cells (){if _acgg .X ().F !=nil {_acgg .X ().V =nil ;};};};};

// SetRowOffset sets the row offset of the top-left anchor.
func (_cgeaf OneCellAnchor )SetRowOffset (m _ad .Distance ){_cgeaf .TopLeft ().SetRowOffset (m )};

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_cbba SheetView )SetState (st _bf .ST_PaneState ){_cbba .ensurePane ();_cbba ._dbba .Pane .StateAttr =st ;};var _gec =[...]uint8 {0,18,37};type DifferentialStyle struct{_fgc *_bf .CT_Dxf ;_gdeg *Workbook ;_aad *_bf .CT_Dxfs ;};

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_adac *Sheet )RemoveMergedCell (mc MergedCell ){for _eeae ,_cgad :=range _adac ._gfae .MergeCells .MergeCell {if _cgad ==mc .X (){copy (_adac ._gfae .MergeCells .MergeCell [_eeae :],_adac ._gfae .MergeCells .MergeCell [_eeae +1:]);_adac ._gfae .MergeCells .MergeCell [len (_adac ._gfae .MergeCells .MergeCell )-1]=nil ;
_adac ._gfae .MergeCells .MergeCell =_adac ._gfae .MergeCells .MergeCell [:len (_adac ._gfae .MergeCells .MergeCell )-1];};};};

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_dccb *Workbook )Save (w _cc .Writer )error {const _efac ="\u0073\u0070\u0072\u0065ad\u0073\u0068\u0065\u0065\u0074\u003a\u0077\u0062\u002e\u0053\u0061\u0076\u0065";if !_fd .GetLicenseKey ().IsLicensed ()&&!_dfbge {_d .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");
_d .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");
return _cda .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_dgbb :="\u0075n\u006b\u006e\u006f\u0077\u006e";if _ecgb ,_bdacf :=w .(*_ed .File );
_bdacf {_dgbb =_ecgb .Name ();};if len (_dccb ._fcec )==0{_acfcc ,_fbge :=_fd .GenRefId ("\u0073\u0077");if _fbge !=nil {_db .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fbge );return _fbge ;};_dccb ._fcec =_acfcc ;};if _ffgfe :=_fd .Track (_dccb ._fcec ,_efac ,_dgbb );
_ffgfe !=nil {_db .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ffgfe );return _ffgfe ;};_fbcdb :=_ee .NewWriter (w );defer _fbcdb .Close ();_gfcda :=_f .DocTypeSpreadsheet ;if _adcfa :=_gb .MarshalXML (_fbcdb ,_f .BaseRelsFilename ,_dccb .Rels .X ());
_adcfa !=nil {return _adcfa ;};if _gaag :=_gb .MarshalXMLByType (_fbcdb ,_gfcda ,_f .ExtendedPropertiesType ,_dccb .AppProperties .X ());_gaag !=nil {return _gaag ;};if _gbbbc :=_gb .MarshalXMLByType (_fbcdb ,_gfcda ,_f .CorePropertiesType ,_dccb .CoreProperties .X ());
_gbbbc !=nil {return _gbbbc ;};_gegf :=_f .AbsoluteFilename (_gfcda ,_f .OfficeDocumentType ,0);if _cffb :=_gb .MarshalXML (_fbcdb ,_gegf ,_dccb ._gceg );_cffb !=nil {return _cffb ;};if _gabgb :=_gb .MarshalXML (_fbcdb ,_gb .RelationsPathFor (_gegf ),_dccb ._dfbgc .X ());
_gabgb !=nil {return _gabgb ;};if _cdbae :=_gb .MarshalXMLByType (_fbcdb ,_gfcda ,_f .StylesType ,_dccb .StyleSheet .X ());_cdbae !=nil {return _cdbae ;};for _edca ,_egccc :=range _dccb ._accb {if _eeba :=_gb .MarshalXMLByTypeIndex (_fbcdb ,_gfcda ,_f .ThemeType ,_edca +1,_egccc );
_eeba !=nil {return _eeba ;};};for _edgd ,_dbgf :=range _dccb ._bfbb {_dbgf .Dimension .RefAttr =Sheet {_dccb ,nil ,_dbgf }.Extents ();_bacb :=_f .AbsoluteFilename (_gfcda ,_f .WorksheetType ,_edgd +1);_gb .MarshalXML (_fbcdb ,_bacb ,_dbgf );_gb .MarshalXML (_fbcdb ,_gb .RelationsPathFor (_bacb ),_dccb ._cfac [_edgd ].X ());
};if _eaeba :=_gb .MarshalXMLByType (_fbcdb ,_gfcda ,_f .SharedStringsType ,_dccb .SharedStrings .X ());_eaeba !=nil {return _eaeba ;};if _dccb .CustomProperties .X ()!=nil {if _dage :=_gb .MarshalXMLByType (_fbcdb ,_gfcda ,_f .CustomPropertiesType ,_dccb .CustomProperties .X ());
_dage !=nil {return _dage ;};};if _dccb .Thumbnail !=nil {_agc :=_f .AbsoluteFilename (_gfcda ,_f .ThumbnailType ,0);_fagf ,_bffd :=_fbcdb .Create (_agc );if _bffd !=nil {return _bffd ;};if _deaf :=_c .Encode (_fagf ,_dccb .Thumbnail ,nil );_deaf !=nil {return _deaf ;
};};for _edbd ,_cdfa :=range _dccb ._ebfc {_fadfb :=_f .AbsoluteFilename (_gfcda ,_f .ChartType ,_edbd +1);_gb .MarshalXML (_fbcdb ,_fadfb ,_cdfa );};for _gbbbf ,_beeba :=range _dccb ._efege {_bacc :=_f .AbsoluteFilename (_gfcda ,_f .TableType ,_gbbbf +1);
_gb .MarshalXML (_fbcdb ,_bacc ,_beeba );};for _dbga ,_ggbced :=range _dccb ._gaffb {_bgcac :=_f .AbsoluteFilename (_gfcda ,_f .DrawingType ,_dbga +1);_gb .MarshalXML (_fbcdb ,_bgcac ,_ggbced );if !_dccb ._effga [_dbga ].IsEmpty (){_gb .MarshalXML (_fbcdb ,_gb .RelationsPathFor (_bgcac ),_dccb ._effga [_dbga ].X ());
};};for _aagd ,_cegf :=range _dccb ._dcefg {_gb .MarshalXML (_fbcdb ,_f .AbsoluteFilename (_gfcda ,_f .VMLDrawingType ,_aagd +1),_cegf );};for _eadea ,_cbcaf :=range _dccb .Images {if _aacg :=_fg .AddImageToZip (_fbcdb ,_cbcaf ,_eadea +1,_f .DocTypeSpreadsheet );
_aacg !=nil {return _aacg ;};};if _ccad :=_gb .MarshalXML (_fbcdb ,_f .ContentTypesFilename ,_dccb .ContentTypes .X ());_ccad !=nil {return _ccad ;};for _befea ,_bfef :=range _dccb ._gbfe {if _bfef ==nil {continue ;};_gb .MarshalXML (_fbcdb ,_f .AbsoluteFilename (_gfcda ,_f .CommentsType ,_befea +1),_bfef );
};if _adeb :=_dccb .WriteExtraFiles (_fbcdb );_adeb !=nil {return _adeb ;};return _fbcdb .Close ();};const _bfg ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_bfc Cell )SetString (s string )int {_bfc ._aef .ensureSharedStringsRelationships ();_bfc .clearValue ();_cdab :=_bfc ._aef .SharedStrings .AddString (s );_bfc ._faa .V =_f .String (_ff .Itoa (_cdab ));_bfc ._faa .TAttr =_bf .ST_CellTypeS ;return _cdab ;
};

// GetValueAsBool retrieves the cell's value as a boolean
func (_deb Cell )GetValueAsBool ()(bool ,error ){if _deb ._faa .TAttr !=_bf .ST_CellTypeB {return false ,_cda .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");
};if _deb ._faa .V ==nil {return false ,_cda .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _ff .ParseBool (*_deb ._faa .V );};

// Comments returns the comments for a sheet.
func (_egcc *Sheet )Comments ()Comments {for _bbgeb ,_fcbg :=range _egcc ._fdcd ._bfbb {if _fcbg ==_egcc ._gfae {if _egcc ._fdcd ._gbfe [_bbgeb ]==nil {_egcc ._fdcd ._gbfe [_bbgeb ]=_bf .NewComments ();_egcc ._fdcd ._cfac [_bbgeb ].AddAutoRelationship (_f .DocTypeSpreadsheet ,_f .WorksheetType ,_bbgeb +1,_f .CommentsType );
_egcc ._fdcd .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .CommentsType ,_bbgeb +1),_f .CommentsContentType );};if len (_egcc ._fdcd ._dcefg )==0{_egcc ._fdcd ._dcefg =append (_egcc ._fdcd ._dcefg ,_ce .NewCommentDrawing ());
_gcbf :=_egcc ._fdcd ._cfac [_bbgeb ].AddAutoRelationship (_f .DocTypeSpreadsheet ,_f .WorksheetType ,1,_f .VMLDrawingType );if _egcc ._gfae .LegacyDrawing ==nil {_egcc ._gfae .LegacyDrawing =_bf .NewCT_LegacyDrawing ();};_egcc ._gfae .LegacyDrawing .IdAttr =_gcbf .ID ();
};return Comments {_egcc ._fdcd ,_egcc ._fdcd ._gbfe [_bbgeb ]};};};_db .Log .Debug ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");
return Comments {};};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_ccfc Sheet )RangeReference (n string )string {_gebg :=_cb .Split (n ,"\u003a");_gfe ,_ :=_dg .ParseCellReference (_gebg [0]);_dcde :=_d .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_gfe .Column ,_gfe .RowIdx );if len (_gebg )==1{return _d .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_ccfc .Name (),_dcde );
};_bead ,_ :=_dg .ParseCellReference (_gebg [1]);_ccbb :=_d .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_bead .Column ,_bead .RowIdx );return _d .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_ccfc .Name (),_dcde ,_ccbb );
};

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_cbge TwoCellAnchor )SetHeightCells (h int32 ){_cbge .SetHeight (0);_eadbd :=_cbge .TopLeft ();_bdfd :=_cbge .BottomRight ();_bdfd .SetRow (_eadbd .Row ()+h );};

// SetIcons sets the icon set to use for display.
func (_ggeb IconScale )SetIcons (t _bf .ST_IconSetType ){_ggeb ._cfbdc .IconSetAttr =t };

// AddHyperlink creates and sets a hyperlink on a cell.
func (_eee Cell )AddHyperlink (url string ){for _dbaf ,_afgb :=range _eee ._aef ._bfbb {if _afgb ==_eee ._bbc ._gfae {_eee .SetHyperlink (_eee ._aef ._cfac [_dbaf ].AddHyperlink (url ));return ;};};};

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_faae :=_bf .NewStyleSheet ();_faae .CellStyleXfs =_bf .NewCT_CellStyleXfs ();_faae .CellXfs =_bf .NewCT_CellXfs ();_faae .CellStyles =_bf .NewCT_CellStyles ();_cdbcb :=_bf .NewCT_CellStyle ();_cdbcb .NameAttr =_f .String ("\u004e\u006f\u0072\u006d\u0061\u006c");
_cdbcb .XfIdAttr =0;_cdbcb .BuiltinIdAttr =_f .Uint32 (0);_faae .CellStyles .CellStyle =append (_faae .CellStyles .CellStyle ,_cdbcb );_faae .CellStyles .CountAttr =_f .Uint32 (uint32 (len (_faae .CellStyles .CellStyle )));_abba :=_bf .NewCT_Xf ();_abba .NumFmtIdAttr =_f .Uint32 (0);
_abba .FontIdAttr =_f .Uint32 (0);_abba .FillIdAttr =_f .Uint32 (0);_abba .BorderIdAttr =_f .Uint32 (0);_faae .CellStyleXfs .Xf =append (_faae .CellStyleXfs .Xf ,_abba );_faae .CellStyleXfs .CountAttr =_f .Uint32 (uint32 (len (_faae .CellStyleXfs .Xf )));
_aafbd :=NewFills ();_faae .Fills =_aafbd .X ();_fgdbfb :=_aafbd .appendFill ().SetPatternFill ();_fgdbfb .SetPattern (_bf .ST_PatternTypeNone );_fgdbfb =_aafbd .appendFill ().SetPatternFill ();_fgdbfb .SetPattern (_bf .ST_PatternTypeGray125 );_faae .Fonts =_bf .NewCT_Fonts ();
_faae .Borders =_bf .NewCT_Borders ();_ffad :=StyleSheet {wb ,_faae };_ffad .appendBorder ().InitializeDefaults ();_ggfc :=_ffad .appendFont ();_ggfc .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_ggfc .SetSize (11);_ddc :=_bf .NewCT_Xf ();*_ddc =*_abba ;
_ddc .XfIdAttr =_f .Uint32 (0);_faae .CellXfs .Xf =append (_faae .CellXfs .Xf ,_ddc );_faae .CellXfs .CountAttr =_f .Uint32 (uint32 (len (_faae .CellXfs .Xf )));return _ffad ;};

// HasFormula returns true if the cell contains formula.
func (_cce *evalContext )HasFormula (cellRef string )bool {return _cce ._gaa .Cell (cellRef ).HasFormula ()};

// IsDBCS returns if a workbook's default language is among DBCS.
func (_ffg *evalContext )IsDBCS ()bool {_aac :=_ffg ._gaa ._fdcd .CoreProperties .X ().Language ;if _aac ==nil {return false ;};_fceg :=string (_aac .Data );for _ ,_fbcg :=range _dcef {if _fceg ==_fbcg {return true ;};};return false ;};var _dfbge =false ;


// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_ddag *Sheet )SetBorder (cellRange string ,border Border )error {_gabd ,_bffa ,_bccc :=_dg .ParseRangeReference (cellRange );if _bccc !=nil {return _bccc ;};_cfg :=_ddag ._fdcd .StyleSheet .AddCellStyle ();_eecd :=_ddag ._fdcd .StyleSheet .AddBorder ();
_cfg .SetBorder (_eecd );_eecd ._bee .Top =border ._bee .Top ;_eecd ._bee .Left =border ._bee .Left ;_aedd :=_ddag ._fdcd .StyleSheet .AddCellStyle ();_egff :=_ddag ._fdcd .StyleSheet .AddBorder ();_aedd .SetBorder (_egff );_egff ._bee .Top =border ._bee .Top ;
_egff ._bee .Right =border ._bee .Right ;_cdcc :=_ddag ._fdcd .StyleSheet .AddCellStyle ();_agfa :=_ddag ._fdcd .StyleSheet .AddBorder ();_cdcc .SetBorder (_agfa );_agfa ._bee .Top =border ._bee .Top ;_acbdf :=_ddag ._fdcd .StyleSheet .AddCellStyle ();
_fgee :=_ddag ._fdcd .StyleSheet .AddBorder ();_acbdf .SetBorder (_fgee );_fgee ._bee .Left =border ._bee .Left ;_cdfgg :=_ddag ._fdcd .StyleSheet .AddCellStyle ();_cgbc :=_ddag ._fdcd .StyleSheet .AddBorder ();_cdfgg .SetBorder (_cgbc );_cgbc ._bee .Right =border ._bee .Right ;
_daaec :=_ddag ._fdcd .StyleSheet .AddCellStyle ();_fbad :=_ddag ._fdcd .StyleSheet .AddBorder ();_daaec .SetBorder (_fbad );_fbad ._bee .Bottom =border ._bee .Bottom ;_abaag :=_ddag ._fdcd .StyleSheet .AddCellStyle ();_edcd :=_ddag ._fdcd .StyleSheet .AddBorder ();
_abaag .SetBorder (_edcd );_edcd ._bee .Bottom =border ._bee .Bottom ;_edcd ._bee .Left =border ._bee .Left ;_bfag :=_ddag ._fdcd .StyleSheet .AddCellStyle ();_affb :=_ddag ._fdcd .StyleSheet .AddBorder ();_bfag .SetBorder (_affb );_affb ._bee .Bottom =border ._bee .Bottom ;
_affb ._bee .Right =border ._bee .Right ;_ccgb :=_gabd .RowIdx ;_gcabc :=_gabd .ColumnIdx ;_ebcf :=_bffa .RowIdx ;_cgadg :=_bffa .ColumnIdx ;for _addfd :=_ccgb ;_addfd <=_ebcf ;_addfd ++{for _ggbce :=_gcabc ;_ggbce <=_cgadg ;_ggbce ++{_agafg :=_d .Sprintf ("\u0025\u0073\u0025\u0064",_dg .IndexToColumn (_ggbce ),_addfd );
switch {case _addfd ==_ccgb &&_ggbce ==_gcabc :_ddag .Cell (_agafg ).SetStyle (_cfg );case _addfd ==_ccgb &&_ggbce ==_cgadg :_ddag .Cell (_agafg ).SetStyle (_aedd );case _addfd ==_ebcf &&_ggbce ==_gcabc :_ddag .Cell (_agafg ).SetStyle (_abaag );case _addfd ==_ebcf &&_ggbce ==_cgadg :_ddag .Cell (_agafg ).SetStyle (_bfag );
case _addfd ==_ccgb :_ddag .Cell (_agafg ).SetStyle (_cdcc );case _addfd ==_ebcf :_ddag .Cell (_agafg ).SetStyle (_daaec );case _ggbce ==_gcabc :_ddag .Cell (_agafg ).SetStyle (_acbdf );case _ggbce ==_cgadg :_ddag .Cell (_agafg ).SetStyle (_cdfgg );};};
};return nil ;};

// LockSheet controls the locking of the sheet.
func (_dcfc SheetProtection )LockSheet (b bool ){if !b {_dcfc ._aege .SheetAttr =nil ;}else {_dcfc ._aege .SheetAttr =_f .Bool (true );};};

// GetWidth returns a worksheet's column width.
func (_cefb *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_fefc :=range _cefb ._gaa .X ().Cols [0].Col {if int (_fefc .MinAttr )<=colIdx &&colIdx <=int (_fefc .MaxAttr ){return float64 (int (*_fefc .WidthAttr ));};};return 0;};

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_gfdf *Sheet )SetDrawing (d Drawing ){var _bgcc _fg .Relationships ;for _ceae ,_caff :=range _gfdf ._fdcd ._bfbb {if _caff ==_gfdf ._gfae {_bgcc =_gfdf ._fdcd ._cfac [_ceae ];break ;};};var _aagg string ;for _agfc ,_cabf :=range d ._ecb ._gaffb {if _cabf ==d ._adg {_effg :=_bgcc .AddAutoRelationship (_f .DocTypeSpreadsheet ,_f .WorksheetType ,_agfc +1,_f .DrawingType );
_aagg =_effg .ID ();break ;};};_gfdf ._gfae .Drawing =_bf .NewCT_Drawing ();_gfdf ._gfae .Drawing .IdAttr =_aagg ;};func (_edfd DataValidation )SetList ()DataValidationList {_edfd .clear ();_edfd ._aabc .TypeAttr =_bf .ST_DataValidationTypeList ;_edfd ._aabc .OperatorAttr =_bf .ST_DataValidationOperatorEqual ;
return DataValidationList {_edfd ._aabc };};func (_ccg Cell )clearValue (){_ccg ._faa .F =nil ;_ccg ._faa .Is =nil ;_ccg ._faa .V =nil ;_ccg ._faa .TAttr =_bf .ST_CellTypeUnset ;};

// SetFont sets the font name for a rich text run.
func (_fdgd RichTextRun )SetFont (s string ){_fdgd .ensureRpr ();_fdgd ._ded .RPr .RFont =_bf .NewCT_FontName ();_fdgd ._ded .RPr .RFont .ValAttr =s ;};type Fills struct{_dccc *_bf .CT_Fills };func (_ccga Cell )GetRawValue ()(string ,error ){switch _ccga ._faa .TAttr {case _bf .ST_CellTypeInlineStr :if _ccga ._faa .Is ==nil ||_ccga ._faa .Is .T ==nil {return "",nil ;
};return *_ccga ._faa .Is .T ,nil ;case _bf .ST_CellTypeS :if _ccga ._faa .V ==nil {return "",nil ;};_bcgd ,_adc :=_ff .Atoi (*_ccga ._faa .V );if _adc !=nil {return "",_adc ;};return _ccga ._aef .SharedStrings .GetString (_bcgd );case _bf .ST_CellTypeStr :if _ccga ._faa .F !=nil {return _ccga ._faa .F .Content ,nil ;
};};if _ccga ._faa .V ==nil {return "",nil ;};return *_ccga ._faa .V ,nil ;};

// SetPasswordHash sets the password hash to the input.
func (_febd WorkbookProtection )SetPasswordHash (pwHash string ){_febd ._afbb .WorkbookPasswordAttr =_f .String (pwHash );};

// SetFormat sets the number format code.
func (_gafc NumberFormat )SetFormat (f string ){_gafc ._badc .FormatCodeAttr =f };

// AddBorder creates a new empty Border style.
func (_dgfd StyleSheet )AddBorder ()Border {_gbbg :=_bf .NewCT_Border ();return Border {_gbbg ,_dgfd ._cafe .Borders };};

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_aaf CellStyle )SetVerticalAlignment (a _bf .ST_VerticalAlignment ){if _aaf ._cag .Alignment ==nil {_aaf ._cag .Alignment =_bf .NewCT_CellAlignment ();};_aaf ._cag .ApplyAlignmentAttr =_f .Bool (true );_aaf ._cag .Alignment .VerticalAttr =a ;};

// X returns the inner wrapped XML type.
func (_aff CellMarker )X ()*_ac .CT_Marker {return _aff ._dbc };

// SetPassword sets the password hash to a hash of the input password.
func (_fgdfg SheetProtection )SetPassword (pw string ){_fgdfg .SetPasswordHash (PasswordHash (pw ))};

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_bbga *_bf .CT_DataValidation };

// X returns the inner wrapped XML type.
func (_efgc SheetProtection )X ()*_bf .CT_SheetProtection {return _efgc ._aege };

// X returns the inner wrapped XML type.
func (_gbdb Comments )X ()*_bf .Comments {return _gbdb ._fca };

// SetColor sets the text color.
func (_dab RichTextRun )SetColor (c _de .Color ){_dab .ensureRpr ();_dab ._ded .RPr .Color =_bf .NewCT_Color ();_ecbc :="\u0066\u0066"+*c .AsRGBString ();_dab ._ded .RPr .Color .RgbAttr =&_ecbc ;};func (_fbeb *Sheet )setShared (_dfdf string ,_gaae ,_gceee _dg .CellReference ,_gedf string ){_ceddb :=_fbeb .FormulaContext ();
_bcgb :=_ca .NewEvaluator ();for _cbca :=_gaae .RowIdx ;_cbca <=_gceee .RowIdx ;_cbca ++{for _dfg :=_gaae .ColumnIdx ;_dfg <=_gceee .ColumnIdx ;_dfg ++{_beed :=_cbca -_gaae .RowIdx ;_fbab :=_dfg -_gaae .ColumnIdx ;_ceddb .SetOffset (_fbab ,_beed );_gbdgb :=_bcgb .Eval (_ceddb ,_gedf );
_facb :=_d .Sprintf ("\u0025\u0073\u0025\u0064",_dg .IndexToColumn (_dfg ),_cbca );_dgdf :=_fbeb .Cell (_facb );if _gbdgb .Type ==_ca .ResultTypeNumber {_dgdf .X ().TAttr =_bf .ST_CellTypeN ;}else {_dgdf .X ().TAttr =_bf .ST_CellTypeInlineStr ;};_dgdf .X ().V =_f .String (_gbdgb .Value ());
};};_ =_bcgb ;_ =_ceddb ;};

// AnchorType is the type of anchor.
type AnchorType byte ;

// SetColOffset sets the column offset of the two cell anchor.
func (_acgb TwoCellAnchor )SetColOffset (m _ad .Distance ){_badcb :=m -_acgb .TopLeft ().ColOffset ();_acgb .TopLeft ().SetColOffset (m );_acgb .BottomRight ().SetColOffset (_acgb .BottomRight ().ColOffset ()+_badcb );};func (_abg *Sheet )updateAfterRemove (_abec uint32 ,_bagb _cf .UpdateAction )error {_befe :=_abg .Name ();
_adae :=&_cf .UpdateQuery {UpdateType :_bagb ,ColumnIdx :_abec ,SheetToUpdate :_befe };for _ ,_debe :=range _abg ._fdcd .Sheets (){_adae .UpdateCurrentSheet =_befe ==_debe .Name ();for _ ,_egdg :=range _debe .Rows (){for _ ,_gebd :=range _egdg .Cells (){if _gebd .X ().F !=nil {_effc :=_gebd .X ().F .Content ;
_dced :=_ca .ParseString (_effc );if _dced ==nil {_gebd .SetError ("\u0023\u0052\u0045F\u0021");}else {_ecdfg :=_dced .Update (_adae );_gebd .X ().F .Content =_d .Sprintf ("\u003d\u0025\u0073",_ecdfg .String ());};};};};};return nil ;};

// SetWrapped configures the cell to wrap text.
func (_fdf CellStyle )SetWrapped (b bool ){if _fdf ._cag .Alignment ==nil {_fdf ._cag .Alignment =_bf .NewCT_CellAlignment ();};if !b {_fdf ._cag .Alignment .WrapTextAttr =nil ;}else {_fdf ._cag .Alignment .WrapTextAttr =_f .Bool (true );_fdf ._cag .ApplyAlignmentAttr =_f .Bool (true );
};};func _fdc (_fde string )bool {_fde =_cb .Replace (_fde ,"\u0024","",-1);if _fda :=_acc .FindStringSubmatch (_cb .ToLower (_fde ));len (_fda )> 2{_cegb :=_fda [1];_ggba ,_abc :=_ff .Atoi (_fda [2]);if _abc !=nil {return false ;};return _ggba <=1048576&&_cegb <="\u007a\u007a";
};return false ;};

// AddFormatValue adds a format value (databars require two).
func (_bdg DataBarScale )AddFormatValue (t _bf .ST_CfvoType ,val string ){_cfdb :=_bf .NewCT_Cfvo ();_cfdb .TypeAttr =t ;_cfdb .ValAttr =_f .String (val );_bdg ._gbc .Cfvo =append (_bdg ._gbc .Cfvo ,_cfdb );};

// WorkbookText is an array of extracted text items which has some methods for representing extracted text from a workbook.
type WorkbookText struct{Sheets []*SheetText ;};

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_adda StyleSheet )AddNumberFormat ()NumberFormat {if _adda ._cafe .NumFmts ==nil {_adda ._cafe .NumFmts =_bf .NewCT_NumFmts ();};_cccb :=_bf .NewCT_NumFmt ();_cccb .NumFmtIdAttr =uint32 (200+len (_adda ._cafe .NumFmts .NumFmt ));_adda ._cafe .NumFmts .NumFmt =append (_adda ._cafe .NumFmts .NumFmt ,_cccb );
_adda ._cafe .NumFmts .CountAttr =_f .Uint32 (uint32 (len (_adda ._cafe .NumFmts .NumFmt )));return NumberFormat {_adda ._faceb ,_cccb };};

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_cdaga *Workbook )SetActiveSheet (s Sheet ){for _cecfc ,_dggde :=range _cdaga ._bfbb {if s ._gfae ==_dggde {_cdaga .SetActiveSheetIndex (uint32 (_cecfc ));};};};

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_febe *Sheet )AddNumberedRow (rowNum uint32 )Row {_bbge :=_bf .NewCT_Row ();_bbge .RAttr =_f .Uint32 (rowNum );_febe ._gfae .SheetData .Row =append (_febe ._gfae .SheetData .Row ,_bbge );_cd .Slice (_febe ._gfae .SheetData .Row ,func (_fgdd ,_fbbb int )bool {_dfc :=_febe ._gfae .SheetData .Row [_fgdd ].RAttr ;
_bebea :=_febe ._gfae .SheetData .Row [_fbbb ].RAttr ;if _dfc ==nil {return true ;};if _bebea ==nil {return true ;};return *_dfc < *_bebea ;});return Row {_febe ._fdcd ,_febe ,_bbge };};

// DefinedNames returns a slice of all defined names in the workbook.
func (_efcf *Workbook )DefinedNames ()[]DefinedName {if _efcf ._gceg .DefinedNames ==nil {return nil ;};_fbbc :=[]DefinedName {};for _ ,_babf :=range _efcf ._gceg .DefinedNames .DefinedName {_fbbc =append (_fbbc ,DefinedName {_babf });};return _fbbc ;};


// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_dddc DataValidationList )SetRange (cellRange string ){_dddc ._cabg .Formula1 =_f .String (cellRange );_dddc ._cabg .Formula2 =_f .String ("\u0030");};

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_fdbb Cell )GetString ()string {switch _fdbb ._faa .TAttr {case _bf .ST_CellTypeInlineStr :if _fdbb ._faa .Is !=nil &&_fdbb ._faa .Is .T !=nil {return *_fdbb ._faa .Is .T ;};if _fdbb ._faa .V !=nil {return *_fdbb ._faa .V ;};case _bf .ST_CellTypeS :if _fdbb ._faa .V ==nil {return "";
};_bce ,_dgd :=_ff .Atoi (*_fdbb ._faa .V );if _dgd !=nil {return "";};_afe ,_dgd :=_fdbb ._aef .SharedStrings .GetString (_bce );if _dgd !=nil {return "";};return _afe ;};if _fdbb ._faa .V ==nil {return "";};return *_fdbb ._faa .V ;};

// SetOperator sets the operator for the rule.
func (_gae ConditionalFormattingRule )SetOperator (t _bf .ST_ConditionalFormattingOperator ){_gae ._aecc .OperatorAttr =t ;};

// SetHeight sets the height of the anchored object.
func (_bdc AbsoluteAnchor )SetHeight (h _ad .Distance ){_bdc ._ace .Ext .CyAttr =int64 (h /_ad .EMU )};

// SetSize sets the text size for a rich text run.
func (_efga RichTextRun )SetSize (m _ad .Distance ){_efga .ensureRpr ();_efga ._ded .RPr .Sz =_bf .NewCT_FontSize ();_efga ._ded .RPr .Sz .ValAttr =float64 (m /_ad .Point );};

// X returns the inner wrapped XML type.
func (_gfbg IconScale )X ()*_bf .CT_IconSet {return _gfbg ._cfbdc };func _dcd (_bcbb bool )int {if _bcbb {return 1;};return 0;};

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_eebf Comment )SetCellReference (cellRef string ){_eebf ._cdeg .RefAttr =cellRef };

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_fafa *evalContext )LastColumn (rowFrom ,rowTo int )string {_fbee :=_fafa ._gaa ;_cddf :=1;for _fggg :=rowFrom ;_fggg <=rowTo ;_fggg ++{_cefa :=len (_fbee .Row (uint32 (_fggg )).Cells ());if _cefa > _cddf {_cddf =_cefa ;};};return _dg .IndexToColumn (uint32 (_cddf -1));
};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_cfag Row )RowNumber ()uint32 {if _cfag ._bgb .RAttr !=nil {return *_cfag ._bgb .RAttr ;};return 0;};

// SetHeight sets the height of the anchored object.
func (_gcbe OneCellAnchor )SetHeight (h _ad .Distance ){_gcbe ._gfga .Ext .CyAttr =int64 (h /_ad .EMU )};

// HasFormula returns true if the cell has an asoociated formula.
func (_acfe Cell )HasFormula ()bool {return _acfe ._faa .F !=nil };

// GetString retrieves a string from the shared strings table by index.
func (_gcaa SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_d .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );
};if id > len (_gcaa ._cgac .Si )-1{return "",_d .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_gcaa ._cgac .Si ));
};_gcgg :=_gcaa ._cgac .Si [id ];if _gcgg .T !=nil {return *_gcgg .T ,nil ;};_fgae :="";for _ ,_bbggb :=range _gcgg .R {if _bbggb .T !=""{_fgae +=_bbggb .T ;};};return _fgae ,nil ;};

// X returns the inner wrapped XML type.
func (_eed RichTextRun )X ()*_bf .CT_RElt {return _eed ._ded };func (_cfade *Sheet )removeColumnFromMergedCells (_efca uint32 )error {if _cfade ._gfae .MergeCells ==nil ||_cfade ._gfae .MergeCells .MergeCell ==nil {return nil ;};_aadc :=[]*_bf .CT_MergeCell {};
for _ ,_cede :=range _cfade .MergedCells (){_daeg :=_gdfc (_cede .Reference (),_efca ,true );if _daeg !=""{_cede .SetReference (_daeg );_aadc =append (_aadc ,_cede .X ());};};_cfade ._gfae .MergeCells .MergeCell =_aadc ;return nil ;};

// IsSheetLocked returns whether the sheet is locked.
func (_fbgc SheetProtection )IsSheetLocked ()bool {return _fbgc ._aege .SheetAttr !=nil &&*_fbgc ._aege .SheetAttr ;};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_dcce *_bf .CT_DefinedName };func NewFills ()Fills {return Fills {_bf .NewCT_Fills ()}};

// SheetCount returns the number of sheets in the workbook.
func (_fdff Workbook )SheetCount ()int {return len (_fdff ._bfbb )};

// SetPasswordHash sets the password hash to the input.
func (_fgbf SheetProtection )SetPasswordHash (pwHash string ){_fgbf ._aege .PasswordAttr =_f .String (pwHash );};

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_bggbe *Workbook )Epoch ()_cg .Time {if _bggbe .Uses1904Dates (){_cg .Date (1904,1,1,0,0,0,0,_cg .UTC );};return _cg .Date (1899,12,30,0,0,0,0,_cg .UTC );};

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_cdb Cell )GetValueAsTime ()(_cg .Time ,error ){if _cdb ._faa .TAttr !=_bf .ST_CellTypeUnset {return _cg .Time {},_cda .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");
};if _cdb ._faa .V ==nil {return _cg .Time {},_cda .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_fae ,_ ,_ceef :=_fa .ParseFloat (*_cdb ._faa .V ,10,128,_fa .ToNearestEven );if _ceef !=nil {return _cg .Time {},_ceef ;
};_agg :=new (_fa .Float );_agg .SetUint64 (uint64 (24*_cg .Hour ));_fae .Mul (_fae ,_agg );_cdf ,_ :=_fae .Uint64 ();_cegc :=_cdb ._aef .Epoch ().Add (_cg .Duration (_cdf ));return _cec (_cegc ),nil ;};

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_cgac :_bf .NewSst (),_dedg :make (map[string ]int )};};

// RemoveSheet removes the sheet with the given index from the workbook.
func (_gfdg *Workbook )RemoveSheet (ind int )error {if _gfdg .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_bdgc :=range _gfdg ._dfbgc .Relationships (){if _bdgc .ID ()==_gfdg ._gceg .Sheets .Sheet [ind ].IdAttr {_gfdg ._dfbgc .Remove (_bdgc );break ;
};};_gfdg .ContentTypes .RemoveOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .WorksheetContentType ,ind +1));copy (_gfdg ._bfbb [ind :],_gfdg ._bfbb [ind +1:]);_gfdg ._bfbb =_gfdg ._bfbb [:len (_gfdg ._bfbb )-1];_fgccb :=_gfdg ._gceg .Sheets .Sheet [ind ];
copy (_gfdg ._gceg .Sheets .Sheet [ind :],_gfdg ._gceg .Sheets .Sheet [ind +1:]);_gfdg ._gceg .Sheets .Sheet =_gfdg ._gceg .Sheets .Sheet [:len (_gfdg ._gceg .Sheets .Sheet )-1];for _abacd :=range _gfdg ._gceg .Sheets .Sheet {if _gfdg ._gceg .Sheets .Sheet [_abacd ].SheetIdAttr > _fgccb .SheetIdAttr {_gfdg ._gceg .Sheets .Sheet [_abacd ].SheetIdAttr --;
};};copy (_gfdg ._cfac [ind :],_gfdg ._cfac [ind +1:]);_gfdg ._cfac =_gfdg ._cfac [:len (_gfdg ._cfac )-1];copy (_gfdg ._gbfe [ind :],_gfdg ._gbfe [ind +1:]);_gfdg ._gbfe =_gfdg ._gbfe [:len (_gfdg ._gbfe )-1];return nil ;};func (_ggf Sheet )validateMergedCells ()error {_gfgc :=map[uint64 ]struct{}{};
for _ ,_daae :=range _ggf .MergedCells (){_babg ,_eedg ,_afgf :=_dg .ParseRangeReference (_daae .Reference ());if _afgf !=nil {return _d .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_ggf .Name (),_daae .Reference ());
};for _age :=_babg .RowIdx ;_age <=_eedg .RowIdx ;_age ++{for _fbaf :=_babg .ColumnIdx ;_fbaf <=_eedg .ColumnIdx ;_fbaf ++{_cgde :=uint64 (_age )<<32|uint64 (_fbaf );if _ ,_gea :=_gfgc [_cgde ];_gea {return _d .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_ggf .Name ());
};_gfgc [_cgde ]=struct{}{};};};};return nil ;};type ConditionalFormattingRule struct{_aecc *_bf .CT_CfRule };

// X returns the inner wrapped XML type.
func (_dccde SheetView )X ()*_bf .CT_SheetView {return _dccde ._dbba };

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_ecab *Sheet )RecalculateFormulas (){_acfg :=_ca .NewEvaluator ();_eacg :=_ecab .FormulaContext ();for _ ,_cdabe :=range _ecab .Rows (){for _ ,_bgf :=range _cdabe .Cells (){if _bgf .X ().F !=nil {_eagc :=_bgf .X ().F .Content ;if _bgf .X ().F .TAttr ==_bf .ST_CellFormulaTypeShared &&len (_eagc )==0{continue ;
};_gcgbd :=_acfg .Eval (_eacg ,_eagc ).AsString ();if _gcgbd .Type ==_ca .ResultTypeError {_db .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_eagc ,_gcgbd .ErrorMessage );
_bgf .X ().V =nil ;}else {if _gcgbd .Type ==_ca .ResultTypeNumber {_bgf .X ().TAttr =_bf .ST_CellTypeN ;}else {_bgf .X ().TAttr =_bf .ST_CellTypeInlineStr ;};_bgf .X ().V =_f .String (_gcgbd .Value ());if _bgf .X ().F .TAttr ==_bf .ST_CellFormulaTypeArray {if _gcgbd .Type ==_ca .ResultTypeArray {_ecab .setArray (_bgf .Reference (),_gcgbd );
}else if _gcgbd .Type ==_ca .ResultTypeList {_ecab .setList (_bgf .Reference (),_gcgbd );};}else if _bgf .X ().F .TAttr ==_bf .ST_CellFormulaTypeShared &&_bgf .X ().F .RefAttr !=nil {_gbdbf ,_caee ,_acdg :=_dg .ParseRangeReference (*_bgf .X ().F .RefAttr );
if _acdg !=nil {_db .Log .Debug ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_acdg );continue ;};
_ecab .setShared (_bgf .Reference (),_gbdbf ,_caee ,_eagc );};};};};};};

// RemoveDefinedName removes an existing defined name.
func (_fcg *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _cda .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");
};for _cagb ,_dafa :=range _fcg ._gceg .DefinedNames .DefinedName {if _dafa ==dn .X (){copy (_fcg ._gceg .DefinedNames .DefinedName [_cagb :],_fcg ._gceg .DefinedNames .DefinedName [_cagb +1:]);_fcg ._gceg .DefinedNames .DefinedName [len (_fcg ._gceg .DefinedNames .DefinedName )-1]=nil ;
_fcg ._gceg .DefinedNames .DefinedName =_fcg ._gceg .DefinedNames .DefinedName [:len (_fcg ._gceg .DefinedNames .DefinedName )-1];return nil ;};};return _cda .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");
};

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_ggg DataValidationCompare )SetValue (v string ){_ggg ._bbga .Formula1 =&v };

// AddMergedCells merges cells within a sheet.
func (_gcgb *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _gcgb ._gfae .MergeCells ==nil {_gcgb ._gfae .MergeCells =_bf .NewCT_MergeCells ();};_gabg :=_bf .NewCT_MergeCell ();_gabg .RefAttr =_d .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );
_gcgb ._gfae .MergeCells .MergeCell =append (_gcgb ._gfae .MergeCells .MergeCell ,_gabg );_gcgb ._gfae .MergeCells .CountAttr =_f .Uint32 (uint32 (len (_gcgb ._gfae .MergeCells .MergeCell )));return MergedCell {_gcgb ._fdcd ,_gcgb ,_gabg };};const (StandardFormatGeneral StandardFormat =0;
StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;
StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;
StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;
StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;
StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;);

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_dbad *Sheet )AddRow ()Row {_edag :=uint32 (0);_dabc :=uint32 (len (_dbad ._gfae .SheetData .Row ));if _dabc > 0&&_dbad ._gfae .SheetData .Row [_dabc -1].RAttr !=nil &&*_dbad ._gfae .SheetData .Row [_dabc -1].RAttr ==_dabc {return _dbad .addNumberedRowFast (_dabc +1);
};for _ ,_dbec :=range _dbad ._gfae .SheetData .Row {if _dbec .RAttr !=nil &&*_dbec .RAttr > _edag {_edag =*_dbec .RAttr ;};};return _dbad .AddNumberedRow (_edag +1);};

// MoveTo is a no-op.
func (_ba AbsoluteAnchor )MoveTo (x ,y int32 ){};

// MergedCells returns the merged cell regions within the sheet.
func (_fadf *Sheet )MergedCells ()[]MergedCell {if _fadf ._gfae .MergeCells ==nil {return nil ;};_ega :=[]MergedCell {};for _ ,_gfcf :=range _fadf ._gfae .MergeCells .MergeCell {_ega =append (_ega ,MergedCell {_fadf ._fdcd ,_fadf ,_gfcf });};return _ega ;
};

// Type returns the type of anchor
func (_dbda TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };func (_cdfc PatternFill )SetBgColor (c _de .Color ){_cdfc ._cafb .BgColor =_bf .NewCT_Color ();_cdfc ._cafb .BgColor .RgbAttr =c .AsRGBAString ();};func (_bfda SortOrder )String ()string {if _bfda >=SortOrder (len (_gec )-1){return _d .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_bfda );
};return _ffff [_gec [_bfda ]:_gec [_bfda +1]];};

// AddGradientStop adds a color gradient stop.
func (_bccd ColorScale )AddGradientStop (color _de .Color ){_bcdf :=_bf .NewCT_Color ();_bcdf .RgbAttr =color .AsRGBAString ();_bccd ._bcce .Color =append (_bccd ._bcce .Color ,_bcdf );};

// IsSheetLocked returns whether the sheet objects are locked.
func (_deedd SheetProtection )IsObjectLocked ()bool {return _deedd ._aege .ObjectsAttr !=nil &&*_deedd ._aege .ObjectsAttr ;};

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_bcac *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_fgbc :=-1;for _fdbdga ,_ggefd :=range _bcac .Sheets (){if name ==_ggefd .Name (){_fgbc =_fdbdga ;break ;};};if _fgbc ==-1{return Sheet {},ErrorNotFound ;};return _bcac .CopySheet (_fgbc ,copiedSheetName );
};func (_dedf *Sheet )addNumberedRowFast (_agaf uint32 )Row {_egfe :=_bf .NewCT_Row ();_egfe .RAttr =_f .Uint32 (_agaf );_dedf ._gfae .SheetData .Row =append (_dedf ._gfae .SheetData .Row ,_egfe );return Row {_dedf ._fdcd ,_dedf ,_egfe };};

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_cgac *_bf .Sst ;_dedg map[string ]int ;};

// CellStyles returns the list of defined cell styles
func (_egba StyleSheet )CellStyles ()[]CellStyle {_dbaff :=[]CellStyle {};for _ ,_cffa :=range _egba ._cafe .CellXfs .Xf {_dbaff =append (_dbaff ,CellStyle {_egba ._faceb ,_cffa ,_egba ._cafe .CellXfs });};return _dbaff ;};

// Row returns the row of the cell marker.
func (_fgea CellMarker )Row ()int32 {return _fgea ._dbc .Row };

// SheetText is an array of extracted text items which has some methods for representing extracted text from a sheet.
type SheetText struct{Cells []CellText ;};

// SetHidden controls the visibility of a column.
func (_bddf Column )SetHidden (b bool ){if !b {_bddf ._gdfd .HiddenAttr =nil ;}else {_bddf ._gdfd .HiddenAttr =_f .Bool (true );};};func (_bccb *evalContext )Cell (ref string ,ev _ca .Evaluator )_ca .Result {if !_fdc (ref ){return _ca .MakeErrorResultType (_ca .ErrorTypeName ,"");
};_affee :=_bccb ._gaa .Name ()+"\u0021"+ref ;if _gfb ,_cfe :=ev .GetFromCache (_affee );_cfe {return _gfb ;};_cbfg ,_bgd :=_dg .ParseCellReference (ref );if _bgd !=nil {return _ca .MakeErrorResult (_d .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_bgd ));
};if _bccb ._adcd !=0&&!_cbfg .AbsoluteColumn {_cbfg .ColumnIdx +=_bccb ._adcd ;_cbfg .Column =_dg .IndexToColumn (_cbfg .ColumnIdx );};if _bccb ._ge !=0&&!_cbfg .AbsoluteRow {_cbfg .RowIdx +=_bccb ._ge ;};_abf :=_bccb ._gaa .Cell (_cbfg .String ());if _abf .HasFormula (){if _ ,_gdde :=_bccb ._gef [ref ];
_gdde {return _ca .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );
};_bccb ._gef [ref ]=struct{}{};_ead :=ev .Eval (_bccb ,_abf .GetFormula ());delete (_bccb ._gef ,ref );ev .SetCache (_affee ,_ead );return _ead ;};if _abf .IsEmpty (){_dfd :=_ca .MakeEmptyResult ();ev .SetCache (_affee ,_dfd );return _dfd ;}else if _abf .IsNumber (){_eaeb ,_ :=_abf .GetValueAsNumber ();
_dca :=_ca .MakeNumberResult (_eaeb );ev .SetCache (_affee ,_dca );return _dca ;}else if _abf .IsBool (){_debb ,_ :=_abf .GetValueAsBool ();_ebe :=_ca .MakeBoolResult (_debb );ev .SetCache (_affee ,_ebe );return _ebe ;};_dcee ,_ :=_abf .GetRawValue ();
if _abf .IsError (){_badg :=_ca .MakeErrorResult ("");_badg .ValueString =_dcee ;ev .SetCache (_affee ,_badg );return _badg ;};_fdbdg :=_ca .MakeStringResult (_dcee );ev .SetCache (_affee ,_fdbdg );return _fdbdg ;};func (_dafff Font )SetColor (c _de .Color ){_ggcb :=_bf .NewCT_Color ();
_cecd :="\u0066\u0066"+*c .AsRGBString ();_ggcb .RgbAttr =&_cecd ;_dafff ._ggc .Color =[]*_bf .CT_Color {_ggcb };};

// SetConditionValue sets the condition value to be used for style applicaton.
func (_daff ConditionalFormattingRule )SetConditionValue (v string ){_daff ._aecc .Formula =[]string {v }};

// GetLocked returns true if the cell is locked.
func (_ceca *evalContext )GetLocked (cellRef string )bool {return _ceca ._gaa .Cell (cellRef ).getLocked ()};

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_cdea *Workbook )RemoveSheetByName (name string )error {_gdded :=-1;for _abcgc ,_ecfd :=range _cdea .Sheets (){if name ==_ecfd .Name (){_gdded =_abcgc ;break ;};};if _gdded ==-1{return ErrorNotFound ;};return _cdea .RemoveSheet (_gdded );};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_bag Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _eabfb ,_bcfg Cell ;for _ ,_dcc :=range lhs .Cells (){_degd ,_ :=_dg .ParseCellReference (_dcc .Reference ());if _degd .Column ==column {_eabfb =_dcc ;break ;};};for _ ,_daf :=range rhs .Cells (){_deeb ,_ :=_dg .ParseCellReference (_daf .Reference ());
if _deeb .Column ==column {_bcfg =_daf ;break ;};};return _bag .LessCells (_eabfb ,_bcfg );};func (_agef StyleSheet )GetCellStyle (id uint32 )CellStyle {for _bdcdg ,_efeg :=range _agef ._cafe .CellXfs .Xf {if uint32 (_bdcdg )==id {return CellStyle {_agef ._faceb ,_efeg ,_agef ._cafe .CellXfs };
};};return CellStyle {};};

// SetYSplit sets the row split point
func (_dgedd SheetView )SetYSplit (v float64 ){_dgedd .ensurePane ();_dgedd ._dbba .Pane .YSplitAttr =_f .Float64 (v );};

// X returns the inner wrapped XML type.
func (_ffeb DefinedName )X ()*_bf .CT_DefinedName {return _ffeb ._dcce };

// SetColOffset sets the column offset of the top-left anchor.
func (_babc OneCellAnchor )SetColOffset (m _ad .Distance ){_babc .TopLeft ().SetColOffset (m )};func (_dag Font )SetName (name string ){_dag ._ggc .Name =[]*_bf .CT_FontName {{ValAttr :name }}};

// InitializeDefaults initializes a border to its defaulte empty values.
func (_bcg Border )InitializeDefaults (){_bcg ._bee .Left =_bf .NewCT_BorderPr ();_bcg ._bee .Bottom =_bf .NewCT_BorderPr ();_bcg ._bee .Right =_bf .NewCT_BorderPr ();_bcg ._bee .Top =_bf .NewCT_BorderPr ();_bcg ._bee .Diagonal =_bf .NewCT_BorderPr ();
};func (_ccab *Sheet )getAllCellsInFormulaArrays (_gcba bool )(map[string ]bool ,error ){_bfae :=_ca .NewEvaluator ();_ebadd :=_ccab .FormulaContext ();_dcabf :=map[string ]bool {};for _ ,_dege :=range _ccab .Rows (){for _ ,_bcfd :=range _dege .Cells (){if _bcfd .X ().F !=nil {_agaff :=_bcfd .X ().F .Content ;
if _bcfd .X ().F .TAttr ==_bf .ST_CellFormulaTypeArray {_dece :=_bfae .Eval (_ebadd ,_agaff ).AsString ();if _dece .Type ==_ca .ResultTypeError {_db .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_agaff ,_dece .ErrorMessage );
_bcfd .X ().V =nil ;};if _dece .Type ==_ca .ResultTypeArray {_efd ,_ffcc :=_dg .ParseCellReference (_bcfd .Reference ());if _ffcc !=nil {return map[string ]bool {},_ffcc ;};if (_gcba &&len (_dece .ValueArray )==1)||(!_gcba &&len (_dece .ValueArray [0])==1){continue ;
};for _cfgd ,_cccd :=range _dece .ValueArray {_daeb :=_efd .RowIdx +uint32 (_cfgd );for _ccdfd :=range _cccd {_cfbe :=_dg .IndexToColumn (_efd .ColumnIdx +uint32 (_ccdfd ));_dcabf [_d .Sprintf ("\u0025\u0073\u0025\u0064",_cfbe ,_daeb )]=true ;};};}else if _dece .Type ==_ca .ResultTypeList {_cdcae ,_afce :=_dg .ParseCellReference (_bcfd .Reference ());
if _afce !=nil {return map[string ]bool {},_afce ;};if _gcba ||len (_dece .ValueList )==1{continue ;};_ffeg :=_cdcae .RowIdx ;for _bdffd :=range _dece .ValueList {_adgag :=_dg .IndexToColumn (_cdcae .ColumnIdx +uint32 (_bdffd ));_dcabf [_d .Sprintf ("\u0025\u0073\u0025\u0064",_adgag ,_ffeg )]=true ;
};};};};};};return _dcabf ,nil ;};

// IsWindowLocked returns whether the workbook windows are locked.
func (_gcef WorkbookProtection )IsWindowLocked ()bool {return _gcef ._afbb .LockWindowsAttr !=nil &&*_gcef ._afbb .LockWindowsAttr ;};

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_cecf ConditionalFormattingRule )SetColorScale ()ColorScale {_cecf .clear ();_cecf .SetType (_bf .ST_CfTypeColorScale );_cecf ._aecc .ColorScale =_bf .NewCT_ColorScale ();return ColorScale {_cecf ._aecc .ColorScale };};

// X returns the inner wrapped XML type.
func (_aece Column )X ()*_bf .CT_Col {return _aece ._gdfd };

// SetText sets the text to be displayed.
func (_aaca RichTextRun )SetText (s string ){_aaca ._ded .T =s };

// Borders returns the list of borders defined in the stylesheet.
func (_cdag StyleSheet )Borders ()[]Border {_cggcd :=[]Border {};for _ ,_ebf :=range _cdag ._cafe .Borders .Border {_cggcd =append (_cggcd ,Border {_bee :_ebf });};return _cggcd ;};

// X returns the inner XML entity for a stylesheet.
func (_agbc StyleSheet )X ()*_bf .StyleSheet {return _agbc ._cafe };

// AddRule adds and returns a new rule that can be configured.
func (_bcbg ConditionalFormatting )AddRule ()ConditionalFormattingRule {_fff :=_bf .NewCT_CfRule ();_bcbg ._eege .CfRule =append (_bcbg ._eege .CfRule ,_fff );_bcca :=ConditionalFormattingRule {_fff };_bcca .InitializeDefaults ();_bcca .SetPriority (int32 (len (_bcbg ._eege .CfRule )+1));
return _bcca ;};

// Col returns the column of the cell marker.
func (_bdcc CellMarker )Col ()int32 {return _bdcc ._dbc .Col };

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_ffdb *Sheet )SetFrozen (firstRow ,firstCol bool ){_ffdb ._gfae .SheetViews =nil ;_dcag :=_ffdb .AddView ();_dcag .SetState (_bf .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_dcag .SetYSplit (1);_dcag .SetXSplit (1);_dcag .SetTopLeft ("\u0042\u0032");
case firstRow :_dcag .SetYSplit (1);_dcag .SetTopLeft ("\u0041\u0032");case firstCol :_dcag .SetXSplit (1);_dcag .SetTopLeft ("\u0042\u0031");};};

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_ebea *evalContext )GetLabelPrefix (cellRef string )string {return _ebea ._gaa .Cell (cellRef ).getLabelPrefix ();};func (_bgdd StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));
};for _ ,_babe :=range _bgdd ._cafe .NumFmts .NumFmt {if _babe .NumFmtIdAttr ==id {return NumberFormat {_bgdd ._faceb ,_babe };};};return NumberFormat {};};

// GetFormat returns a cell data format.
func (_fce *evalContext )GetFormat (cellRef string )string {return _fce ._gaa .Cell (cellRef ).getFormat ()};

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_bgg *Workbook ;_badc *_bf .CT_NumFmt ;};

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_feaa *Sheet )RemoveColumn (column string )error {_fcbd ,_feab :=_feaa .getAllCellsInFormulaArraysForColumn ();if _feab !=nil {return _feab ;};_degdb :=_dg .ColumnToIndex (column );for _ ,_fdag :=range _feaa .Rows (){_dbcg :=_d .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_fdag .X ().RAttr );
if _ ,_eagg :=_fcbd [_dbcg ];_eagg {return nil ;};};for _ ,_bbag :=range _feaa .Rows (){_bdbb :=_bbag ._bgb .C ;for _bbef ,_efcd :=range _bdbb {_bgca ,_edfcg :=_dg .ParseCellReference (*_efcd .RAttr );if _edfcg !=nil {return _edfcg ;};if _bgca .ColumnIdx ==_degdb {_bbag ._bgb .C =append (_bdbb [:_bbef ],_feaa .slideCellsLeft (_bdbb [_bbef +1:])...);
break ;}else if _bgca .ColumnIdx > _degdb {_bbag ._bgb .C =append (_bdbb [:_bbef ],_feaa .slideCellsLeft (_bdbb [_bbef :])...);break ;};};};_feab =_feaa .updateAfterRemove (_degdb ,_cf .UpdateActionRemoveColumn );if _feab !=nil {return _feab ;};_feab =_feaa .removeColumnFromNamedRanges (_degdb );
if _feab !=nil {return _feab ;};_feab =_feaa .removeColumnFromMergedCells (_degdb );if _feab !=nil {return _feab ;};for _ ,_ggdba :=range _feaa ._fdcd .Sheets (){_ggdba .RecalculateFormulas ();};return nil ;};type PatternFill struct{_cafb *_bf .CT_PatternFill ;
_dad *_bf .CT_Fill ;};

// MoveTo repositions the anchor without changing the objects size.
func (_bacfb TwoCellAnchor )MoveTo (col ,row int32 ){_afgdf :=_bacfb .TopLeft ();_fcbcg :=_bacfb .BottomRight ();_facebf :=_fcbcg .Col ()-_afgdf .Col ();_fafg :=_fcbcg .Row ()-_afgdf .Row ();_afgdf .SetCol (col );_afgdf .SetRow (row );_fcbcg .SetCol (col +_facebf );
_fcbcg .SetRow (row +_fafg );};type MergedCell struct{_fbcgc *Workbook ;_ggbc *Sheet ;_beef *_bf .CT_MergeCell ;};

// SetNumberFormat applies a number format to a cell style avoiding redundancy. The function checks if the given string
// already exists in the saved number formats. If found, the existing number format is reused; otherwise,
// the new number format is added to the saved number formats collection. The number format is then applied to the cell style,
// affecting all styles that reference it by index.
func (_gbdg CellStyle )SetNumberFormat (s string ){var _dbab NumberFormat ;if _gbdg ._dd .StyleSheet ._cafe .NumFmts ==nil {_gbdg ._dd .StyleSheet ._cafe .NumFmts =_bf .NewCT_NumFmts ();};_fee :=_gbdg ._dd .StyleSheet ._cafe .NumFmts .NumFmt ;for _ ,_eae :=range _fee {if _cgg .DeepEqual (_eae .FormatCodeAttr ,s ){_dbab =NumberFormat {_gbdg ._dd ,_eae };
_gbdg ._cag .ApplyNumberFormatAttr =_f .Bool (true );_gbdg ._cag .NumFmtIdAttr =_f .Uint32 (_dbab .ID ());return ;};};_ccd :=_bf .NewCT_NumFmt ();_ccd .NumFmtIdAttr =uint32 (200+len (_gbdg ._dd .StyleSheet ._cafe .NumFmts .NumFmt ));_gbdg ._dd .StyleSheet ._cafe .NumFmts .NumFmt =append (_gbdg ._dd .StyleSheet ._cafe .NumFmts .NumFmt ,_ccd );
_gbdg ._dd .StyleSheet ._cafe .NumFmts .CountAttr =_f .Uint32 (uint32 (len (_gbdg ._dd .StyleSheet ._cafe .NumFmts .NumFmt )));_dbab =NumberFormat {_gbdg ._dd ,_ccd };_dbab ._badc .FormatCodeAttr =s ;_gbdg ._cag .ApplyNumberFormatAttr =_f .Bool (true );
_gbdg ._cag .NumFmtIdAttr =_f .Uint32 (_dbab .ID ());};

// X returns the inner wrapped XML type.
func (_gaba ColorScale )X ()*_bf .CT_ColorScale {return _gaba ._bcce };

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_bbf Comparer )LessCells (lhs ,rhs Cell )bool {if _bbf .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_edd ,_gad :=lhs .getRawSortValue ();
_cdc ,_cdd :=rhs .getRawSortValue ();switch {case _gad &&_cdd :_fefd ,_ :=_ff .ParseFloat (_edd ,64);_affe ,_ :=_ff .ParseFloat (_cdc ,64);return _fefd < _affe ;case _gad :return true ;case _cdd :return false ;};_edd =lhs .GetFormattedValue ();_cdc =rhs .GetFormattedValue ();
return _edd < _cdc ;};

// ClearBorder clears any border configuration from the cell style.
func (_cab CellStyle )ClearBorder (){_cab ._cag .BorderIdAttr =nil ;_cab ._cag .ApplyBorderAttr =nil };type SheetProtection struct{_aege *_bf .CT_SheetProtection };var (_deab =[...]uint8 {0,21,46,61,76,91};_cbefa =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};
_afca =[...]uint8 {0,16,32,48,64};_ddgf =[...]uint8 {0,16,32,48,64,80};);

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_dcgf *Workbook )Close ()error {if _dcgf .TmpPath !=""{return _fdg .RemoveAll (_dcgf .TmpPath );};return nil ;};

// New constructs a new workbook.
func New ()*Workbook {_faaf :=&Workbook {};_faaf ._gceg =_bf .NewWorkbook ();_faaf .AppProperties =_fg .NewAppProperties ();_faaf .CoreProperties =_fg .NewCoreProperties ();_faaf .StyleSheet =NewStyleSheet (_faaf );_faaf .Rels =_fg .NewRelationships ();
_faaf ._dfbgc =_fg .NewRelationships ();_faaf .Rels .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,"",_f .ExtendedPropertiesType ,0),_f .ExtendedPropertiesType );_faaf .Rels .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,"",_f .CorePropertiesType ,0),_f .CorePropertiesType );
_faaf .Rels .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,"",_f .OfficeDocumentType ,0),_f .OfficeDocumentType );_faaf ._dfbgc .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,_f .StylesType ,0),_f .StylesType );
_faaf .ContentTypes =_fg .NewContentTypes ();_faaf .ContentTypes .AddDefault ("\u0076\u006d\u006c",_f .VMLDrawingContentType );_faaf .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");
_faaf .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .StylesType ,0),_f .SMLStyleSheetContentType );_faaf .SharedStrings =NewSharedStrings ();_faaf .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .SharedStringsType ,0),_f .SharedStringsContentType );
_faaf ._dfbgc .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,_f .SharedStringsType ,0),_f .SharedStringsType );_faaf ._edga =map[string ]string {};return _faaf ;};

// SetWidth sets the width of the anchored object.
func (_cbc OneCellAnchor )SetWidth (w _ad .Distance ){_cbc ._gfga .Ext .CxAttr =int64 (w /_ad .EMU )};

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_bbfcg *Sheet )FormulaContext ()_ca .Context {return _fgag (_bbfcg )};

// GetEpoch returns a workbook's time epoch.
func (_ggdc *evalContext )GetEpoch ()_cg .Time {return _ggdc ._gaa ._fdcd .Epoch ()};

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_gc ,_bc int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_bdd _ad .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_gbe int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_ffc _ad .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_fgd int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_afa _ad .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_fdb _ad .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};func (_ffa Sheet )validateRowCellNumbers ()error {_daa :=map[uint32 ]struct{}{};for _ ,_gfcd :=range _ffa ._gfae .SheetData .Row {if _gfcd .RAttr !=nil {if _ ,_dgda :=_daa [*_gfcd .RAttr ];_dgda {return _d .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_ffa .Name (),*_gfcd .RAttr );
};_daa [*_gfcd .RAttr ]=struct{}{};};_gga :=map[string ]struct{}{};for _ ,_fbdc :=range _gfcd .C {if _fbdc .RAttr ==nil {continue ;};if _ ,_cgcc :=_gga [*_fbdc .RAttr ];_cgcc {return _d .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_ffa .Name (),*_fbdc .RAttr );
};_gga [*_fbdc .RAttr ]=struct{}{};};};return nil ;};

// SetBold causes the text to be displayed in bold.
func (_dggd RichTextRun )SetBold (b bool ){_dggd .ensureRpr ();_dggd ._ded .RPr .B =_bf .NewCT_BooleanProperty ();_dggd ._ded .RPr .B .ValAttr =_f .Bool (b );};func _dfdg ()*_ac .CT_TwoCellAnchor {_ede :=_ac .NewCT_TwoCellAnchor ();_ede .EditAsAttr =_ac .ST_EditAsOneCell ;
_ede .From .Col =5;_ede .From .Row =0;_ede .From .ColOff .ST_CoordinateUnqualified =_f .Int64 (0);_ede .From .RowOff .ST_CoordinateUnqualified =_f .Int64 (0);_ede .To .Col =10;_ede .To .Row =20;_ede .To .ColOff .ST_CoordinateUnqualified =_f .Int64 (0);
_ede .To .RowOff .ST_CoordinateUnqualified =_f .Int64 (0);return _ede ;};func (_fgf CellStyle )Index ()uint32 {for _gged ,_gdb :=range _fgf ._fcf .Xf {if _fgf ._cag ==_gdb {return uint32 (_gged );};};return 0;};

// SetColOffset sets a column offset in absolute distance.
func (_dae CellMarker )SetColOffset (m _ad .Distance ){_dae ._dbc .ColOff .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_ad .EMU ));};type Fill struct{_fgcc *_bf .CT_Fill ;_abca *_bf .CT_Fills ;};

// Reference returns the table reference (the cells within the table)
func (_effe Table )Reference ()string {return _effe ._gfbgg .RefAttr };

// Name returns the name of the defined name.
func (_bdcff DefinedName )Name ()string {return _bdcff ._dcce .NameAttr };

// SetFill applies a fill to a cell style avoiding redundancy. The function checks if the given fill
// already exists in the saved fills. If found, the existing fill is reused; otherwise,
// the new fill is added to the saved fills collection. The fill is then applied to the cell style,
// affecting all styles that reference it by index.
func (_ccgg CellStyle )SetFill (f Fill ){_ebc :=f ._abca .Fill ;for _ ,_afdc :=range _ebc {if _cgg .DeepEqual (_afdc ,f ._fgcc ){f ._fgcc =_afdc ;_ccgg ._cag .FillIdAttr =_f .Uint32 (f .Index ());_ccgg ._cag .ApplyFillAttr =_f .Bool (true );return ;};};
f ._abca .Fill =append (f ._abca .Fill ,f ._fgcc );f ._abca .CountAttr =_f .Uint32 (uint32 (len (f ._abca .Fill )));_ccgg ._cag .FillIdAttr =_f .Uint32 (f .Index ());_ccgg ._cag .ApplyFillAttr =_f .Bool (true );};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_geaf *Workbook )GetFilename ()string {return _geaf ._ceaec };

// ClearFont clears any font configuration from the cell style.
func (_decg CellStyle )ClearFont (){_decg ._cag .FontIdAttr =nil ;_decg ._cag .ApplyFontAttr =nil };

// AddFont creates a new empty Font style.
func (_gbff StyleSheet )AddFont ()Font {_dgbcc :=_bf .NewCT_Font ();return Font {_dgbcc ,_gbff ._cafe }};

// SetHidden marks the defined name as hidden.
func (_ffgf DefinedName )SetHidden (b bool ){_ffgf ._dcce .HiddenAttr =_f .Bool (b )};func (_bbcf Fill )SetPatternFill ()PatternFill {_bbcf ._fgcc .GradientFill =nil ;_bbcf ._fgcc .PatternFill =_bf .NewCT_PatternFill ();_bbcf ._fgcc .PatternFill .PatternTypeAttr =_bf .ST_PatternTypeSolid ;
return PatternFill {_bbcf ._fgcc .PatternFill ,_bbcf ._fgcc };};

// SetTopLeft sets the top left visible cell after the split.
func (_ddbc SheetView )SetTopLeft (cellRef string ){_ddbc .ensurePane ();_ddbc ._dbba .Pane .TopLeftCellAttr =&cellRef ;};

// IsNumber returns true if the cell is a number type cell.
func (_aa Cell )IsNumber ()bool {switch _aa ._faa .TAttr {case _bf .ST_CellTypeN :return true ;case _bf .ST_CellTypeS ,_bf .ST_CellTypeB :return false ;};return _aa ._faa .V !=nil &&_eda .IsNumber (*_aa ._faa .V );};

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_bffg *Sheet )Cell (cellRef string )Cell {_adcda ,_ggdcc :=_dg .ParseCellReference (cellRef );if _ggdcc !=nil {_db .Log .Debug ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_ggdcc );
return _bffg .AddRow ().AddCell ();};return _bffg .Row (_adcda .RowIdx ).Cell (_adcda .Column );};

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_egbd *Workbook )AddDrawing ()Drawing {_caad :=_ac .NewWsDr ();_egbd ._gaffb =append (_egbd ._gaffb ,_caad );_cdef :=_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .DrawingType ,len (_egbd ._gaffb ));_egbd .ContentTypes .AddOverride (_cdef ,_f .DrawingContentType );
_egbd ._effga =append (_egbd ._effga ,_fg .NewRelationships ());return Drawing {_egbd ,_caad };};

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_gcbeb TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_gcbeb ._fbbg .To }};

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_fbbg *_ac .CT_TwoCellAnchor };func (_bdf CellStyle )SetShrinkToFit (b bool ){if _bdf ._cag .Alignment ==nil {_bdf ._cag .Alignment =_bf .NewCT_CellAlignment ();};_bdf ._cag .ApplyAlignmentAttr =_f .Bool (true );if !b {_bdf ._cag .Alignment .ShrinkToFitAttr =nil ;
}else {_bdf ._cag .Alignment .ShrinkToFitAttr =_f .Bool (b );};};

// Comments returns the list of comments for this sheet
func (_fgaf Comments )Comments ()[]Comment {_bdcg :=[]Comment {};for _ ,_gde :=range _fgaf ._fca .CommentList .Comment {_bdcg =append (_bdcg ,Comment {_fgaf ._eac ,_gde ,_fgaf ._fca });};return _bdcg ;};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_acg ,_gaca :=_ed .Open (filename );if _gaca !=nil {return nil ,_d .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_gaca );};defer _acg .Close ();
_aeb ,_gaca :=_ed .Stat (filename );if _gaca !=nil {return nil ,_d .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_gaca );};_bac ,_gaca :=Read (_acg ,_aeb .Size ());if _gaca !=nil {return nil ,_gaca ;
};_efbg ,_ :=_bd .Abs (_bd .Dir (filename ));_bac ._ceaec =_bd .Join (_efbg ,filename );return _bac ,nil ;};

// DataValidation controls cell validation
type DataValidation struct{_aabc *_bf .CT_DataValidation };func (_cgeag PatternFill )X ()*_bf .CT_PatternFill {return _cgeag ._cafb };

// GetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_ef CellStyle )GetHorizontalAlignment ()_bf .ST_HorizontalAlignment {if _ef ._cag .Alignment ==nil {return _bf .ST_HorizontalAlignmentUnset ;};return _ef ._cag .Alignment .HorizontalAttr ;};

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_edg Cell )GetFormattedValue ()string {_deg :=_edg .getFormat ();switch _edg ._faa .TAttr {case _bf .ST_CellTypeB :_ceg ,_ :=_edg .GetValueAsBool ();if _ceg {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _bf .ST_CellTypeN :_faf ,_ :=_edg .GetValueAsNumber ();
return _eda .Number (_faf ,_deg );case _bf .ST_CellTypeE :if _edg ._faa .V !=nil {return *_edg ._faa .V ;};return "";case _bf .ST_CellTypeS ,_bf .ST_CellTypeInlineStr :return _eda .String (_edg .GetString (),_deg );case _bf .ST_CellTypeStr :_faag :=_edg .GetString ();
if _eda .IsNumber (_faag ){_gbd ,_ :=_ff .ParseFloat (_faag ,64);return _eda .Number (_gbd ,_deg );};return _eda .String (_faag ,_deg );case _bf .ST_CellTypeUnset :fallthrough;default:_gab ,_ :=_edg .GetRawValue ();if len (_gab )==0{return "";};_aec ,_fc :=_edg .GetValueAsNumber ();
if _fc ==nil {return _eda .Number (_aec ,_deg );};return _eda .String (_gab ,_deg );};};

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_bab DataValidation )SetRange (cellRange string ){_bab ._aabc .SqrefAttr =_bf .ST_Sqref {cellRange }};

// Index returns the index of the differential style.
func (_bgda DifferentialStyle )Index ()uint32 {for _afad ,_bbd :=range _bgda ._aad .Dxf {if _bgda ._fgc ==_bbd {return uint32 (_afad );};};return 0;};

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_beg *Sheet )InsertRow (rowNum int )Row {_afeb :=uint32 (rowNum );for _ ,_agaa :=range _beg .Rows (){if _agaa ._bgb .RAttr !=nil &&*_agaa ._bgb .RAttr >=_afeb {*_agaa ._bgb .RAttr ++;for _ ,_adcf :=range _agaa .Cells (){_ddae ,_adaf :=_dg .ParseCellReference (_adcf .Reference ());
if _adaf !=nil {continue ;};_ddae .RowIdx ++;_adcf ._faa .RAttr =_f .String (_ddae .String ());};};};for _ ,_defb :=range _beg .MergedCells (){_acbg ,_beec ,_eea :=_dg .ParseRangeReference (_defb .Reference ());if _eea !=nil {continue ;};if int (_acbg .RowIdx )>=rowNum {_acbg .RowIdx ++;
};if int (_beec .RowIdx )>=rowNum {_beec .RowIdx ++;};_fdcg :=_d .Sprintf ("\u0025\u0073\u003a%\u0073",_acbg ,_beec );_defb .SetReference (_fdcg );};return _beg .AddNumberedRow (_afeb );};

// Type returns the type of the rule
func (_cadb ConditionalFormattingRule )Type ()_bf .ST_CfType {return _cadb ._aecc .TypeAttr };

// AddCell adds a cell to a spreadsheet.
func (_affc Row )AddCell ()Cell {_dded :=uint32 (len (_affc ._bgb .C ));var _ffbg *string ;if _dded > 0{_dccd :=_f .Stringf ("\u0025\u0073\u0025\u0064",_dg .IndexToColumn (_dded -1),_affc .RowNumber ());if _affc ._bgb .C [_dded -1].RAttr !=nil &&*_affc ._bgb .C [_dded -1].RAttr ==*_dccd {_ffbg =_f .Stringf ("\u0025\u0073\u0025\u0064",_dg .IndexToColumn (_dded ),_affc .RowNumber ());
};};_cadd :=_bf .NewCT_Cell ();_affc ._bgb .C =append (_affc ._bgb .C ,_cadd );if _ffbg ==nil {_beff :=uint32 (0);for _ ,_fdd :=range _affc ._bgb .C {if _fdd .RAttr !=nil {_bada ,_ :=_dg .ParseCellReference (*_fdd .RAttr );if _bada .ColumnIdx >=_beff {_beff =_bada .ColumnIdx +1;
};};};_ffbg =_f .Stringf ("\u0025\u0073\u0025\u0064",_dg .IndexToColumn (_beff ),_affc .RowNumber ());};_cadd .RAttr =_ffbg ;return Cell {_affc ._gdc ,_affc ._ade ,_affc ._bgb ,_cadd };};

// SetWidth sets the width of the anchored object.
func (_ae AbsoluteAnchor )SetWidth (w _ad .Distance ){_ae ._ace .Ext .CxAttr =int64 (w /_ad .EMU )};

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_dfgg *Sheet )SheetViews ()[]SheetView {if _dfgg ._gfae .SheetViews ==nil {return nil ;};_faffa :=[]SheetView {};for _ ,_ccfdf :=range _dfgg ._gfae .SheetViews .SheetView {_faffa =append (_faffa ,SheetView {_ccfdf });};return _faffa ;};

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_acb ConditionalFormattingRule )SetDataBar ()DataBarScale {_acb .clear ();_acb .SetType (_bf .ST_CfTypeDataBar );_acb ._aecc .DataBar =_bf .NewCT_DataBar ();_dbg :=DataBarScale {_acb ._aecc .DataBar };_dbg .SetShowValue (true );_dbg .SetMinLength (10);
_dbg .SetMaxLength (90);return _dbg ;};

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_eaea *Workbook )AddImage (i _fg .Image )(_fg .ImageRef ,error ){_cdfgf :=_fg .MakeImageRef (i ,&_eaea .DocBase ,_eaea ._dfbgc );if i .Data ==nil &&i .Path ==""{return _cdfgf ,_cda .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");
};if i .Format ==""{return _cdfgf ,_cda .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _cdfgf ,_cda .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");
};if i .Path !=""{_abde :=_fdg .Add (i .Path );if _abde !=nil {return _cdfgf ,_abde ;};};_eaea .Images =append (_eaea .Images ,_cdfgf );return _cdfgf ,nil ;};

// AddCellStyle creates a new empty cell style.
func (_dgcg StyleSheet )AddCellStyle ()CellStyle {_cgaag :=_bf .NewCT_Xf ();return CellStyle {_dgcg ._faceb ,_cgaag ,_dgcg ._cafe .CellXfs };};func _cee (_dba _cg .Time )_cg .Time {_dba =_dba .Local ();return _cg .Date (_dba .Year (),_dba .Month (),_dba .Day (),_dba .Hour (),_dba .Minute (),_dba .Second (),_dba .Nanosecond (),_cg .UTC );
};

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_abda *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_abbf :=_bf .NewCT_ConditionalFormatting ();_abda ._gfae .ConditionalFormatting =append (_abda ._gfae .ConditionalFormatting ,_abbf );_gcab :=make (_bf .ST_Sqref ,0,0);
_abbf .SqrefAttr =&_gcab ;for _ ,_fgbd :=range cellRanges {*_abbf .SqrefAttr =append (*_abbf .SqrefAttr ,_fgbd );};return ConditionalFormatting {_abbf };};const (DVCompareTypeWholeNumber =DVCompareType (_bf .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_bf .ST_DataValidationTypeDecimal );
DVCompareTypeDate =DVCompareType (_bf .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_bf .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_bf .ST_DataValidationTypeTextLength ););

// SetHeight is a nop-op.
func (_bgdcd TwoCellAnchor )SetHeight (h _ad .Distance ){};

// SetNumber sets the cell type to number, and the value to the given number
func (_agd Cell )SetNumber (v float64 ){_agd .clearValue ();if _eg .IsNaN (v )||_eg .IsInf (v ,0){_agd ._faa .TAttr =_bf .ST_CellTypeE ;_agd ._faa .V =_f .String ("\u0023\u004e\u0055M\u0021");return ;};_agd ._faa .TAttr =_bf .ST_CellTypeN ;_agd ._faa .V =_f .String (_ff .FormatFloat (v ,'f',-1,64));
};

// RowOffset returns the offset from the row cell.
func (_cac CellMarker )RowOffset ()_ad .Distance {if _cac ._dbc .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _ad .Distance (float64 (*_cac ._dbc .RowOff .ST_CoordinateUnqualified )*_ad .EMU );};

// Type returns the type of anchor
func (_cfd AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };func (_daaa SheetView )ensurePane (){if _daaa ._dbba .Pane ==nil {_daaa ._dbba .Pane =_bf .NewCT_Pane ();_daaa ._dbba .Pane .ActivePaneAttr =_bf .ST_PaneBottomLeft ;};};func (_bba Row )renumberAs (_fbgg uint32 ){_bba ._bgb .RAttr =_f .Uint32 (_fbgg );
for _ ,_bbgg :=range _bba .Cells (){_cbcc ,_aafb :=_dg .ParseCellReference (_bbgg .Reference ());if _aafb ==nil {_dcda :=_d .Sprintf ("\u0025\u0073\u0025\u0064",_cbcc .Column ,_fbgg );_bbgg ._faa .RAttr =_f .String (_dcda );};};};const (_abbff ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";
_bacf ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";
_abecc ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";
_baeb ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";
);

// X returns the inner wrapped XML type.
func (_bbbb Comment )X ()*_bf .CT_Comment {return _bbbb ._cdeg };

// SetShowRuler controls the visibility of the ruler
func (_bae SheetView )SetShowRuler (b bool ){if !b {_bae ._dbba .ShowRulerAttr =_f .Bool (false );}else {_bae ._dbba .ShowRulerAttr =nil ;};};

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_gg AbsoluteAnchor )SetRowOffset (m _ad .Distance ){_gg ._ace .Pos .YAttr .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_ad .EMU ));};

// SetShowValue controls if the cell value is displayed.
func (_ddfe DataBarScale )SetShowValue (b bool ){_ddfe ._gbc .ShowValueAttr =_f .Bool (b )};func (_fbdca *Sheet )slideCellsLeft (_bgcga []*_bf .CT_Cell )[]*_bf .CT_Cell {for _ ,_bdcd :=range _bgcga {_egfa ,_adbd :=_dg .ParseCellReference (*_bdcd .RAttr );
if _adbd !=nil {return _bgcga ;};_egbb :=_egfa .ColumnIdx -1;_fcd :=_dg .IndexToColumn (_egbb )+_d .Sprintf ("\u0025\u0064",_egfa .RowIdx );_bdcd .RAttr =&_fcd ;};return _bgcga ;};

// MaxColumnIdx returns the max used column of the sheet.
func (_ggec Sheet )MaxColumnIdx ()uint32 {_fbb :=uint32 (0);for _ ,_bgdc :=range _ggec .Rows (){_cdfcd :=_bgdc ._bgb .C ;if len (_cdfcd )> 0{_afag :=_cdfcd [len (_cdfcd )-1];_fdde ,_ :=_dg .ParseCellReference (*_afag .RAttr );if _fbb < _fdde .ColumnIdx {_fbb =_fdde .ColumnIdx ;
};};};return _fbb ;};

// SaveToFile writes the workbook out to a file.
func (_adgaf *Workbook )SaveToFile (path string )error {_ecg ,_cbfe :=_ed .Create (path );if _cbfe !=nil {return _cbfe ;};defer _ecg .Close ();return _adgaf .Save (_ecg );};

// Column returns the cell column
func (_abb Cell )Column ()(string ,error ){_bcd ,_dec :=_dg .ParseCellReference (_abb .Reference ());if _dec !=nil {return "",_dec ;};return _bcd .Column ,nil ;};

// AddSheet adds a new sheet to a workbook.
func (_gbcf *Workbook )AddSheet ()Sheet {_cgeab :=_bf .NewCT_Sheet ();_cgeab .SheetIdAttr =1;for _ ,_ddga :=range _gbcf ._gceg .Sheets .Sheet {if _cgeab .SheetIdAttr <=_ddga .SheetIdAttr {_cgeab .SheetIdAttr =_ddga .SheetIdAttr +1;};};_gbcf ._gceg .Sheets .Sheet =append (_gbcf ._gceg .Sheets .Sheet ,_cgeab );
_cgeab .NameAttr =_d .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_cgeab .SheetIdAttr );_gbbd :=_bf .NewWorksheet ();_gbbd .Dimension =_bf .NewCT_SheetDimension ();_gbbd .Dimension .RefAttr ="\u0041\u0031";_gbcf ._bfbb =append (_gbcf ._bfbb ,_gbbd );
_efde :=_fg .NewRelationships ();_gbcf ._cfac =append (_gbcf ._cfac ,_efde );_gbbd .SheetData =_bf .NewCT_SheetData ();_gbcf ._gbfe =append (_gbcf ._gbfe ,nil );_affgg :=_f .DocTypeSpreadsheet ;_ggac :=_gbcf ._dfbgc .AddAutoRelationship (_affgg ,_f .OfficeDocumentType ,len (_gbcf ._gceg .Sheets .Sheet ),_f .WorksheetType );
_cgeab .IdAttr =_ggac .ID ();_gbcf .ContentTypes .AddOverride (_f .AbsoluteFilename (_affgg ,_f .WorksheetContentType ,len (_gbcf ._gceg .Sheets .Sheet )),_f .WorksheetContentType );return Sheet {_gbcf ,_cgeab ,_gbbd };};

// SetRotation configures the cell to be rotated.
func (_fgg CellStyle )SetRotation (deg uint8 ){if _fgg ._cag .Alignment ==nil {_fgg ._cag .Alignment =_bf .NewCT_CellAlignment ();};_fgg ._cag .ApplyAlignmentAttr =_f .Bool (true );_fgg ._cag .Alignment .TextRotationAttr =_f .Uint8 (deg );};

// SetDateWithStyle sets a date with the default date style applied.
func (_cbff Cell )SetDateWithStyle (d _cg .Time ){_cbff .SetDate (d );for _ ,_gce :=range _cbff ._aef .StyleSheet .CellStyles (){if _gce .HasNumberFormat ()&&_gce .NumberFormat ()==uint32 (StandardFormatDate ){_cbff .SetStyle (_gce );return ;};};_eag :=_cbff ._aef .StyleSheet .AddCellStyle ();
_eag .SetNumberFormatStandard (StandardFormatDate );_cbff .SetStyle (_eag );};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_add CellStyle )NumberFormat ()uint32 {if _add ._cag .NumFmtIdAttr ==nil {return 0;};return *_add ._cag .NumFmtIdAttr ;};

// ExtractText returns text from the sheet as a SheetText object.
func (_cfbd *Sheet )ExtractText ()*SheetText {_afgd :=[]CellText {};for _ ,_ecde :=range _cfbd .Rows (){for _ ,_eade :=range _ecde .Cells (){if !_eade .IsEmpty (){if _aggc :=_eade .GetFormattedValue ();_aggc !=""{_afgd =append (_afgd ,CellText {Text :_aggc ,Cell :_eade });
};};};};return &SheetText {Cells :_afgd };};

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_gfga *_ac .CT_OneCellAnchor };

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_deae CellStyle )SetHorizontalAlignment (a _bf .ST_HorizontalAlignment ){if _deae ._cag .Alignment ==nil {_deae ._cag .Alignment =_bf .NewCT_CellAlignment ();};_deae ._cag .Alignment .HorizontalAttr =a ;_deae ._cag .ApplyAlignmentAttr =_f .Bool (true );
};

// Cell is a single cell within a sheet.
type Cell struct{_aef *Workbook ;_bbc *Sheet ;_fge *_bf .CT_Row ;_faa *_bf .CT_Cell ;};

// IsBool returns true if the cell boolean value.
func (_bde *evalContext )IsBool (cellRef string )bool {return _bde ._gaa .Cell (cellRef ).IsBool ()};

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_bdga *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_cfcg :=range _bdga .Sheets (){if _cfcg .Name ()==name {return _cfcg ,nil ;};};return Sheet {},ErrorNotFound ;};func (_cefbc StyleSheet )appendFont ()Font {_ebec :=_bf .NewCT_Font ();
_cefbc ._cafe .Fonts .Font =append (_cefbc ._cafe .Fonts .Font ,_ebec );_cefbc ._cafe .Fonts .CountAttr =_f .Uint32 (uint32 (len (_cefbc ._cafe .Fonts .Font )));return Font {_ebec ,_cefbc ._cafe };};

// SetHeightCells is a no-op.
func (_ffgg OneCellAnchor )SetHeightCells (int32 ){};

// TopLeft returns the top-left corner of the anchored object.
func (_bccf OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_bccf ._gfga .From }};

// SetColor sets teh color of the databar.
func (_gddb DataBarScale )SetColor (c _de .Color ){_gddb ._gbc .Color =_bf .NewCT_Color ();_gddb ._gbc .Color .RgbAttr =c .AsRGBAString ();};

// IconScale maps values to icons.
type IconScale struct{_cfbdc *_bf .CT_IconSet };func (_gcd Border )SetLeft (style _bf .ST_BorderStyle ,c _de .Color ){if _gcd ._bee .Left ==nil {_gcd ._bee .Left =_bf .NewCT_BorderPr ();};_gcd ._bee .Left .Color =_bf .NewCT_Color ();_gcd ._bee .Left .Color .RgbAttr =c .AsRGBAString ();
_gcd ._bee .Left .StyleAttr =style ;};

// SetLocked sets cell locked or not.
func (_debf *evalContext )SetLocked (cellRef string ,locked bool ){_debf ._gaa .Cell (cellRef ).setLocked (locked );};

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_badd PatternFill )SetFgColor (c _de .Color ){_badd ._cafb .FgColor =_bf .NewCT_Color ();_badd ._cafb .FgColor .RgbAttr =c .AsRGBAString ();};

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_bbb Cell )SetTime (d _cg .Time ){_bbb .clearValue ();d =_cee (d );_dcf :=_bbb ._aef .Epoch ();if d .Before (_dcf ){_db .Log .Debug ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");
return ;};_bad :=d .Sub (_dcf );_cbf :=new (_fa .Float );_cgf :=new (_fa .Float );_cgf .SetPrec (128);_cgf .SetUint64 (uint64 (_bad ));_cbfa :=new (_fa .Float );_cbfa .SetUint64 (24*60*60*1e9);_cbf .Quo (_cgf ,_cbfa );_bbb ._faa .V =_f .String (_cbf .Text ('g',20));
};

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_ggc *_bf .CT_Font ;_bcdfc *_bf .StyleSheet ;};

// GetFilename returns the filename of the context's workbook.
func (_edf *evalContext )GetFilename ()string {return _edf ._gaa ._fdcd .GetFilename ()};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_debc Sheet )ValidateWithPath (path string )error {return _debc ._gfae .ValidateWithPath (path )};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_cebb TwoCellAnchor )SetWidthCells (w int32 ){_bceef :=_cebb .TopLeft ();_cefbe :=_cebb .BottomRight ();_cefbe .SetCol (_bceef .Col ()+w );};

// AddFill creates a new empty Fill style.
func (_adb Fills )AddFill ()Fill {_dace :=_bf .NewCT_Fill ();return Fill {_dace ,_adb ._dccc }};

// SetMinLength sets the minimum bar length in percent.
func (_aca DataBarScale )SetMinLength (l uint32 ){_aca ._gbc .MinLengthAttr =_f .Uint32 (l )};

// Protection allows control over the workbook protections.
func (_cdee *Workbook )Protection ()WorkbookProtection {if _cdee ._gceg .WorkbookProtection ==nil {_cdee ._gceg .WorkbookProtection =_bf .NewCT_WorkbookProtection ();};return WorkbookProtection {_cdee ._gceg .WorkbookProtection };};

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};

// SetError sets the cell type to error and the value to the given error message.
func (_abd Cell )SetError (msg string ){_abd .clearValue ();_abd ._faa .V =_f .String (msg );_abd ._faa .TAttr =_bf .ST_CellTypeE ;};

// Priority returns the rule priority
func (_aced ConditionalFormattingRule )Priority ()int32 {return _aced ._aecc .PriorityAttr };

// Workbook returns sheet's parent workbook.
func (_eacf *Sheet )Workbook ()*Workbook {return _eacf ._fdcd };

// IsStructureLocked returns whether the workbook structure is locked.
func (_babgb WorkbookProtection )IsStructureLocked ()bool {return _babgb ._afbb .LockStructureAttr !=nil &&*_babgb ._afbb .LockStructureAttr ;};

// TopLeft is a no-op.
func (_ab AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};var _dcef []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};


// Text returns text from the workbook as one string separated with line breaks.
func (_dbd *WorkbookText )Text ()string {_ddea :=_g .NewBuffer ([]byte {});for _ ,_bebe :=range _dbd .Sheets {_ddea .WriteString (_bebe .Text ());};return _ddea .String ();};

// Clear clears the cell's value and type.
func (_bbg Cell )Clear (){_bbg .clearValue ();_bbg ._faa .TAttr =_bf .ST_CellTypeUnset };func (_aagf Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _agge ,_cccec ,_bcad ,_dedc uint32 =1,1,0,0;for _ ,_eceb :=range _aagf .Rows (){if _eceb .RowNumber ()< _agge {_agge =_eceb .RowNumber ();
}else if _eceb .RowNumber ()> _cccec {_cccec =_eceb .RowNumber ();};for _ ,_afaa :=range _eceb .Cells (){_gced ,_bdff :=_dg .ParseCellReference (_afaa .Reference ());if _bdff ==nil {if _gced .ColumnIdx < _bcad {_bcad =_gced .ColumnIdx ;}else if _gced .ColumnIdx > _dedc {_dedc =_gced .ColumnIdx ;
};};};};return _dg .IndexToColumn (_bcad ),_agge ,_dg .IndexToColumn (_dedc ),_cccec ;};

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_cafec StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _cafec ._cafe .Dxfs ==nil {_cafec ._cafe .Dxfs =_bf .NewCT_Dxfs ();};_aega :=_bf .NewCT_Dxf ();_cafec ._cafe .Dxfs .Dxf =append (_cafec ._cafe .Dxfs .Dxf ,_aega );_cafec ._cafe .Dxfs .CountAttr =_f .Uint32 (uint32 (len (_cafec ._cafe .Dxfs .Dxf )));
return DifferentialStyle {_aega ,_cafec ._faceb ,_cafec ._cafe .Dxfs };};

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_bdac Cell )GetCachedFormulaResult ()string {if _bdac ._faa .V !=nil {return *_bdac ._faa .V ;};return "";};

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_gag Cell )SetDate (d _cg .Time ){_gag .clearValue ();d =_cee (d );_gca :=_gag ._aef .Epoch ();if d .Before (_gca ){_db .Log .Debug ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");
return ;};_cge :=d .Sub (_gca );_fgb :=new (_fa .Float );_fbe :=new (_fa .Float );_fbe .SetPrec (128);_fbe .SetUint64 (uint64 (_cge ));_eba :=new (_fa .Float );_eba .SetUint64 (24*60*60*1e9);_fgb .Quo (_fbe ,_eba );_edb ,_ :=_fgb .Uint64 ();_gag ._faa .V =_f .Stringf ("\u0025\u0064",_edb );
};const _ffff ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_eaac *Sheet )ClearSheetViews (){_eaac ._gfae .SheetViews =nil };

// SetName sets the sheet name.
func (_ged *Sheet )SetName (name string ){_ged ._fggga .NameAttr =name };

// AddDataValidation adds a data validation rule to a sheet.
func (_fgca *Sheet )AddDataValidation ()DataValidation {if _fgca ._gfae .DataValidations ==nil {_fgca ._gfae .DataValidations =_bf .NewCT_DataValidations ();};_bagc :=_bf .NewCT_DataValidation ();_bagc .ShowErrorMessageAttr =_f .Bool (true );_fgca ._gfae .DataValidations .DataValidation =append (_fgca ._gfae .DataValidations .DataValidation ,_bagc );
_fgca ._gfae .DataValidations .CountAttr =_f .Uint32 (uint32 (len (_fgca ._gfae .DataValidations .DataValidation )));return DataValidation {_bagc };};

// ClearAutoFilter removes the autofilters from the sheet.
func (_bed *Sheet )ClearAutoFilter (){_bed ._gfae .AutoFilter =nil ;_face :="\u0027"+_bed .Name ()+"\u0027\u0021";for _ ,_begf :=range _bed ._fdcd .DefinedNames (){if _begf .Name ()==_bfg {if _cb .HasPrefix (_begf .Content (),_face ){_bed ._fdcd .RemoveDefinedName (_begf );
break ;};};};};

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_befb Sheet )Validate ()error {_cdg :=[]func ()error {_befb .validateRowCellNumbers ,_befb .validateMergedCells ,_befb .validateSheetNames };for _ ,_eaa :=range _cdg {if _aafe :=_eaa ();_aafe !=nil {return _aafe ;};};if _eef :=_befb ._gfae .Validate ();
_eef !=nil {return _eef ;};return _befb ._gfae .Validate ();};type Table struct{_gfbgg *_bf .Table };

// Cell returns the actual cell behind the merged region
func (_dbafb MergedCell )Cell ()Cell {_gcgc :=_dbafb .Reference ();if _abaa :=_cb .Index (_dbafb .Reference (),"\u003a");_abaa !=-1{_gcgc =_gcgc [0:_abaa ];return _dbafb ._ggbc .Cell (_gcgc );};return Cell {};};func _fgag (_afdg *Sheet )*evalContext {return &evalContext {_gaa :_afdg ,_gef :make (map[string ]struct{})};
};func (_gafa Font )SetItalic (b bool ){if b {_gafa ._ggc .I =[]*_bf .CT_BooleanProperty {{}};}else {_gafa ._ggc .I =nil ;};};

// SetType sets the type of the rule.
func (_gfcc ConditionalFormattingRule )SetType (t _bf .ST_CfType ){_gfcc ._aecc .TypeAttr =t };

// CellMarker represents a cell position
type CellMarker struct{_dbc *_ac .CT_Marker };

// PasswordHash returns the hash of the workbook password.
func (_egcb SheetProtection )PasswordHash ()string {if _egcb ._aege .PasswordAttr ==nil {return "";};return *_egcb ._aege .PasswordAttr ;};func _eaef ()*_ac .CT_AbsoluteAnchor {_eddb :=_ac .NewCT_AbsoluteAnchor ();return _eddb };var _ebcd =_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .SharedStringsType ,0);


// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_cdfg Cell )SetStyleIndex (idx uint32 ){_cdfg ._faa .SAttr =_f .Uint32 (idx )};func (_cdbc PatternFill )ClearBgColor (){_cdbc ._cafb .BgColor =nil };const (DVOpGreater =_bf .ST_DataValidationOperatorGreaterThanOrEqual ;);

// SetMaxLength sets the maximum bar length in percent.
func (_ada DataBarScale )SetMaxLength (l uint32 ){_ada ._gbc .MaxLengthAttr =_f .Uint32 (l )};

// SetCol set the column of the cell marker.
func (_deac CellMarker )SetCol (col int32 ){_deac ._dbc .Col =col };

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_ecec NumberFormat )ID ()uint32 {return _ecec ._badc .NumFmtIdAttr };

// X returns the inner wrapped XML type.
func (_ecc Sheet )X ()*_bf .Worksheet {return _ecc ._gfae };

// CellText is used for keeping text with references to a cell where it is located.
type CellText struct{Text string ;Cell Cell ;};

// Fonts returns the list of fonts defined in the stylesheet.
func (_bfgdc StyleSheet )Fonts ()[]Font {_ddeg :=[]Font {};for _ ,_cbbb :=range _bfgdc ._cafe .Fonts .Font {_ddeg =append (_ddeg ,Font {_cbbb ,_bfgdc ._cafe });};return _ddeg ;};

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_gbc *_bf .CT_DataBar };

// X returns the inner wrapped XML type.
func (_fcfe MergedCell )X ()*_bf .CT_MergeCell {return _fcfe ._beef };

// GetFill gets a Fill from a cell style.
func (_ece CellStyle )GetFill ()*_bf .CT_Fill {if _fcbc :=_ece ._cag .FillIdAttr ;_fcbc !=nil {_bgc :=_ece ._dd .StyleSheet .Fills ().X ().Fill ;if int (*_fcbc )< len (_bgc ){return _bgc [int (*_fcbc )];};};return nil ;};

// SetStyle sets the cell style for an entire column.
func (_aab Column )SetStyle (cs CellStyle ){_aab ._gdfd .StyleAttr =_f .Uint32 (cs .Index ())};func _gdfc (_ggef string ,_bdgd uint32 ,_ccdf bool )string {_aagfe ,_efag ,_fbfb :=_dg .ParseRangeReference (_ggef );if _fbfb ==nil {_bbfd ,_badb :=_aagfe .ColumnIdx ,_efag .ColumnIdx ;
if _bdgd >=_bbfd &&_bdgd <=_badb {if _bbfd ==_badb {if _ccdf {return "";}else {return _ggef ;};}else {_eadba :=_efag .Update (_cf .UpdateActionRemoveColumn );return _d .Sprintf ("\u0025\u0073\u003a%\u0073",_aagfe .String (),_eadba .String ());};}else if _bdgd < _bbfd {_ebae :=_aagfe .Update (_cf .UpdateActionRemoveColumn );
_acbdd :=_efag .Update (_cf .UpdateActionRemoveColumn );return _d .Sprintf ("\u0025\u0073\u003a%\u0073",_ebae .String (),_acbdd .String ());};}else {_bbae ,_gabba ,_ebed :=_dg .ParseColumnRangeReference (_ggef );if _ebed !=nil {return "";};_cagg ,_fcdc :=_bbae .ColumnIdx ,_gabba .ColumnIdx ;
if _bdgd >=_cagg &&_bdgd <=_fcdc {if _cagg ==_fcdc {if _ccdf {return "";}else {return _ggef ;};}else {_gcdg :=_gabba .Update (_cf .UpdateActionRemoveColumn );return _d .Sprintf ("\u0025\u0073\u003a%\u0073",_bbae .String (),_gcdg .String ());};}else if _bdgd < _cagg {_cggc :=_bbae .Update (_cf .UpdateActionRemoveColumn );
_acaa :=_gabba .Update (_cf .UpdateActionRemoveColumn );return _d .Sprintf ("\u0025\u0073\u003a%\u0073",_cggc .String (),_acaa .String ());};};return "";};

// SetRowOffset sets a column offset in absolute distance.
func (_fcb CellMarker )SetRowOffset (m _ad .Distance ){_fcb ._dbc .RowOff .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_ad .EMU ));};var ErrorNotFound =_cda .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// X returns the inner wrapped XML type.
func (_afd Cell )X ()*_bf .CT_Cell {return _afd ._faa };

// GetVerticalAlignment sets the vertical alignment of a cell style.
func (_fab CellStyle )GetVerticalAlignment ()_bf .ST_VerticalAlignment {if _fab ._cag .Alignment ==nil {return _bf .ST_VerticalAlignmentUnset ;};return _fab ._cag .Alignment .VerticalAttr ;};

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_bbcc *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_dfdc :=_bbcc ._gfae .SheetData .Row ;_eaed :=_bbcc .Rows ();for _egde ,_cbgd :=range _eaed {if _cbgd .RowNumber ()==firstRow {_dfdc =_bbcc ._gfae .SheetData .Row [_egde :];break ;
};};_deff :=Comparer {Order :order };_cd .Slice (_dfdc ,func (_beebe ,_gbdf int )bool {return _deff .LessRows (column ,Row {_bbcc ._fdcd ,_bbcc ,_dfdc [_beebe ]},Row {_bbcc ._fdcd ,_bbcc ,_dfdc [_gbdf ]});});for _cddc ,_cgbcb :=range _bbcc .Rows (){_bfgd :=uint32 (_cddc +1);
if _cgbcb .RowNumber ()!=_bfgd {_cgbcb .renumberAs (_bfgd );};};};func (_dgbc *Sheet )setArray (_eced string ,_cbd _ca .Result )error {_bfcf ,_ggdd :=_dg .ParseCellReference (_eced );if _ggdd !=nil {return _ggdd ;};for _afc ,_caea :=range _cbd .ValueArray {_deed :=_dgbc .Row (_bfcf .RowIdx +uint32 (_afc ));
for _adga ,_edad :=range _caea {_aade :=_deed .Cell (_dg .IndexToColumn (_bfcf .ColumnIdx +uint32 (_adga )));if _edad .Type !=_ca .ResultTypeEmpty {if _edad .IsBoolean {_aade .SetBool (_edad .ValueNumber !=0);}else {_aade .SetCachedFormulaResult (_edad .String ());
};};};};return nil ;};const _afac ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";

// X returns the inner wrapped XML type.
func (_dfba WorkbookProtection )X ()*_bf .CT_WorkbookProtection {return _dfba ._afbb };

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_gfg Drawing )AddChart (at AnchorType )(_cgc .Chart ,Anchor ){_ggdb :=_bb .NewChartSpace ();_gfg ._ecb ._ebfc =append (_gfg ._ecb ._ebfc ,_ggdb );_baa :=_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .ChartContentType ,len (_gfg ._ecb ._ebfc ));
_gfg ._ecb .ContentTypes .AddOverride (_baa ,_f .ChartContentType );var _bdcb string ;for _cgea ,_cbef :=range _gfg ._ecb ._gaffb {if _cbef ==_gfg ._adg {_geb :=_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .DrawingType ,_f .ChartType ,len (_gfg ._ecb ._ebfc ));
_adf :=_gfg ._ecb ._effga [_cgea ].AddRelationship (_geb ,_f .ChartType );_bdcb =_adf .ID ();break ;};};var _cfca Anchor ;var _faed *_ac .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_dbae :=_eaef ();_gfg ._adg .EG_Anchor =append (_gfg ._adg .EG_Anchor ,&_ac .EG_Anchor {AbsoluteAnchor :_dbae });
_dbae .Choice =&_ac .EG_ObjectChoicesChoice {};_dbae .Choice .GraphicFrame =_ac .NewCT_GraphicalObjectFrame ();_faed =_dbae .Choice .GraphicFrame ;_cfca =AbsoluteAnchor {_dbae };case AnchorTypeOneCell :_eabb :=_bbfc ();_gfg ._adg .EG_Anchor =append (_gfg ._adg .EG_Anchor ,&_ac .EG_Anchor {OneCellAnchor :_eabb });
_eabb .Choice =&_ac .EG_ObjectChoicesChoice {};_eabb .Choice .GraphicFrame =_ac .NewCT_GraphicalObjectFrame ();_faed =_eabb .Choice .GraphicFrame ;_cfca =OneCellAnchor {_eabb };case AnchorTypeTwoCell :_abe :=_dfdg ();_gfg ._adg .EG_Anchor =append (_gfg ._adg .EG_Anchor ,&_ac .EG_Anchor {TwoCellAnchor :_abe });
_abe .Choice =&_ac .EG_ObjectChoicesChoice {};_abe .Choice .GraphicFrame =_ac .NewCT_GraphicalObjectFrame ();_faed =_abe .Choice .GraphicFrame ;_cfca =TwoCellAnchor {_abe };};_faed .NvGraphicFramePr =_ac .NewCT_GraphicalObjectFrameNonVisual ();_faed .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_gfg ._adg .EG_Anchor ));
_faed .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_faed .Graphic =_gbb .NewGraphic ();_faed .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";
_ggdcf :=_bb .NewChart ();_ggdcf .IdAttr =_bdcb ;_faed .Graphic .GraphicData .Any =[]_f .Any {_ggdcf };_efa :=_cgc .MakeChart (_ggdb );_efa .Properties ().SetSolidFill (_de .White );_efa .SetDisplayBlanksAs (_bb .ST_DispBlanksAsGap );return _efa ,_cfca ;
};

// CellStyle is a formatting style for a cell. CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_dd *Workbook ;_cag *_bf .CT_Xf ;_fcf *_bf .CT_CellXfs ;};

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_bdcf Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_bdcf .SetNumber (v );_bdcf .SetStyle (_bdcf ._aef .StyleSheet .GetOrCreateStandardNumberFormat (f ));};

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_bcce *_bf .CT_ColorScale };

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_aaa *evalContext )LastRow (col string )int {_gcad :=_aaa ._gaa ;_ebb :=int (_dg .ColumnToIndex (col ));_bebg :=1;for _ ,_bfe :=range _gcad ._gfae .SheetData .Row {if _bfe .RAttr !=nil {_egc :=Row {_gcad ._fdcd ,_gcad ,_bfe };_egb :=len (_egc .Cells ());
if _egb > _ebb {_bebg =int (_egc .RowNumber ());};};};return _bebg ;};

// IsEmpty checks if the cell style contains nothing.
func (_fcbf CellStyle )IsEmpty ()bool {return _fcbf ._dd ==nil ||_fcbf ._cag ==nil ||_fcbf ._fcf ==nil ||_fcbf ._fcf .Xf ==nil ;};

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_fef Cell )SetCachedFormulaResult (s string ){_fef ._faa .V =&s };

// X returns the inner wrapped XML type.
func (_fbg DataValidation )X ()*_bf .CT_DataValidation {return _fbg ._aabc };

// AddView adds a sheet view.
func (_ddfb *Sheet )AddView ()SheetView {if _ddfb ._gfae .SheetViews ==nil {_ddfb ._gfae .SheetViews =_bf .NewCT_SheetViews ();};_ecdf :=_bf .NewCT_SheetView ();_ddfb ._gfae .SheetViews .SheetView =append (_ddfb ._gfae .SheetViews .SheetView ,_ecdf );return SheetView {_ecdf };
};

// Wrapped returns true if the cell will wrap text.
func (_eaba CellStyle )Wrapped ()bool {if _eaba ._cag .Alignment ==nil {return false ;};if _eaba ._cag .Alignment .WrapTextAttr ==nil {return false ;};return *_eaba ._cag .Alignment .WrapTextAttr ;};