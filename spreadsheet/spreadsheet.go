//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_ab "archive/zip";_dd "bytes";_gf "errors";_abb "fmt";_a "github.com/unidoc/unioffice/v2";_ddb "github.com/unidoc/unioffice/v2/chart";_cb "github.com/unidoc/unioffice/v2/color";_bb "github.com/unidoc/unioffice/v2/common";_gb "github.com/unidoc/unioffice/v2/common/logger";
_fa "github.com/unidoc/unioffice/v2/common/tempstorage";_db "github.com/unidoc/unioffice/v2/internal/formatutils";_ff "github.com/unidoc/unioffice/v2/internal/license";_ddde "github.com/unidoc/unioffice/v2/measurement";_df "github.com/unidoc/unioffice/v2/schema/soo/dml";
_ce "github.com/unidoc/unioffice/v2/schema/soo/dml/chart";_cce "github.com/unidoc/unioffice/v2/schema/soo/dml/spreadsheetDrawing";_bc "github.com/unidoc/unioffice/v2/schema/soo/pkg/relationships";_ee "github.com/unidoc/unioffice/v2/schema/soo/sml";_abbg "github.com/unidoc/unioffice/v2/spreadsheet/format";
_ffc "github.com/unidoc/unioffice/v2/spreadsheet/formula";_ffb "github.com/unidoc/unioffice/v2/spreadsheet/reference";_gc "github.com/unidoc/unioffice/v2/spreadsheet/update";_ea "github.com/unidoc/unioffice/v2/vmldrawing";_ed "github.com/unidoc/unioffice/v2/zippkg";
_cg "image";_b "image/jpeg";_d "io";_dca "math";_ddd "math/big";_f "os";_ae "path";_aec "path/filepath";_fb "reflect";_cc "regexp";_g "sort";_dc "strconv";_e "strings";_cd "time";);

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_aabgf *Sheet )AddRow ()Row {_fegcf :=uint32 (0);_face :=uint32 (len (_aabgf ._bbag .SheetData .Row ));if _face > 0&&_aabgf ._bbag .SheetData .Row [_face -1].RAttr !=nil &&*_aabgf ._bbag .SheetData .Row [_face -1].RAttr ==_face {return _aabgf .addNumberedRowFast (_face +1);
};for _ ,_eagf :=range _aabgf ._bbag .SheetData .Row {if _eagf .RAttr !=nil &&*_eagf .RAttr > _fegcf {_fegcf =*_eagf .RAttr ;};};return _aabgf .AddNumberedRow (_fegcf +1);};func _ebcc ()*_cce .CT_OneCellAnchor {_aaec :=_cce .NewCT_OneCellAnchor ();return _aaec };


// SetRowOffset sets the row offset of the top-left anchor.
func (_aaad OneCellAnchor )SetRowOffset (m _ddde .Distance ){_aaad .TopLeft ().SetRowOffset (m )};

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_bdfb PatternFill )SetFgColor (c _cb .Color ){_bdfb ._fegc .FgColor =_ee .NewCT_Color ();_bdfb ._fegc .FgColor .RgbAttr =c .AsRGBAString ();};

// X returns the inner wrapped XML type.
func (_gbfc WorkbookProtection )X ()*_ee .CT_WorkbookProtection {return _gbfc ._cafd };

// SetStyle sets the style to be used for conditional rules
func (_efcf ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_efcf ._ddg .DxfIdAttr =_a .Uint32 (d .Index ());};

// X returns the inner wrapped XML type.
func (_egba RichTextRun )X ()*_ee .CT_RElt {return _egba ._caeb };

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_gadd TwoCellAnchor )SetHeightCells (h int32 ){_gadd .SetHeight (0);_bcbc :=_gadd .TopLeft ();_cda :=_gadd .BottomRight ();_cda .SetRow (_bcbc .Row ()+h );};

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_fbfa Cell )SetCachedFormulaResult (s string ){_fbfa ._ged .V =&s };

// ExtractText returns text from the sheet as a SheetText object.
func (_ceeb *Sheet )ExtractText ()*SheetText {_ffac :=[]CellText {};for _ ,_dcg :=range _ceeb .Rows (){for _ ,_gcff :=range _dcg .Cells (){if !_gcff .IsEmpty (){if _cceff :=_gcff .GetFormattedValue ();_cceff !=""{_ffac =append (_ffac ,CellText {Text :_cceff ,Cell :_gcff });
};};};};return &SheetText {Cells :_ffac };};

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_eecd *Workbook )RemoveSheetByName (name string )error {_dddd :=-1;for _ddfe ,_dcgg :=range _eecd .Sheets (){if name ==_dcgg .Name (){_dddd =_ddfe ;break ;};};if _dddd ==-1{return ErrorNotFound ;};return _eecd .RemoveSheet (_dddd );};func (_beae Fill )Index ()uint32 {if _beae ._dcfd ==nil {return 0;
};for _acfg ,_fafe :=range _beae ._dcfd .Fill {if _beae ._cecec ==_fafe {return uint32 (_acfg );};};return 0;};

// SetFont applies a font to a cell style avoiding redundancy. The function checks if the given font
// already exists in the saved fonts. If found, the existing font is reused; otherwise,
// the new font is added to the saved fonts collection. The font is then applied to the cell style,
// affecting all styles that reference it by index.
func (_gag CellStyle )SetFont (f Font ){_cece :=f ._dcac .Fonts .Font ;for _ ,_bcac :=range _cece {if _fb .DeepEqual (_bcac ,f ._eadf ){f ._eadf =_bcac ;_gag ._beg .FontIdAttr =_a .Uint32 (f .Index ());_gag ._beg .ApplyFontAttr =_a .Bool (true );return ;
};};f ._dcac .Fonts .Font =append (f ._dcac .Fonts .Font ,f ._eadf );f ._dcac .Fonts .CountAttr =_a .Uint32 (uint32 (len (f ._dcac .Fonts .Font )));_gag ._beg .FontIdAttr =_a .Uint32 (f .Index ());_gag ._beg .ApplyFontAttr =_a .Bool (true );};

// SetError sets the cell type to error and the value to the given error message.
func (_gce Cell )SetError (msg string ){_gce .clearValue ();_gce ._ged .V =_a .String (msg );_gce ._ged .TAttr =_ee .ST_CellTypeE ;};

// AnchorType is the type of anchor.
type AnchorType byte ;

// SetCol set the column of the cell marker.
func (_gbc CellMarker )SetCol (col int32 ){_gbc ._fed .Col =col };

// GetDrawing return the worksheet drawing and its relationships if exists.
func (_geaa *Sheet )GetDrawing ()(*_cce .WsDr ,_bb .Relationships ){if _gbce :=_geaa ._bbag .Drawing ;_gbce !=nil {_cfec :=0;for _ ,_ecca :=range _geaa ._edad ._adce {if _aecf :=_ecca .Drawing ;_aecf !=nil {if _ecca ==_geaa ._bbag {return _geaa ._edad ._cefb [_cfec ],_geaa ._edad ._dffd [_cfec ];
};_cfec ++;};};};return nil ,_bb .Relationships {};};

// SetUnderline controls if the run is underlined.
func (_cdff RichTextRun )SetUnderline (u _ee .ST_UnderlineValues ){_cdff .ensureRpr ();for _ ,_ecee :=range _cdff ._caeb .RPr .RPrEltChoice {if _ecee .U !=nil {_ecee .U .ValAttr =u ;return ;};};_cdff ._caeb .RPr .RPrEltChoice =append (_cdff ._caeb .RPr .RPrEltChoice ,&_ee .CT_RPrEltChoice {U :&_ee .CT_UnderlineProperty {ValAttr :u }});
};

// Sheets returns the sheets from the workbook.
func (_gedgg *Workbook )Sheets ()[]Sheet {_efcd :=[]Sheet {};for _egbge ,_bcgg :=range _gedgg ._adce {_bbdf :=_gedgg ._bcbedf .Sheets .Sheet [_egbge ];if _bbdf .StateAttr ==_ee .ST_SheetStateHidden ||_bbdf .StateAttr ==_ee .ST_SheetStateVeryHidden {continue ;
};_caff :=Sheet {_gedgg ,_bbdf ,_bcgg };_efcd =append (_efcd ,_caff );};return _efcd ;};

// AddCommentWithStyle adds a new comment styled in a default way
func (_dae Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_cbf :=_dae .AddComment (cellRef ,author );_eedc :=_cbf .AddRun ();_eedc .SetBold (true );_eedc .SetSize (10);_eedc .SetColor (_cb .Black );_eedc .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");
_eedc .SetText (author +"\u003a");_eedc =_cbf .AddRun ();_eedc .SetSize (10);_eedc .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_eedc .SetColor (_cb .Black );_eedc .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_bed ,_aae :=_ffb .ParseCellReference (cellRef );
if _aae !=nil {return _aae ;};_dae ._dfgg ._aegc [0].Shape =append (_dae ._dfgg ._aegc [0].Shape ,_ea .NewCommentShape (int64 (_bed .ColumnIdx ),int64 (_bed .RowIdx -1)));return nil ;};

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_gfda *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_fdde :=_gfda ._bbag .SheetData .Row ;_fcef :=_gfda .Rows ();for _gbcg ,_dcge :=range _fcef {if _dcge .RowNumber ()==firstRow {_fdde =_gfda ._bbag .SheetData .Row [_gbcg :];break ;
};};_fbfc :=Comparer {Order :order };_g .Slice (_fdde ,func (_edea ,_bdae int )bool {return _fbfc .LessRows (column ,Row {_gfda ._edad ,_gfda ,_fdde [_edea ]},Row {_gfda ._edad ,_gfda ,_fdde [_bdae ]});});for _faee ,_fgba :=range _gfda .Rows (){_dfba :=uint32 (_faee +1);
if _fgba .RowNumber ()!=_dfba {_fgba .renumberAs (_dfba );};};};const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);

// ColOffset returns the offset from the row cell.
func (_eee CellMarker )ColOffset ()_ddde .Distance {if _eee ._fed .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _ddde .Distance (float64 (*_eee ._fed .ColOff .ST_CoordinateUnqualified )*_ddde .EMU );};

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_gg *_cce .CT_AbsoluteAnchor };func (_ddgd *evalContext )Sheet (name string )_ffc .Context {for _ ,_bedc :=range _ddgd ._abf ._edad .Sheets (){if _bedc .Name ()==name {return _bedc .FormulaContext ();};};return _ffc .InvalidReferenceContext ;
};

// GetValueAsBool retrieves the cell's value as a boolean
func (_caef Cell )GetValueAsBool ()(bool ,error ){if _caef ._ged .TAttr !=_ee .ST_CellTypeB {return false ,_gf .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");
};if _caef ._ged .V ==nil {return false ,_gf .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _dc .ParseBool (*_caef ._ged .V );};

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_ggc Cell )SetRichTextString ()RichText {_ggc .clearValue ();_ggc ._ged .Is =_ee .NewCT_Rst ();_ggc ._ged .TAttr =_ee .ST_CellTypeInlineStr ;return RichText {_ggc ._ged .Is };};

// Comments returns the comments for a sheet.
func (_ceba *Sheet )Comments ()Comments {for _bafa ,_bfdb :=range _ceba ._edad ._adce {if _bfdb ==_ceba ._bbag {if _ceba ._edad ._fbda [_bafa ]==nil {_ceba ._edad ._fbda [_bafa ]=_ee .NewComments ();_ceba ._edad ._bggf [_bafa ].AddAutoRelationship (_a .DocTypeSpreadsheet ,_a .WorksheetType ,_bafa +1,_a .CommentsType );
_ceba ._edad .ContentTypes .AddOverride (_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .CommentsType ,_bafa +1),_a .CommentsContentType );};if len (_ceba ._edad ._aegc )==0{_ceba ._edad ._aegc =append (_ceba ._edad ._aegc ,_ea .NewCommentDrawing ());
_fcdg :=_ceba ._edad ._bggf [_bafa ].AddAutoRelationship (_a .DocTypeSpreadsheet ,_a .WorksheetType ,1,_a .VMLDrawingType );if _ceba ._bbag .LegacyDrawing ==nil {_ceba ._bbag .LegacyDrawing =_ee .NewCT_LegacyDrawing ();};_ceba ._bbag .LegacyDrawing .IdAttr =_fcdg .ID ();
};return Comments {_ceba ._edad ,_ceba ._edad ._fbda [_bafa ]};};};_gb .Log .Debug ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");
return Comments {};};

// CellText is used for keeping text with references to a cell where it is located.
type CellText struct{Text string ;Cell Cell ;};

// GetWidth returns a worksheet's column width.
func (_dcaf *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_cga :=range _dcaf ._abf .X ().Cols [0].Col {if int (_cga .MinAttr )<=colIdx &&colIdx <=int (_cga .MaxAttr ){return float64 (int (*_cga .WidthAttr ));};};return 0;};func (_dbd Comments )getOrCreateAuthor (_bcbg string )uint32 {for _bff ,_gaga :=range _dbd ._ede .Authors .Author {if _gaga ==_bcbg {return uint32 (_bff );
};};_feb :=uint32 (len (_dbd ._ede .Authors .Author ));_dbd ._ede .Authors .Author =append (_dbd ._ede .Authors .Author ,_bcbg );return _feb ;};type Fills struct{_ebfc *_ee .CT_Fills };

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_fgd Cell )GetFormattedValue ()string {_bcd :=_fgd .getFormat ();switch _fgd ._ged .TAttr {case _ee .ST_CellTypeB :_bg ,_ :=_fgd .GetValueAsBool ();if _bg {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _ee .ST_CellTypeN :_cefe ,_ :=_fgd .GetValueAsNumber ();
return _abbg .Number (_cefe ,_bcd );case _ee .ST_CellTypeE :if _fgd ._ged .V !=nil {return *_fgd ._ged .V ;};return "";case _ee .ST_CellTypeS ,_ee .ST_CellTypeInlineStr :return _abbg .String (_fgd .GetString (),_bcd );case _ee .ST_CellTypeStr :_ad :=_fgd .GetString ();
if _abbg .IsNumber (_ad ){_bcab ,_ :=_dc .ParseFloat (_ad ,64);return _abbg .Number (_bcab ,_bcd );};return _abbg .String (_ad ,_bcd );case _ee .ST_CellTypeUnset :fallthrough;default:_cag ,_ :=_fgd .GetRawValue ();if len (_cag )==0{return "";};_ddbc ,_bcb :=_fgd .GetValueAsNumber ();
if _bcb ==nil {return _abbg .Number (_ddbc ,_bcd );};return _abbg .String (_cag ,_bcd );};};

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_efbb DataValidationCompare )SetValue (v string ){_efbb ._edg .Formula1 =&v };

// IconScale maps values to icons.
type IconScale struct{_bccd *_ee .CT_IconSet };func (_abec *Sheet )getAllCellsInFormulaArrays (_bddd bool )(map[string ]bool ,error ){_beeb :=_ffc .NewEvaluator ();_aaga :=_abec .FormulaContext ();_fbed :=map[string ]bool {};for _ ,_ggaf :=range _abec .Rows (){for _ ,_edaab :=range _ggaf .Cells (){if _edaab .X ().F !=nil {_bfbb :=_edaab .X ().F .Content ;
if _edaab .X ().F .TAttr ==_ee .ST_CellFormulaTypeArray {_abgaa :=_beeb .Eval (_aaga ,_bfbb ).AsString ();if _abgaa .Type ==_ffc .ResultTypeError {_gb .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_bfbb ,_abgaa .ErrorMessage );
_edaab .X ().V =nil ;};if _abgaa .Type ==_ffc .ResultTypeArray {_efeec ,_cgfb :=_ffb .ParseCellReference (_edaab .Reference ());if _cgfb !=nil {return map[string ]bool {},_cgfb ;};if (_bddd &&len (_abgaa .ValueArray )==1)||(!_bddd &&len (_abgaa .ValueArray [0])==1){continue ;
};for _ccbdg ,_ffadc :=range _abgaa .ValueArray {_eeed :=_efeec .RowIdx +uint32 (_ccbdg );for _fafea :=range _ffadc {_gggb :=_ffb .IndexToColumn (_efeec .ColumnIdx +uint32 (_fafea ));_fbed [_abb .Sprintf ("\u0025\u0073\u0025\u0064",_gggb ,_eeed )]=true ;
};};}else if _abgaa .Type ==_ffc .ResultTypeList {_eeea ,_gbebc :=_ffb .ParseCellReference (_edaab .Reference ());if _gbebc !=nil {return map[string ]bool {},_gbebc ;};if _bddd ||len (_abgaa .ValueList )==1{continue ;};_dgdd :=_eeea .RowIdx ;for _fegfg :=range _abgaa .ValueList {_faba :=_ffb .IndexToColumn (_eeea .ColumnIdx +uint32 (_fegfg ));
_fbed [_abb .Sprintf ("\u0025\u0073\u0025\u0064",_faba ,_dgdd )]=true ;};};};};};};return _fbed ,nil ;};

// GetFont gets a Font from a cell style.
func (_dce CellStyle )GetFont ()*_ee .CT_Font {if _caa :=_dce ._beg .FontIdAttr ;_caa !=nil {_dfde :=_dce ._eae .StyleSheet .Fonts ();if int (*_caa )< len (_dfde ){return _dfde [int (*_caa )].X ();};};return nil ;};func (_gfb Border )SetDiagonal (style _ee .ST_BorderStyle ,c _cb .Color ,up ,down bool ){if _gfb ._cde .Diagonal ==nil {_gfb ._cde .Diagonal =_ee .NewCT_BorderPr ();
};_gfb ._cde .Diagonal .Color =_ee .NewCT_Color ();_gfb ._cde .Diagonal .Color .RgbAttr =c .AsRGBAString ();_gfb ._cde .Diagonal .StyleAttr =style ;if up {_gfb ._cde .DiagonalUpAttr =_a .Bool (true );};if down {_gfb ._cde .DiagonalDownAttr =_a .Bool (true );
};};

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_bef Cell )GetValueAsTime ()(_cd .Time ,error ){if _bef ._ged .TAttr !=_ee .ST_CellTypeUnset {return _cd .Time {},_gf .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");
};if _bef ._ged .V ==nil {return _cd .Time {},_gf .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_ga ,_ ,_dcdf :=_ddd .ParseFloat (*_bef ._ged .V ,10,128,_ddd .ToNearestEven );if _dcdf !=nil {return _cd .Time {},_dcdf ;
};_bec :=new (_ddd .Float );_bec .SetUint64 (uint64 (24*_cd .Hour ));_ga .Mul (_ga ,_bec );_dcc ,_ :=_ga .Uint64 ();_bcba :=_bef ._cfg .Epoch ().Add (_cd .Duration (_dcc ));return _acc (_bcba ),nil ;};func (_dbbb ConditionalFormattingRule )InitializeDefaults (){_dbbb .SetType (_ee .ST_CfTypeCellIs );
_dbbb .SetOperator (_ee .ST_ConditionalFormattingOperatorGreaterThan );_dbbb .SetPriority (1);};

// IsHidden returns whether the row is hidden or not.
func (_daeea Row )IsHidden ()bool {return _daeea ._abbe .HiddenAttr !=nil &&*_daeea ._abbe .HiddenAttr };

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_cedg *Sheet )SetFrozen (firstRow ,firstCol bool ){_cedg ._bbag .SheetViews =nil ;_abbd :=_cedg .AddView ();_abbd .SetState (_ee .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_abbd .SetYSplit (1);_abbd .SetXSplit (1);_abbd .SetTopLeft ("\u0042\u0032");
case firstRow :_abbd .SetYSplit (1);_abbd .SetTopLeft ("\u0041\u0032");case firstCol :_abbd .SetXSplit (1);_abbd .SetTopLeft ("\u0042\u0031");};};

// TopLeft is a no-op.
func (_ba AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};func _acc (_geg _cd .Time )_cd .Time {_geg =_geg .UTC ();return _cd .Date (_geg .Year (),_geg .Month (),_geg .Day (),_geg .Hour (),_geg .Minute (),_geg .Second (),_geg .Nanosecond (),_cd .Local );
};

// SetReference sets the regin of cells that the merged cell applies to.
func (_cdge MergedCell )SetReference (ref string ){_cdge ._bcfc .RefAttr =ref };

// SetColOffset sets the column offset of the two cell anchor.
func (_dbebe TwoCellAnchor )SetColOffset (m _ddde .Distance ){_ege :=m -_dbebe .TopLeft ().ColOffset ();_dbebe .TopLeft ().SetColOffset (m );_dbebe .BottomRight ().SetColOffset (_dbebe .BottomRight ().ColOffset ()+_ege );};func (_gcf Border )SetRight (style _ee .ST_BorderStyle ,c _cb .Color ){if _gcf ._cde .Right ==nil {_gcf ._cde .Right =_ee .NewCT_BorderPr ();
};_gcf ._cde .Right .Color =_ee .NewCT_Color ();_gcf ._cde .Right .Color .RgbAttr =c .AsRGBAString ();_gcf ._cde .Right .StyleAttr =style ;};

// Priority returns the rule priority
func (_dbdb ConditionalFormattingRule )Priority ()int32 {return _dbdb ._ddg .PriorityAttr };func (_dgab StyleSheet )appendFont ()Font {_bbgfa :=_ee .NewCT_Font ();_dgab ._dbdd .Fonts .Font =append (_dgab ._dbdd .Fonts .Font ,_bbgfa );_dgab ._dbdd .Fonts .CountAttr =_a .Uint32 (uint32 (len (_dgab ._dbdd .Fonts .Font )));
return Font {_bbgfa ,_dgab ._dbdd };};func (_gbed *Sheet )removeColumnFromNamedRanges (_ggge uint32 )error {for _ ,_cgcdc :=range _gbed ._edad .DefinedNames (){_efea :=_cgcdc .Name ();_fbge :=_cgcdc .Content ();_bcfad :=_e .Split (_fbge ,"\u0021");if len (_bcfad )!=2{return _gf .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_fbge );
};_gfdeg :=_bcfad [0];if _gbed .Name ()==_gfdeg {_bdcf :=_gbed ._edad .RemoveDefinedName (_cgcdc );if _bdcf !=nil {return _bdcf ;};_dgdee :=_fge (_bcfad [1],_ggge ,true );if _dgdee !=""{_adfa :=_gfdeg +"\u0021"+_dgdee ;_gbed ._edad .AddDefinedName (_efea ,_adfa );
};};};_afdg :=0;if _gbed ._bbag .TableParts !=nil &&_gbed ._bbag .TableParts .TablePart !=nil {_afdg =len (_gbed ._bbag .TableParts .TablePart );};if _afdg !=0{_efeg :=0;for _ ,_beaeg :=range _gbed ._edad .Sheets (){if _beaeg .Name ()==_gbed .Name (){break ;
}else {if _beaeg ._bbag .TableParts !=nil &&_beaeg ._bbag .TableParts .TablePart !=nil {_efeg +=len (_beaeg ._bbag .TableParts .TablePart );};};};_cgba :=_gbed ._edad ._dege [_efeg :_efeg +_afdg ];for _fgaeb ,_adee :=range _cgba {_ddge :=_adee ;_ddge .RefAttr =_fge (_ddge .RefAttr ,_ggge ,false );
_gbed ._edad ._dege [_efeg +_fgaeb ]=_ddge ;};};return nil ;};

// SetColor sets teh color of the databar.
func (_dfaf DataBarScale )SetColor (c _cb .Color ){_dfaf ._dgg .Color =_ee .NewCT_Color ();_dfaf ._dgg .Color .RgbAttr =c .AsRGBAString ();};type Table struct{_gbba *_ee .Table };const (DVCompareTypeWholeNumber =DVCompareType (_ee .ST_DataValidationTypeWhole );
DVCompareTypeDecimal =DVCompareType (_ee .ST_DataValidationTypeDecimal );DVCompareTypeDate =DVCompareType (_ee .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_ee .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_ee .ST_DataValidationTypeTextLength );
);

// RemoveSheet removes the sheet with the given index from the workbook.
func (_feaf *Workbook )RemoveSheet (ind int )error {if _feaf .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_ceadf :=range _feaf ._afafd .Relationships (){if _ceadf .ID ()==_feaf ._bcbedf .Sheets .Sheet [ind ].IdAttr {_feaf ._afafd .Remove (_ceadf );
break ;};};_feaf .ContentTypes .RemoveOverride (_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .WorksheetContentType ,ind +1));copy (_feaf ._adce [ind :],_feaf ._adce [ind +1:]);_feaf ._adce =_feaf ._adce [:len (_feaf ._adce )-1];_abce :=_feaf ._bcbedf .Sheets .Sheet [ind ];
copy (_feaf ._bcbedf .Sheets .Sheet [ind :],_feaf ._bcbedf .Sheets .Sheet [ind +1:]);_feaf ._bcbedf .Sheets .Sheet =_feaf ._bcbedf .Sheets .Sheet [:len (_feaf ._bcbedf .Sheets .Sheet )-1];for _bgag :=range _feaf ._bcbedf .Sheets .Sheet {if _feaf ._bcbedf .Sheets .Sheet [_bgag ].SheetIdAttr > _abce .SheetIdAttr {_feaf ._bcbedf .Sheets .Sheet [_bgag ].SheetIdAttr --;
};};copy (_feaf ._bggf [ind :],_feaf ._bggf [ind +1:]);_feaf ._bggf =_feaf ._bggf [:len (_feaf ._bggf )-1];copy (_feaf ._fbda [ind :],_feaf ._fbda [ind +1:]);_feaf ._fbda =_feaf ._fbda [:len (_feaf ._fbda )-1];return nil ;};

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_ffe Cell )SetFormulaArray (s string ){_dfb :=_ffc .ParseString (s );if _dfb ==nil {return ;};_ffe .clearValue ();_ffe ._ged .TAttr =_ee .ST_CellTypeStr ;_ffe ._ged .F =_ee .NewCT_CellFormula ();_ffe ._ged .F .TAttr =_ee .ST_CellFormulaTypeArray ;
_ffe ._ged .F .Content =s ;};

// SheetText is an array of extracted text items which has some methods for representing extracted text from a sheet.
type SheetText struct{Cells []CellText ;};

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_egge Row )Cells ()[]Cell {_fgdae :=[]Cell {};_bgga :=-1;_gedc :=append ([]*_ee .CT_Cell {},_egge ._abbe .C ...);for _ ,_gea :=range _gedc {if _gea .RAttr ==nil {_gb .Log .Debug ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
continue ;};_bbfce ,_gda :=_ffb .ParseCellReference (*_gea .RAttr );if _gda !=nil {_gb .Log .Debug ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_gea .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
continue ;};_fdac :=int (_bbfce .ColumnIdx );if _fdac -_bgga > 1{for _bbb :=_bgga +1;_bbb < _fdac ;_bbb ++{_fgdae =append (_fgdae ,_egge .Cell (_ffb .IndexToColumn (uint32 (_bbb ))));};};_bgga =_fdac ;_fgdae =append (_fgdae ,Cell {_egge ._gbgf ,_egge ._baec ,_egge ._abbe ,_gea });
};return _fgdae ;};

// X returns the inner XML entity for a stylesheet.
func (_cbcc StyleSheet )X ()*_ee .StyleSheet {return _cbcc ._dbdd };const (_faeea ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";
_fcec ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";
_gdfb ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";
_ebaa ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";
);

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_cfag *Sheet )InitialView ()SheetView {if _cfag ._bbag .SheetViews ==nil ||len (_cfag ._bbag .SheetViews .SheetView )==0{return _cfag .AddView ();};return SheetView {_cfag ._bbag .SheetViews .SheetView [0]};};

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_ace *_ee .CT_Col };

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_bb .DocBase ;_bcbedf *_ee .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_fbda []*_ee .Comments ;_adce []*_ee .Worksheet ;_bggf []_bb .Relationships ;_afafd _bb .Relationships ;_gdgc []*_df .Theme ;_cefb []*_cce .WsDr ;
_dffd []_bb .Relationships ;_aegc []*_ea .Container ;_gceec []*_ce .ChartSpace ;_dege []*_ee .Table ;_bcgeg string ;_bacf map[string ]string ;_fged map[string ]*_ce .ChartSpace ;_cdaa string ;};

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_ffbf Drawing )AddChart (at AnchorType )(_ddb .Chart ,Anchor ){_gedb :=_ce .NewChartSpace ();_ffbf ._ffcd ._gceec =append (_ffbf ._ffcd ._gceec ,_gedb );_ega :=_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .ChartContentType ,len (_ffbf ._ffcd ._gceec ));
_ffbf ._ffcd .ContentTypes .AddOverride (_ega ,_a .ChartContentType );var _cfe string ;for _fad ,_babb :=range _ffbf ._ffcd ._cefb {if _babb ==_ffbf ._aaedc {_adeg :=_a .RelativeFilename (_a .DocTypeSpreadsheet ,_a .DrawingType ,_a .ChartType ,len (_ffbf ._ffcd ._gceec ));
_ddba :=_ffbf ._ffcd ._dffd [_fad ].AddRelationship (_adeg ,_a .ChartType );_cfe =_ddba .ID ();break ;};};var _gad Anchor ;var _fgfdb *_cce .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_bgcd :=_bgfb ();_ffbf ._aaedc .EG_Anchor =append (_ffbf ._aaedc .EG_Anchor ,&_cce .EG_Anchor {AnchorChoice :&_cce .EG_AnchorChoice {AbsoluteAnchor :_bgcd }});
_bgcd .ObjectChoicesChoice =&_cce .EG_ObjectChoicesChoice {};_bgcd .ObjectChoicesChoice .GraphicFrame =_cce .NewCT_GraphicalObjectFrame ();_fgfdb =_bgcd .ObjectChoicesChoice .GraphicFrame ;_gad =AbsoluteAnchor {_bgcd };case AnchorTypeOneCell :_bgb :=_ebcc ();
_ffbf ._aaedc .EG_Anchor =append (_ffbf ._aaedc .EG_Anchor ,&_cce .EG_Anchor {AnchorChoice :&_cce .EG_AnchorChoice {OneCellAnchor :_bgb }});_bgb .ObjectChoicesChoice =&_cce .EG_ObjectChoicesChoice {};_bgb .ObjectChoicesChoice .GraphicFrame =_cce .NewCT_GraphicalObjectFrame ();
_fgfdb =_bgb .ObjectChoicesChoice .GraphicFrame ;_gad =OneCellAnchor {_bgb };case AnchorTypeTwoCell :_efdf :=_affb ();_ffbf ._aaedc .EG_Anchor =append (_ffbf ._aaedc .EG_Anchor ,&_cce .EG_Anchor {AnchorChoice :&_cce .EG_AnchorChoice {TwoCellAnchor :_efdf }});
_efdf .ObjectChoicesChoice =&_cce .EG_ObjectChoicesChoice {};_efdf .ObjectChoicesChoice .GraphicFrame =_cce .NewCT_GraphicalObjectFrame ();_fgfdb =_efdf .ObjectChoicesChoice .GraphicFrame ;_gad =TwoCellAnchor {_efdf };};_fgfdb .NvGraphicFramePr =_cce .NewCT_GraphicalObjectFrameNonVisual ();
_fgfdb .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_ffbf ._aaedc .EG_Anchor ));_fgfdb .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_fgfdb .Graphic =_df .NewGraphic ();_fgfdb .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";
_fggf :=_ce .NewChart ();_fggf .IdAttr =_cfe ;_fgfdb .Graphic .GraphicData .Any =[]_a .Any {_fggf };_aebc :=_ddb .MakeChart (_gedb );_aebc .Properties ().SetSolidFill (_cb .White );_aebc .SetDisplayBlanksAs (_ce .ST_DispBlanksAsGap );return _aebc ,_gad ;
};

// TopLeft returns the top-left corner of the anchored object.
func (_abga OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_abga ._adf .From }};

// IsSheetLocked returns whether the sheet is locked.
func (_bbfgd SheetProtection )IsSheetLocked ()bool {return _bbfgd ._bbaf .SheetAttr !=nil &&*_bbfgd ._bbaf .SheetAttr ;};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_bce *Sheet )ClearSheetViews (){_bce ._bbag .SheetViews =nil };

// MaxColumnIdx returns the max used column of the sheet.
func (_ada Sheet )MaxColumnIdx ()uint32 {_aecc :=uint32 (0);for _ ,_bbfg :=range _ada .Rows (){_caf :=_bbfg ._abbe .C ;if len (_caf )> 0{_egaf :=_caf [len (_caf )-1];_fgae ,_ :=_ffb .ParseCellReference (*_egaf .RAttr );if _aecc < _fgae .ColumnIdx {_aecc =_fgae .ColumnIdx ;
};};};return _aecc ;};

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_cggg *Workbook )SetActiveSheet (s Sheet ){for _debdf ,_gdeb :=range _cggg ._adce {if s ._bbag ==_gdeb {_cggg .SetActiveSheetIndex (uint32 (_debdf ));};};};

// AddView adds a sheet view.
func (_gedg *Sheet )AddView ()SheetView {if _gedg ._bbag .SheetViews ==nil {_gedg ._bbag .SheetViews =_ee .NewCT_SheetViews ();};_dcdb :=_ee .NewCT_SheetView ();_gedg ._bbag .SheetViews .SheetView =append (_gedg ._bbag .SheetViews .SheetView ,_dcdb );return SheetView {_dcdb };
};

// SetSize sets the text size for a rich text run.
func (_cdcg RichTextRun )SetSize (m _ddde .Distance ){_cdcg .ensureRpr ();_abfb :=float64 (m /_ddde .Point );for _ ,_dbcb :=range _cdcg ._caeb .RPr .RPrEltChoice {if _dbcb .Sz !=nil {_dbcb .Sz .ValAttr =_abfb ;return ;};};_cdcg ._caeb .RPr .RPrEltChoice =append (_cdcg ._caeb .RPr .RPrEltChoice ,&_ee .CT_RPrEltChoice {Sz :&_ee .CT_FontSize {ValAttr :_abfb }});
};

// X returns the inner wrapped XML type.
func (_eedcg Drawing )X ()*_cce .WsDr {return _eedcg ._aaedc };func (_fc Cell )getLocked ()bool {if _fc ._ged .SAttr ==nil {return false ;};_ded :=*_fc ._ged .SAttr ;_dab :=_fc ._cfg .StyleSheet .GetCellStyle (_ded );return *_dab ._beg .Protection .LockedAttr ;
};var ErrorNotFound =_gf .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// SetHidden marks the defined name as hidden.
func (_ccaa DefinedName )SetLocalSheetID (id uint32 ){_ccaa ._degb .LocalSheetIdAttr =_a .Uint32 (id )};func (_fbbc Sheet )IsValid ()bool {return _fbbc ._bbag !=nil };

// StandardFormat is a standard ECMA 376 number format.
//
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_ecbfg Comparer )LessCells (lhs ,rhs Cell )bool {if _ecbfg .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_acfa ,_ecbg :=lhs .getRawSortValue ();
_eeb ,_gdd :=rhs .getRawSortValue ();switch {case _ecbg &&_gdd :_aag ,_ :=_dc .ParseFloat (_acfa ,64);_eea ,_ :=_dc .ParseFloat (_eeb ,64);return _aag < _eea ;case _ecbg :return true ;case _gdd :return false ;};_acfa =lhs .GetFormattedValue ();_eeb =rhs .GetFormattedValue ();
return _acfa < _eeb ;};

// X returns the inner wrapped XML type.
func (_edb Comments )X ()*_ee .Comments {return _edb ._ede };func (_agbb Sheet )validateRowCellNumbers ()error {_dgdb :=map[uint32 ]struct{}{};for _ ,_afab :=range _agbb ._bbag .SheetData .Row {if _afab .RAttr !=nil {if _ ,_fdcf :=_dgdb [*_afab .RAttr ];
_fdcf {return _abb .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_agbb .Name (),*_afab .RAttr );};_dgdb [*_afab .RAttr ]=struct{}{};};_bgge :=map[string ]struct{}{};for _ ,_deae :=range _afab .C {if _deae .RAttr ==nil {continue ;
};if _ ,_bbd :=_bgge [*_deae .RAttr ];_bbd {return _abb .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_agbb .Name (),*_deae .RAttr );};_bgge [*_deae .RAttr ]=struct{}{};};};return nil ;
};

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_edg *_ee .CT_DataValidation };func (_beba SortOrder )String ()string {if _beba >=SortOrder (len (_bdbf )-1){return _abb .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_beba );
};return _cbcdd [_bdbf [_beba ]:_bdbf [_beba +1]];};

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_bfdc *Sheet )Row (rowNum uint32 )Row {for _ ,_gbb :=range _bfdc ._bbag .SheetData .Row {if _gbb .RAttr !=nil &&*_gbb .RAttr ==rowNum {return Row {_bfdc ._edad ,_bfdc ,_gbb };};};return _bfdc .AddNumberedRow (rowNum );};

// SetOperator sets the operator for the rule.
func (_fcg ConditionalFormattingRule )SetOperator (t _ee .ST_ConditionalFormattingOperator ){_fcg ._ddg .OperatorAttr =t ;};

// GetString retrieves a string from the shared strings table by index.
func (_cbea SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_abb .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );
};if id > len (_cbea ._aggf .Si )-1{return "",_abb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_cbea ._aggf .Si ));
};_gfag :=_cbea ._aggf .Si [id ];if _gfag .T !=nil {return *_gfag .T ,nil ;};_dcga :="";for _ ,_fgfee :=range _gfag .R {if _fgfee .T !=""{_dcga +=_fgfee .T ;};};return _dcga ,nil ;};

// SetPattern sets the pattern of the fill.
func (_dgga PatternFill )SetPattern (p _ee .ST_PatternType ){_dgga ._fegc .PatternTypeAttr =p };

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_bbcef *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_cbda :=-1;for _aadc ,_ecge :=range _bbcef .Sheets (){if name ==_ecge .Name (){_cbda =_aadc ;break ;};};if _cbda ==-1{return Sheet {},ErrorNotFound ;};return _bbcef .CopySheet (_cbda ,copiedSheetName );
};

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_aabc *Workbook )RemoveCalcChain (){var _ceed string ;for _ ,_cgbf :=range _aabc ._afafd .Relationships (){if _cgbf .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_ceed ="\u0078\u006c\u002f"+_cgbf .Target ();
_aabc ._afafd .Remove (_cgbf );break ;};};if _ceed ==""{return ;};_aabc .ContentTypes .RemoveOverride (_ceed );for _ggfd ,_edde :=range _aabc .ExtraFiles {if _edde .ZipPath ==_ceed {_aabc .ExtraFiles [_ggfd ]=_aabc .ExtraFiles [len (_aabc .ExtraFiles )-1];
_aabc .ExtraFiles =_aabc .ExtraFiles [:len (_aabc .ExtraFiles )-1];return ;};};};

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_affbf *Sheet )SheetViews ()[]SheetView {if _affbf ._bbag .SheetViews ==nil {return nil ;};_fagb :=[]SheetView {};for _ ,_eddf :=range _affbf ._bbag .SheetViews .SheetView {_fagb =append (_fagb ,SheetView {_eddf });};return _fagb ;};

// BottomRight is a no-op.
func (_dbb AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_bade *Workbook )GetFilename ()string {return _bade ._bcgeg };

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_fac Cell )SetFormulaRaw (s string ){_bca :=_ffc .ParseString (s );if _bca ==nil {return ;};_fac .clearValue ();_fac ._ged .TAttr =_ee .ST_CellTypeStr ;_fac ._ged .F =_ee .NewCT_CellFormula ();_fac ._ged .F .Content =s ;};func (_efbd Sheet )validateMergedCells ()error {_bgcg :=map[uint64 ]struct{}{};
for _ ,_bddc :=range _efbd .MergedCells (){_aeef ,_bbeg ,_ffbb :=_ffb .ParseRangeReference (_bddc .Reference ());if _ffbb !=nil {return _abb .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_efbd .Name (),_bddc .Reference ());
};for _gedcg :=_aeef .RowIdx ;_gedcg <=_bbeg .RowIdx ;_gedcg ++{for _fecg :=_aeef .ColumnIdx ;_fecg <=_bbeg .ColumnIdx ;_fecg ++{_cbbba :=uint64 (_gedcg )<<32|uint64 (_fecg );if _ ,_afdf :=_bgcg [_cbbba ];_afdf {return _abb .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_efbd .Name ());
};_bgcg [_cbbba ]=struct{}{};};};};return nil ;};

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_aggf :_ee .NewSst (),_bagg :make (map[string ]int )};};func (_ebe PatternFill )X ()*_ee .CT_PatternFill {return _ebe ._fegc };

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_bffb Comments )AddComment (cellRef string ,author string )RichText {_efe :=_ee .NewCT_Comment ();_bffb ._ede .CommentList .Comment =append (_bffb ._ede .CommentList .Comment ,_efe );_efe .RefAttr =cellRef ;_efe .AuthorIdAttr =_bffb .getOrCreateAuthor (author );
_efe .Text =_ee .NewCT_Rst ();return RichText {_efe .Text };};

// GetLocked returns true if the cell is locked.
func (_gaa *evalContext )GetLocked (cellRef string )bool {return _gaa ._abf .Cell (cellRef ).getLocked ()};

// IsBool returns true if the cell boolean value.
func (_bea *evalContext )IsBool (cellRef string )bool {return _bea ._abf .Cell (cellRef ).IsBool ()};

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_fec Comment )SetAuthor (author string ){_fec ._eba .AuthorIdAttr =Comments {_fec ._aga ,_fec ._ddda }.getOrCreateAuthor (author );};

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_fbc Cell )SetDate (d _cd .Time ){_fbc .clearValue ();d =_dgd (d );_eaae :=_fbc ._cfg .Epoch ();if d .Before (_eaae ){_gb .Log .Debug ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");
return ;};_aab :=d .Sub (_eaae );_aee :=new (_ddd .Float );_dddg :=new (_ddd .Float );_dddg .SetPrec (128);_dddg .SetUint64 (uint64 (_aab ));_dga :=new (_ddd .Float );_dga .SetUint64 (24*60*60*1e9);_aee .Quo (_dddg ,_dga );_gef ,_ :=_aee .Uint64 ();_fbc ._ged .V =_a .Stringf ("\u0025\u0064",_gef );
};type evalContext struct{_abf *Sheet ;_bedf ,_dcef uint32 ;_adbd map[string ]struct{};};func (_edee *Sheet )removeColumnFromMergedCells (_abdb uint32 )error {if _edee ._bbag .MergeCells ==nil ||_edee ._bbag .MergeCells .MergeCell ==nil {return nil ;};
_gfdbb :=[]*_ee .CT_MergeCell {};for _ ,_beef :=range _edee .MergedCells (){_fecge :=_fge (_beef .Reference (),_abdb ,true );if _fecge !=""{_beef .SetReference (_fecge );_gfdbb =append (_gfdbb ,_beef .X ());};};_edee ._bbag .MergeCells .MergeCell =_gfdbb ;
return nil ;};

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_cfgb *_ee .CT_ConditionalFormatting };

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_fdbc StyleSheet )RemoveFont (f Font )error {for _acbbe ,_caec :=range _fdbc ._dbdd .Fonts .Font {if _caec ==f .X (){_fdbc ._dbdd .Fonts .Font =append (_fdbc ._dbdd .Fonts .Font [:_acbbe ],_fdbc ._dbdd .Fonts .Font [_acbbe +1:]...);return nil ;};
};return _gf .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// GetEpoch returns a workbook's time epoch.
func (_cee *evalContext )GetEpoch ()_cd .Time {return _cee ._abf ._edad .Epoch ()};

// IsDBCS returns if a workbook's default language is among DBCS.
func (_fgda *evalContext )IsDBCS ()bool {_ebc :=_fgda ._abf ._edad .CoreProperties .X ().Language ;if _ebc ==nil {return false ;};_bbf :=string (_ebc .Data );for _ ,_bebd :=range _bgf {if _bbf ==_bebd {return true ;};};return false ;};

// SetBorder applies a border to a cell style avoiding redundancy. The function checks if the given border
// already exists in the saved borders. If found, the existing border is reused; otherwise,
// the new border is added to the saved borders collection. The border is then applied to the cell style,
// affecting all styles that reference it by index.
func (_agf CellStyle )SetBorder (b Border ){_acf :=b ._cf .Border ;for _ ,_gcfg :=range _acf {if _fb .DeepEqual (_gcfg ,b ._cde ){b ._cde =_gcfg ;_agf ._beg .BorderIdAttr =_a .Uint32 (b .Index ());_agf ._beg .ApplyBorderAttr =_a .Bool (true );return ;};
};b ._cf .Border =append (b ._cf .Border ,b ._cde );b ._cf .CountAttr =_a .Uint32 (uint32 (len (b ._cf .Border )));_agf ._beg .BorderIdAttr =_a .Uint32 (b .Index ());_agf ._beg .ApplyBorderAttr =_a .Bool (true );};

// SetWidthCells is a no-op.
func (_ef AbsoluteAnchor )SetWidthCells (int32 ){};func (_ebd DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_ebd .clear ();_ebd ._abdc .TypeAttr =_ee .ST_DataValidationType (t );_ebd ._abdc .OperatorAttr =_ee .ST_DataValidationOperator (op );
return DataValidationCompare {_ebd ._abdc };};

// Col returns the column of the cell marker.
func (_ddf CellMarker )Col ()int32 {return _ddf ._fed .Col };

// Protection allows control over the workbook protections.
func (_abgb *Workbook )Protection ()WorkbookProtection {if _abgb ._bcbedf .WorkbookProtection ==nil {_abgb ._bcbedf .WorkbookProtection =_ee .NewCT_WorkbookProtection ();};return WorkbookProtection {_abgb ._bcbedf .WorkbookProtection };};

// Column returns the cell column
func (_ecb Cell )Column ()(string ,error ){_dcd ,_de :=_ffb .ParseCellReference (_ecb .Reference ());if _de !=nil {return "",_de ;};return _dcd .Column ,nil ;};

// AddRule adds and returns a new rule that can be configured.
func (_agg ConditionalFormatting )AddRule ()ConditionalFormattingRule {_fgbg :=_ee .NewCT_CfRule ();_agg ._cfgb .CfRule =append (_agg ._cfgb .CfRule ,_fgbg );_abc :=ConditionalFormattingRule {_fgbg };_abc .InitializeDefaults ();_abc .SetPriority (int32 (len (_agg ._cfgb .CfRule )+1));
return _abc ;};var _bgf []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};

// DataValidation controls cell validation
type DataValidation struct{_abdc *_ee .CT_DataValidation };

// X returns the inner wrapped XML type.
func (_gfgdd *Workbook )X ()*_ee .Workbook {return _gfgdd ._bcbedf };

// GetFilename returns the filename of the context's workbook.
func (_degd *evalContext )GetFilename ()string {return _degd ._abf ._edad .GetFilename ()};func (_gab *evalContext )SetOffset (col ,row uint32 ){_gab ._bedf =col ;_gab ._dcef =row };

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_dedde *_cce .CT_TwoCellAnchor };

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_dfgd *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _dfgd .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _ggbda _bb .Relationship ;for _ ,_gacbg :=range _dfgd ._afafd .Relationships (){if _gacbg .ID ()==_dfgd ._bcbedf .Sheets .Sheet [ind ].IdAttr {var _fdbf bool ;
if _ggbda ,_fdbf =_dfgd ._afafd .CopyRelationship (_gacbg .ID ());!_fdbf {return Sheet {},ErrorNotFound ;};break ;};};_dfgd .ContentTypes .CopyOverride (_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .WorksheetContentType ,ind +1),_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .WorksheetContentType ,len (_dfgd .ContentTypes .X ().TypesChoice )));
_fbbe :=*_dfgd ._adce [ind ];_dfgd ._adce =append (_dfgd ._adce ,&_fbbe );var _adg uint32 =0;for _ ,_eecg :=range _dfgd ._bcbedf .Sheets .Sheet {if _eecg .SheetIdAttr > _adg {_adg =_eecg .SheetIdAttr ;};};_adg ++;_gfcf :=*_dfgd ._bcbedf .Sheets .Sheet [ind ];
_gfcf .IdAttr =_ggbda .ID ();_gfcf .NameAttr =copiedSheetName ;_gfcf .SheetIdAttr =_adg ;_dfgd ._bcbedf .Sheets .Sheet =append (_dfgd ._bcbedf .Sheets .Sheet ,&_gfcf );_facd :=_bb .NewRelationshipsCopy (_dfgd ._bggf [ind ]);_dfgd ._bggf =append (_dfgd ._bggf ,_facd );
_aede :=_dfgd ._fbda [ind ];if _aede ==nil {_dfgd ._fbda =append (_dfgd ._fbda ,nil );}else {_fbcg :=*_aede ;_dfgd ._fbda =append (_dfgd ._fbda ,&_fbcg );};_eff :=Sheet {_dfgd ,&_gfcf ,&_fbbe };return _eff ,nil ;};type ConditionalFormattingRule struct{_ddg *_ee .CT_CfRule };


// X returns the inner wrapped XML type.
func (_feec Font )X ()*_ee .CT_Font {return _feec ._eadf };func (_ecbf Cell )getLabelPrefix ()string {if _ecbf ._ged .SAttr ==nil {return "";};_ceaa :=*_ecbf ._ged .SAttr ;_bd :=_ecbf ._cfg .StyleSheet .GetCellStyle (_ceaa );switch _bd ._beg .Alignment .HorizontalAttr {case _ee .ST_HorizontalAlignmentLeft :return "\u0027";
case _ee .ST_HorizontalAlignmentRight :return "\u0022";case _ee .ST_HorizontalAlignmentCenter :return "\u005e";case _ee .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_fbdg *Workbook )RecalculateFormulas (){for _ ,_ddgg :=range _fbdg .Sheets (){_ddgg .RecalculateFormulas ();};};

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_gded :=uint16 (0);if len (s )> 0{for _cfed :=len (s )-1;_cfed >=0;_cfed --{_bdfg :=s [_cfed ];_gded =((_gded >>14)&0x01)|((_gded <<1)&0x7fff);_gded ^=uint16 (_bdfg );};_gded =((_gded >>14)&0x01)|((_gded <<1)&0x7fff);
_gded ^=uint16 (len (s ));_gded ^=(0x8000|('N'<<8)|'K');};return _abb .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_gded ));};

// Row returns the row of the cell marker.
func (_aad CellMarker )Row ()int32 {return _aad ._fed .Row };

// AddFormatValue adds a format value to be used to determine the cell background.
func (_ade ColorScale )AddFormatValue (t _ee .ST_CfvoType ,val string ){_aeae :=_ee .NewCT_Cfvo ();_aeae .TypeAttr =t ;_aeae .ValAttr =_a .String (val );_ade ._fag .Cfvo =append (_ade ._fag .Cfvo ,_aeae );};

// SetWrapped configures the cell to wrap text.
func (_cdea CellStyle )SetWrapped (b bool ){if _cdea ._beg .Alignment ==nil {_cdea ._beg .Alignment =_ee .NewCT_CellAlignment ();};if !b {_cdea ._beg .Alignment .WrapTextAttr =nil ;}else {_cdea ._beg .Alignment .WrapTextAttr =_a .Bool (true );_cdea ._beg .ApplyAlignmentAttr =_a .Bool (true );
};};

// X returns the inner wrapped XML type.
func (_bebc DataValidation )X ()*_ee .CT_DataValidation {return _bebc ._abdc };

// SetTopLeft sets the top left visible cell after the split.
func (_dbed SheetView )SetTopLeft (cellRef string ){_dbed .ensurePane ();_dbed ._ceda .Pane .TopLeftCellAttr =&cellRef ;};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_bbe CellStyle )NumberFormat ()uint32 {if _bbe ._beg .NumFmtIdAttr ==nil {return 0;};return *_bbe ._beg .NumFmtIdAttr ;};

// AddMergedCells merges cells within a sheet.
func (_egbg *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _egbg ._bbag .MergeCells ==nil {_egbg ._bbag .MergeCells =_ee .NewCT_MergeCells ();};_gcce :=_ee .NewCT_MergeCell ();_gcce .RefAttr =_abb .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );
_egbg ._bbag .MergeCells .MergeCell =append (_egbg ._bbag .MergeCells .MergeCell ,_gcce );_egbg ._bbag .MergeCells .CountAttr =_a .Uint32 (uint32 (len (_egbg ._bbag .MergeCells .MergeCell )));return MergedCell {_egbg ._edad ,_egbg ,_gcce };};

// X returns the inner wrapped XML type.
func (_gdf DataBarScale )X ()*_ee .CT_DataBar {return _gdf ._dgg };

// X returns the inner wrapped XML type.
func (_fggd DifferentialStyle )X ()*_ee .CT_Dxf {return _fggd ._efef };

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_bcc CellStyle )SetNumberFormatStandard (s StandardFormat ){_bcc ._beg .NumFmtIdAttr =_a .Uint32 (uint32 (s ));_bcc ._beg .ApplyNumberFormatAttr =_a .Bool (true );};

// AddFormatValue adds a format value (databars require two).
func (_fcga DataBarScale )AddFormatValue (t _ee .ST_CfvoType ,val string ){_adcf :=_ee .NewCT_Cfvo ();_adcf .TypeAttr =t ;_adcf .ValAttr =_a .String (val );_fcga ._dgg .Cfvo =append (_fcga ._dgg .Cfvo ,_adcf );};func (_fda Border )SetBottom (style _ee .ST_BorderStyle ,c _cb .Color ){if _fda ._cde .Bottom ==nil {_fda ._cde .Bottom =_ee .NewCT_BorderPr ();
};_fda ._cde .Bottom .Color =_ee .NewCT_Color ();_fda ._cde .Bottom .Color .RgbAttr =c .AsRGBAString ();_fda ._cde .Bottom .StyleAttr =style ;};

// SetValues sets the possible values. This is incompatible with SetRange.
func (_gacb DataValidationList )SetValues (values []string ){_gacb ._cgb .Formula1 =_a .String ("\u0022"+_e .Join (values ,"\u002c")+"\u0022");_gacb ._cgb .Formula2 =_a .String ("\u0030");};

// HasFormula returns true if the cell has an asoociated formula.
func (_fbb Cell )HasFormula ()bool {return _fbb ._ged .F !=nil };func (_eceb Fills )appendFill ()Fill {_ddbca :=_ee .NewCT_Fill ();_eceb ._ebfc .Fill =append (_eceb ._ebfc .Fill ,_ddbca );_eceb ._ebfc .CountAttr =_a .Uint32 (uint32 (len (_eceb ._ebfc .Fill )));
return Fill {_ddbca ,_eceb ._ebfc };};

// Type returns the type of anchor
func (_bcf AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_dgde *evalContext )LastColumn (rowFrom ,rowTo int )string {_gddc :=_dgde ._abf ;_aeb :=1;for _ceb :=rowFrom ;_ceb <=rowTo ;_ceb ++{_bdf :=len (_gddc .Row (uint32 (_ceb )).Cells ());if _bdf > _aeb {_aeb =_bdf ;};};return _ffb .IndexToColumn (uint32 (_aeb -1));
};

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_gbf Comment )SetCellReference (cellRef string ){_gbf ._eba .RefAttr =cellRef };

// AddString adds a string to the shared string cache.
func (_fbga SharedStrings )AddString (v string )int {if _egde ,_afca :=_fbga ._bagg [v ];_afca {return _egde ;};_eadd :=_ee .NewCT_Rst ();_eadd .T =_a .String (v );_fbga ._aggf .Si =append (_fbga ._aggf .Si ,_eadd );_fbcfd :=len (_fbga ._aggf .Si )-1;_fbga ._bagg [v ]=_fbcfd ;
_fbga ._aggf .CountAttr =_a .Uint32 (uint32 (len (_fbga ._aggf .Si )));_fbga ._aggf .UniqueCountAttr =_fbga ._aggf .CountAttr ;return _fbcfd ;};

// ClearFont clears any font configuration from the cell style.
func (_efc CellStyle )ClearFont (){_efc ._beg .FontIdAttr =nil ;_efc ._beg .ApplyFontAttr =nil };

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_bcgb Sheet )Validate ()error {_eaddb :=[]func ()error {_bcgb .validateRowCellNumbers ,_bcgb .validateMergedCells ,_bcgb .validateSheetNames };for _ ,_cedd :=range _eaddb {if _eagc :=_cedd ();_eagc !=nil {return _eagc ;};};if _agba :=_bcgb ._bbag .Validate ();
_agba !=nil {return _agba ;};return _bcgb ._bbag .Validate ();};

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_geb Cell )SetStringByID (id int ){_geb ._cfg .ensureSharedStringsRelationships ();_geb .clearValue ();_geb ._ged .V =_a .String (_dc .Itoa (id ));_geb ._ged .TAttr =_ee .ST_CellTypeS ;};

// AddFont creates a new empty Font style.
func (_gfc StyleSheet )AddFont ()Font {_adde :=_ee .NewCT_Font ();return Font {_adde ,_gfc ._dbdd }};

// SetPriority sets the rule priority
func (_aeac ConditionalFormattingRule )SetPriority (p int32 ){_aeac ._ddg .PriorityAttr =p };

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_ffcd *Workbook ;_aaedc *_cce .WsDr ;};

// AddCellStyle creates a new empty cell style.
func (_cgde StyleSheet )AddCellStyle ()CellStyle {_edadc :=_ee .NewCT_Xf ();return CellStyle {_cgde ._ecfba ,_edadc ,_cgde ._dbdd .CellXfs };};

// Comments is the container for comments for a single sheet.
type Comments struct{_dfgg *Workbook ;_ede *_ee .Comments ;};func (_dabd Row )renumberAs (_daa uint32 ){_dabd ._abbe .RAttr =_a .Uint32 (_daa );for _ ,_aaae :=range _dabd .Cells (){_fdfb ,_cefa :=_ffb .ParseCellReference (_aaae .Reference ());if _cefa ==nil {_acce :=_abb .Sprintf ("\u0025\u0073\u0025\u0064",_fdfb .Column ,_daa );
_aaae ._ged .RAttr =_a .String (_acce );};};};type WorkbookProtection struct{_cafd *_ee .CT_WorkbookProtection };

// Cell is a single cell within a sheet.
type Cell struct{_cfg *Workbook ;_ge *Sheet ;_aaa *_ee .CT_Row ;_ged *_ee .CT_Cell ;};func (_dfcb PatternFill )SetBgColor (c _cb .Color ){_dfcb ._fegc .BgColor =_ee .NewCT_Color ();_dfcb ._fegc .BgColor .RgbAttr =c .AsRGBAString ();};

// Index returns the index of the differential style.
func (_bedcc DifferentialStyle )Index ()uint32 {for _fdge ,_faab :=range _bedcc ._ccaab .Dxf {if _bedcc ._efef ==_faab {return uint32 (_fdge );};};return 0;};

// AddDataValidation adds a data validation rule to a sheet.
func (_gfea *Sheet )AddDataValidation ()DataValidation {if _gfea ._bbag .DataValidations ==nil {_gfea ._bbag .DataValidations =_ee .NewCT_DataValidations ();};_faaeb :=_ee .NewCT_DataValidation ();_faaeb .ShowErrorMessageAttr =_a .Bool (true );_gfea ._bbag .DataValidations .DataValidation =append (_gfea ._bbag .DataValidations .DataValidation ,_faaeb );
_gfea ._bbag .DataValidations .CountAttr =_a .Uint32 (uint32 (len (_gfea ._bbag .DataValidations .DataValidation )));return DataValidation {_faaeb };};

// SetWidthCells is a no-op.
func (_eaad OneCellAnchor )SetWidthCells (int32 ){};

// CellMarker represents a cell position
type CellMarker struct{_fed *_cce .CT_Marker };

// SetShowValue controls if the cell value is displayed.
func (_bcaa DataBarScale )SetShowValue (b bool ){_bcaa ._dgg .ShowValueAttr =_a .Bool (b )};

// CellStyles returns the list of defined cell styles
func (_dbga StyleSheet )CellStyles ()[]CellStyle {_cdcdd :=[]CellStyle {};for _ ,_cfga :=range _dbga ._dbdd .CellXfs .Xf {_cdcdd =append (_cdcdd ,CellStyle {_dbga ._ecfba ,_cfga ,_dbga ._dbdd .CellXfs });};return _cdcdd ;};const (DVCompareOpEqual =DVCompareOp (_ee .ST_DataValidationOperatorEqual );
DVCompareOpBetween =DVCompareOp (_ee .ST_DataValidationOperatorBetween );DVCompareOpNotBetween =DVCompareOp (_ee .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_ee .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_ee .ST_DataValidationOperatorGreaterThan );
DVCompareOpGreaterEqual =DVCompareOp (_ee .ST_DataValidationOperatorGreaterThanOrEqual );DVCompareOpLess =DVCompareOp (_ee .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_ee .ST_DataValidationOperatorLessThanOrEqual ););const (AnchorTypeAbsolute AnchorType =iota ;
AnchorTypeOneCell ;AnchorTypeTwoCell ;);

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_gegc CellStyle )SetHorizontalAlignment (a _ee .ST_HorizontalAlignment ){if _gegc ._beg .Alignment ==nil {_gegc ._beg .Alignment =_ee .NewCT_CellAlignment ();};_gegc ._beg .Alignment .HorizontalAttr =a ;_gegc ._beg .ApplyAlignmentAttr =_a .Bool (true );
};func (_bbged StyleSheet )appendBorder ()Border {_bbaa :=_ee .NewCT_Border ();_bbged ._dbdd .Borders .Border =append (_bbged ._dbdd .Borders .Border ,_bbaa );_bbged ._dbdd .Borders .CountAttr =_a .Uint32 (uint32 (len (_bbged ._dbdd .Borders .Border )));
return Border {_bbaa ,_bbged ._dbdd .Borders };};func (_dceff *Workbook )onNewRelationship (_cbee *_ed .DecodeMap ,_ccefc ,_fgcb string ,_fbfcg []*_ab .File ,_adae *_bc .Relationship ,_cbdc _ed .Target )error {_fcde :=_a .DocTypeSpreadsheet ;switch _fgcb {case _a .OfficeDocumentType :_dceff ._bcbedf =_ee .NewWorkbook ();
_cbee .AddTarget (_ccefc ,_dceff ._bcbedf ,_fgcb ,0);_dceff ._afafd =_bb .NewRelationships ();_cbee .AddTarget (_ed .RelationsPathFor (_ccefc ),_dceff ._afafd .X (),_fgcb ,0);_adae .TargetAttr =_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,0);case _a .CorePropertiesType :_cbee .AddTarget (_ccefc ,_dceff .CoreProperties .X (),_fgcb ,0);
_adae .TargetAttr =_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,0);case _a .CustomPropertiesType :_cbee .AddTarget (_ccefc ,_dceff .CustomProperties .X (),_fgcb ,0);_adae .TargetAttr =_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,0);case _a .ExtendedPropertiesType :_cbee .AddTarget (_ccefc ,_dceff .AppProperties .X (),_fgcb ,0);
_adae .TargetAttr =_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,0);case _a .WorksheetType :_ggda :=_ee .NewWorksheet ();_cgab ,_fbaf :=_db .StringToNumbers (_ccefc );if !_fbaf {_cgab =len (_dceff ._adce );};_cbee .AddTarget (_ccefc ,_ggda ,_fgcb ,uint32 (_cgab ));
_gbda :=_bb .NewRelationships ();_cbee .AddTarget (_ed .RelationsPathFor (_ccefc ),_gbda .X (),_fgcb ,0);_dceff ._bggf =append (_dceff ._bggf ,_gbda );_dceff ._fbda =append (_dceff ._fbda ,nil );_adae .TargetAttr =_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,_cgab );
if _dceff ._bcbedf .Sheets !=nil {if len (_dceff ._adce )< 1{_dceff ._adce =make ([]*_ee .Worksheet ,len (_dceff ._bcbedf .Sheets .Sheet ));};for _geff ,_faca :=range _dceff ._bcbedf .Sheets .Sheet {if _faca .IdAttr ==_adae .IdAttr {_dceff ._adce [_geff ]=_ggda ;
};};}else {_dceff ._adce =append (_dceff ._adce ,_ggda );};case _a .StylesType :_dceff .StyleSheet =NewStyleSheet (_dceff );_cbee .AddTarget (_ccefc ,_dceff .StyleSheet .X (),_fgcb ,0);_adae .TargetAttr =_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,0);
case _a .ThemeType :_bdfe :=_df .NewTheme ();_dceff ._gdgc =append (_dceff ._gdgc ,_bdfe );_cbee .AddTarget (_ccefc ,_bdfe ,_fgcb ,0);_adae .TargetAttr =_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,len (_dceff ._gdgc ));case _a .SharedStringsType :_dceff .SharedStrings =NewSharedStrings ();
_cbee .AddTarget (_ccefc ,_dceff .SharedStrings .X (),_fgcb ,0);_adae .TargetAttr =_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,0);case _a .ThumbnailType :for _aaabd ,_faaga :=range _fbfcg {if _faaga ==nil {continue ;};if _faaga .Name ==_ccefc {_fdcff ,_dfabg :=_faaga .Open ();
if _dfabg !=nil {return _abb .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_dfabg );};_dceff .Thumbnail ,_ ,_dfabg =_cg .Decode (_fdcff );_fdcff .Close ();
if _dfabg !=nil {return _abb .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_dfabg );};_fbfcg [_aaabd ]=nil ;};};case _a .ImageType :for _gba ,_fddf :=range _dceff ._bacf {_edffg :=_ae .Clean (_ccefc );
if _edffg ==_gba {_adae .TargetAttr =_fddf ;return nil ;};};_addf :=_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,len (_dceff .Images )+1);for _dgeb ,_bcaf :=range _fbfcg {if _bcaf ==nil {continue ;};if _bcaf .Name ==_ae .Clean (_ccefc ){_cgfc ,_dgdf :=_ed .ExtractToDiskTmp (_bcaf ,_dceff .TmpPath );
if _dgdf !=nil {return _dgdf ;};_aeee ,_dgdf :=_bb .ImageFromStorage (_cgfc );if _dgdf !=nil {return _dgdf ;};_bbde :=_bb .MakeImageRef (_aeee ,&_dceff .DocBase ,_dceff ._afafd );_bbde .SetTarget (_addf );_dceff ._bacf [_bcaf .Name ]=_addf ;_dceff .Images =append (_dceff .Images ,_bbde );
_fbfcg [_dgeb ]=nil ;};};_adae .TargetAttr =_addf ;case _a .DrawingType :_acefb :=_cce .NewWsDr ();_ggdab :=uint32 (len (_dceff ._cefb ));_cbee .AddTarget (_ccefc ,_acefb ,_fgcb ,_ggdab );_dceff ._cefb =append (_dceff ._cefb ,_acefb );_afgd :=_bb .NewRelationships ();
_cbee .AddTarget (_ed .RelationsPathFor (_ccefc ),_afgd .X (),_fgcb ,_ggdab );_dceff ._dffd =append (_dceff ._dffd ,_afgd );_adae .TargetAttr =_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,len (_dceff ._cefb ));case _a .VMLDrawingType :_dgcdc :=_ea .NewContainer ();
_agc :=uint32 (len (_dceff ._aegc ));_cbee .AddTarget (_ccefc ,_dgcdc ,_fgcb ,_agc );_dceff ._aegc =append (_dceff ._aegc ,_dgcdc );case _a .CommentsType :_dceff ._fbda [_cbdc .Index ]=_ee .NewComments ();_cbee .AddTarget (_ccefc ,_dceff ._fbda [_cbdc .Index ],_fgcb ,_cbdc .Index );
_adae .TargetAttr =_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,len (_dceff ._fbda ));case _a .ChartType :_dadd :=_ce .NewChartSpace ();_acea :=uint32 (len (_dceff ._gceec ));_cbee .AddTarget (_ccefc ,_dadd ,_fgcb ,_acea );_dceff ._gceec =append (_dceff ._gceec ,_dadd );
_adae .TargetAttr =_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,len (_dceff ._gceec ));if _dceff ._fged ==nil {_dceff ._fged =make (map[string ]*_ce .ChartSpace );};_dceff ._fged [_adae .TargetAttr ]=_dadd ;case _a .TableType :_adec :=_ee .NewTable ();
_eggb :=uint32 (len (_dceff ._dege ));_cbee .AddTarget (_ccefc ,_adec ,_fgcb ,_eggb );_dceff ._dege =append (_dceff ._dege ,_adec );_adae .TargetAttr =_a .RelativeFilename (_fcde ,_cbdc .Typ ,_fgcb ,len (_dceff ._dege ));default:_gb .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_ccefc ,_fgcb );
};return nil ;};

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_cdcb Cell )SetStyleIndex (idx uint32 ){_cdcb ._ged .SAttr =_a .Uint32 (idx )};

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_eadf *_ee .CT_Font ;_dcac *_ee .StyleSheet ;};

// SetStyle applies a style to a cell avoiding redundancy. The function checks if the given style
// already exists in the saved styles. If found, the existing style is reused; otherwise,
// the new style is added to the saved styles collection. The style is then applied to the cell.
// This style is referenced in the generated XML via CellStyle.Index().
func (_faae Cell )SetStyle (cs CellStyle ){_bcfb :=cs ._egc .Xf ;for _ ,_dad :=range _bcfb {if _fb .DeepEqual (_dad ,cs ._beg ){cs ._beg =_dad ;_faae .SetStyleIndex (cs .Index ());return ;};};cs ._egc .Xf =append (cs ._egc .Xf ,cs ._beg );cs ._egc .CountAttr =_a .Uint32 (uint32 (len (cs ._egc .Xf )));
_faae .SetStyleIndex (cs .Index ());};func (_gacf Fill )SetPatternFill ()PatternFill {if _gacf ._cecec .FillChoice ==nil {_gacf ._cecec .FillChoice =_ee .NewCT_FillChoice ();};_gacf ._cecec .FillChoice .GradientFill =nil ;_gacf ._cecec .FillChoice .PatternFill =_ee .NewCT_PatternFill ();
_gacf ._cecec .FillChoice .PatternFill .PatternTypeAttr =_ee .ST_PatternTypeSolid ;return PatternFill {_gacf ._cecec .FillChoice .PatternFill ,_gacf ._cecec };};func (_cgbc Font )SetName (name string ){_fea :=false ;for _gbe ,_egff :=range _cgbc ._eadf .FontChoice {if _egff .Name !=nil {_cgbc ._eadf .FontChoice [_gbe ].Name =&_ee .CT_FontName {ValAttr :name };
_fea =true ;};};if !_fea {_cgbc ._eadf .FontChoice =append (_cgbc ._eadf .FontChoice ,&_ee .CT_FontChoice {Name :&_ee .CT_FontName {ValAttr :name }});};};

// AddHyperlink creates and sets a hyperlink on a cell.
func (_cccb Cell )AddHyperlink (url string ){for _edf ,_ag :=range _cccb ._cfg ._adce {if _ag ==_cccb ._ge ._bbag {_cccb .SetHyperlink (_cccb ._cfg ._bggf [_edf ].AddHyperlink (url ));return ;};};};type SheetProtection struct{_bbaf *_ee .CT_SheetProtection };


// PasswordHash returns the hash of the workbook password.
func (_cbff WorkbookProtection )PasswordHash ()string {if _cbff ._cafd .WorkbookPasswordAttr ==nil {return "";};return *_cbff ._cafd .WorkbookPasswordAttr ;};

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_gfe ,_cbec int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_eg _ddde .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_fe int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_gcc _ddde .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_cge int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_bf _ddde .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_cab _ddde .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};

// X returns the inner wrapped XML type.
func (_bde DefinedName )X ()*_ee .CT_DefinedName {return _bde ._degb };

// Name returns the sheet name
func (_eabg Sheet )Name ()string {return _eabg ._aefa .NameAttr };

// IsWindowLocked returns whether the workbook windows are locked.
func (_bebda WorkbookProtection )IsWindowLocked ()bool {return _bebda ._cafd .LockWindowsAttr !=nil &&*_bebda ._cafd .LockWindowsAttr ;};

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_ebbdb *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_ebdc :=range _ebbdb .Sheets (){if _ebdc .Name ()==name {return _ebdc ,nil ;};};return Sheet {},ErrorNotFound ;};

// X returns the inner wrapped XML type.
func (_ddab Table )X ()*_ee .Table {return _ddab ._gbba };

// Comments returns the list of comments for this sheet
func (_acfb Comments )Comments ()[]Comment {_cfa :=[]Comment {};for _ ,_gfed :=range _acfb ._ede .CommentList .Comment {_cfa =append (_cfa ,Comment {_acfb ._dfgg ,_gfed ,_acfb ._ede });};return _cfa ;};

// Border is a cell border configuraton.
type Border struct{_cde *_ee .CT_Border ;_cf *_ee .CT_Borders ;};func _dgd (_cgd _cd .Time )_cd .Time {_cgd =_cgd .Local ();return _cd .Date (_cgd .Year (),_cgd .Month (),_cgd .Day (),_cgd .Hour (),_cgd .Minute (),_cgd .Second (),_cgd .Nanosecond (),_cd .UTC );
};func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_gegb :=NumberFormat {_addg :_ee .NewCT_NumFmt ()};_gegb ._addg .NumFmtIdAttr =uint32 (id );_gegb ._addg .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";switch id {case StandardFormat0 :_gegb ._addg .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";
case StandardFormat1 :_gegb ._addg .FormatCodeAttr ="\u0030";case StandardFormat2 :_gegb ._addg .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_gegb ._addg .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";case StandardFormat4 :_gegb ._addg .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";
case StandardFormat9 :_gegb ._addg .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_gegb ._addg .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_gegb ._addg .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";
case StandardFormat12 :_gegb ._addg .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_gegb ._addg .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_gegb ._addg .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";
case StandardFormat15 :_gegb ._addg .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_gegb ._addg .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_gegb ._addg .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";
case StandardFormat18 :_gegb ._addg .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_gegb ._addg .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_gegb ._addg .FormatCodeAttr ="\u0068\u003a\u006d\u006d";
case StandardFormat21 :_gegb ._addg .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_gegb ._addg .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_gegb ._addg .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";
case StandardFormat38 :_gegb ._addg .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_gegb ._addg .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";
case StandardFormat40 :_gegb ._addg .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_gegb ._addg .FormatCodeAttr ="\u006d\u006d\u003as\u0073";
case StandardFormat46 :_gegb ._addg .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_gegb ._addg .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_gegb ._addg .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";
case StandardFormat49 :_gegb ._addg .FormatCodeAttr ="\u0040";};return _gegb ;};func (_gefc DataValidation )SetList ()DataValidationList {_gefc .clear ();_gefc ._abdc .TypeAttr =_ee .ST_DataValidationTypeList ;_gefc ._abdc .OperatorAttr =_ee .ST_DataValidationOperatorEqual ;
return DataValidationList {_gefc ._abdc };};

// X returns the inner wrapped XML type.
func (_cccg Sheet )X ()*_ee .Worksheet {return _cccg ._bbag };func (_cec Cell )GetRawValue ()(string ,error ){switch _cec ._ged .TAttr {case _ee .ST_CellTypeInlineStr :if _cec ._ged .Is ==nil ||_cec ._ged .Is .T ==nil {return "",nil ;};return *_cec ._ged .Is .T ,nil ;
case _ee .ST_CellTypeS :if _cec ._ged .V ==nil {return "",nil ;};_bdd ,_beff :=_dc .Atoi (*_cec ._ged .V );if _beff !=nil {return "",_beff ;};return _cec ._cfg .SharedStrings .GetString (_bdd );case _ee .ST_CellTypeStr :if _cec ._ged .F !=nil {return _cec ._ged .F .Content ,nil ;
};};if _cec ._ged .V ==nil {return "",nil ;};return *_cec ._ged .V ,nil ;};

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_dgg *_ee .CT_DataBar };

// SetColOffset sets the column offset of the top-left anchor.
func (_addc OneCellAnchor )SetColOffset (m _ddde .Distance ){_addc .TopLeft ().SetColOffset (m )};

// Themes returns the array of workbook dml.Theme.
func (_gddg *Workbook )Themes ()[]*_df .Theme {return _gddg ._gdgc };type MergedCell struct{_ecaa *Workbook ;_cbce *Sheet ;_bcfc *_ee .CT_MergeCell ;};var _bdbf =[...]uint8 {0,18,37};

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_dcefe *Workbook )AddImage (i _bb .Image )(_bb .ImageRef ,error ){_baba :=_bb .MakeImageRef (i ,&_dcefe .DocBase ,_dcefe ._afafd );if i .Data ==nil &&i .Path ==""{return _baba ,_gf .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");
};if i .Format ==""{return _baba ,_gf .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _baba ,_gf .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");
};if i .Path !=""{_daccd :=_fa .Add (i .Path );if _daccd !=nil {return _baba ,_daccd ;};};_dcefe .Images =append (_dcefe .Images ,_baba );return _baba ,nil ;};

// Cell returns the actual cell behind the merged region
func (_faada MergedCell )Cell ()Cell {_eec :=_faada .Reference ();if _aded :=_e .Index (_faada .Reference (),"\u003a");_aded !=-1{_eec =_eec [0:_aded ];return _faada ._cbce .Cell (_eec );};return Cell {};};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_bfed Comment )CellReference ()string {return _bfed ._eba .RefAttr };func (_aac Cell )getFormat ()string {if _aac ._ged .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_ffbc :=*_aac ._ged .SAttr ;_dg :=_aac ._cfg .StyleSheet .GetCellStyle (_ffbc );
_cdcf :=_aac ._cfg .StyleSheet .GetNumberFormat (_dg .NumberFormat ());return _cdcf .GetFormat ();};

// IsEmpty checks if the cell style contains nothing.
func (_dee CellStyle )IsEmpty ()bool {return _dee ._eae ==nil ||_dee ._beg ==nil ||_dee ._egc ==nil ||_dee ._egc .Xf ==nil ;};

// Rows returns all of the rows in a sheet.
func (_addcc *Sheet )Rows ()[]Row {_gceg :=[]Row {};for _ ,_eadb :=range _addcc ._bbag .SheetData .Row {_gceg =append (_gceg ,Row {_addcc ._edad ,_addcc ,_eadb });};return _gceg ;};

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_cdg *evalContext )GetLabelPrefix (cellRef string )string {return _cdg ._abf .Cell (cellRef ).getLabelPrefix ();};func (_ggbdd StyleSheet )GetCellStyle (id uint32 )CellStyle {for _ccafd ,_deaac :=range _ggbdd ._dbdd .CellXfs .Xf {if uint32 (_ccafd )==id {return CellStyle {_ggbdd ._ecfba ,_deaac ,_ggbdd ._dbdd .CellXfs };
};};return CellStyle {};};

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_edfb ConditionalFormattingRule )SetColorScale ()ColorScale {_edfb .clear ();_edfb .SetType (_ee .ST_CfTypeColorScale );_edfb ._ddg .ColorScale =_ee .NewCT_ColorScale ();return ColorScale {_edfb ._ddg .ColorScale };};type DifferentialStyle struct{_efef *_ee .CT_Dxf ;
_deag *Workbook ;_ccaab *_ee .CT_Dxfs ;};

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_beac *_ee .CT_Rst };

// IsError returns true if the cell is an error type cell.
func (_abag Cell )IsError ()bool {return _abag ._ged .TAttr ==_ee .ST_CellTypeE };func _bgfb ()*_cce .CT_AbsoluteAnchor {_ebg :=_cce .NewCT_AbsoluteAnchor ();return _ebg };const _aa ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";


// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_cbbb *Sheet )AddNumberedRow (rowNum uint32 )Row {_befe :=_ee .NewCT_Row ();_befe .RAttr =_a .Uint32 (rowNum );_cbbb ._bbag .SheetData .Row =append (_cbbb ._bbag .SheetData .Row ,_befe );_g .Slice (_cbbb ._bbag .SheetData .Row ,func (_fecd ,_ffg int )bool {_bcfa :=_cbbb ._bbag .SheetData .Row [_fecd ].RAttr ;
_cbcd :=_cbbb ._bbag .SheetData .Row [_ffg ].RAttr ;if _bcfa ==nil {return true ;};if _cbcd ==nil {return true ;};return *_bcfa < *_cbcd ;});return Row {_cbbb ._edad ,_cbbb ,_befe };};

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_ced ConditionalFormattingRule )SetIcons ()IconScale {_ced .clear ();_ced .SetType (_ee .ST_CfTypeIconSet );_ced ._ddg .IconSet =_ee .NewCT_IconSet ();_faf :=IconScale {_ced ._ddg .IconSet };_faf .SetIcons (_ee .ST_IconSetType3TrafficLights1 );return _faf ;
};

// Author returns the author of the comment
func (_dbbg Comment )Author ()string {if _dbbg ._eba .AuthorIdAttr < uint32 (len (_dbbg ._ddda .Authors .Author )){return _dbbg ._ddda .Authors .Author [_dbbg ._eba .AuthorIdAttr ];};return "";};

// SetFill applies a fill to a cell style avoiding redundancy. The function checks if the given fill
// already exists in the saved fills. If found, the existing fill is reused; otherwise,
// the new fill is added to the saved fills collection. The fill is then applied to the cell style,
// affecting all styles that reference it by index.
func (_bba CellStyle )SetFill (f Fill ){_fdf :=f ._dcfd .Fill ;for _ ,_bbgf :=range _fdf {if _fb .DeepEqual (_bbgf ,f ._cecec ){f ._cecec =_bbgf ;_bba ._beg .FillIdAttr =_a .Uint32 (f .Index ());_bba ._beg .ApplyFillAttr =_a .Bool (true );return ;};};f ._dcfd .Fill =append (f ._dcfd .Fill ,f ._cecec );
f ._dcfd .CountAttr =_a .Uint32 (uint32 (len (f ._dcfd .Fill )));_bba ._beg .FillIdAttr =_a .Uint32 (f .Index ());_bba ._beg .ApplyFillAttr =_a .Bool (true );};

// SetItalic causes the text to be displayed in italic.
func (_dcb RichTextRun )SetItalic (b bool ){_dcb .ensureRpr ();for _ ,_cfb :=range _dcb ._caeb .RPr .RPrEltChoice {if _cfb .I !=nil {_cfb .I .ValAttr =_a .Bool (b );return ;};};_dcb ._caeb .RPr .RPrEltChoice =append (_dcb ._caeb .RPr .RPrEltChoice ,&_ee .CT_RPrEltChoice {I :&_ee .CT_BooleanProperty {ValAttr :_a .Bool (b )}});
};

// New constructs a new workbook.
func New ()*Workbook {_bgg :=&Workbook {};_bgg ._bcbedf =_ee .NewWorkbook ();_bgg .AppProperties =_bb .NewAppProperties ();_bgg .CoreProperties =_bb .NewCoreProperties ();_bgg .StyleSheet =NewStyleSheet (_bgg );_bgg .Rels =_bb .NewRelationships ();_bgg ._afafd =_bb .NewRelationships ();
_bgg .Rels .AddRelationship (_a .RelativeFilename (_a .DocTypeSpreadsheet ,"",_a .ExtendedPropertiesType ,0),_a .ExtendedPropertiesType );_bgg .Rels .AddRelationship (_a .RelativeFilename (_a .DocTypeSpreadsheet ,"",_a .CorePropertiesType ,0),_a .CorePropertiesType );
_bgg .Rels .AddRelationship (_a .RelativeFilename (_a .DocTypeSpreadsheet ,"",_a .OfficeDocumentType ,0),_a .OfficeDocumentType );_bgg ._afafd .AddRelationship (_a .RelativeFilename (_a .DocTypeSpreadsheet ,_a .OfficeDocumentType ,_a .StylesType ,0),_a .StylesType );
_bgg .ContentTypes =_bb .NewContentTypes ();_bgg .ContentTypes .AddDefault ("\u0076\u006d\u006c",_a .VMLDrawingContentType );_bgg .ContentTypes .AddOverride (_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");
_bgg .ContentTypes .AddOverride (_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .StylesType ,0),_a .SMLStyleSheetContentType );_bgg .SharedStrings =NewSharedStrings ();_bgg .ContentTypes .AddOverride (_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .SharedStringsType ,0),_a .SharedStringsContentType );
_bgg ._afafd .AddRelationship (_a .RelativeFilename (_a .DocTypeSpreadsheet ,_a .OfficeDocumentType ,_a .SharedStringsType ,0),_a .SharedStringsType );_bgg ._bacf =map[string ]string {};return _bgg ;};

// SetNumberFormat applies a number format to a cell style avoiding redundancy. The function checks if the given string
// already exists in the saved number formats. If found, the existing number format is reused; otherwise,
// the new number format is added to the saved number formats collection. The number format is then applied to the cell style,
// affecting all styles that reference it by index.
func (_aed CellStyle )SetNumberFormat (s string ){var _ecbfa NumberFormat ;if _aed ._eae .StyleSheet ._dbdd .NumFmts ==nil {_aed ._eae .StyleSheet ._dbdd .NumFmts =_ee .NewCT_NumFmts ();};_egd :=_aed ._eae .StyleSheet ._dbdd .NumFmts .NumFmt ;for _ ,_ecd :=range _egd {if _fb .DeepEqual (_ecd .FormatCodeAttr ,s ){_ecbfa =NumberFormat {_aed ._eae ,_ecd };
_aed ._beg .ApplyNumberFormatAttr =_a .Bool (true );_aed ._beg .NumFmtIdAttr =_a .Uint32 (_ecbfa .ID ());return ;};};_aef :=_ee .NewCT_NumFmt ();_aef .NumFmtIdAttr =uint32 (200+len (_aed ._eae .StyleSheet ._dbdd .NumFmts .NumFmt ));_aed ._eae .StyleSheet ._dbdd .NumFmts .NumFmt =append (_aed ._eae .StyleSheet ._dbdd .NumFmts .NumFmt ,_aef );
_aed ._eae .StyleSheet ._dbdd .NumFmts .CountAttr =_a .Uint32 (uint32 (len (_aed ._eae .StyleSheet ._dbdd .NumFmts .NumFmt )));_ecbfa =NumberFormat {_aed ._eae ,_aef };_ecbfa ._addg .FormatCodeAttr =s ;_aed ._beg .ApplyNumberFormatAttr =_a .Bool (true );
_aed ._beg .NumFmtIdAttr =_a .Uint32 (_ecbfa .ID ());};

// X returns the inner wrapped XML type.
func (_dbfd ConditionalFormattingRule )X ()*_ee .CT_CfRule {return _dbfd ._ddg };

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_bbcd *Workbook ;_addg *_ee .CT_NumFmt ;};

// GetChartByTargetId returns the array of workbook crt.ChartSpace.
func (_faaac *Workbook )GetChartByTargetId (targetAttr string )*_ce .ChartSpace {return _faaac ._fged [targetAttr ];};

// MoveTo repositions the anchor without changing the objects size.
func (_gbgce TwoCellAnchor )MoveTo (col ,row int32 ){_deab :=_gbgce .TopLeft ();_fcgc :=_gbgce .BottomRight ();_gbd :=_fcgc .Col ()-_deab .Col ();_deeg :=_fcgc .Row ()-_deab .Row ();_deab .SetCol (col );_deab .SetRow (row );_fcgc .SetCol (col +_gbd );_fcgc .SetRow (row +_deeg );
};

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_gbeb NumberFormat )ID ()uint32 {return _gbeb ._addg .NumFmtIdAttr };

// SetHeight sets the row height in points.
func (_cfbf Row )SetHeight (d _ddde .Distance ){_cfbf ._abbe .HtAttr =_a .Float64 (float64 (d ));_cfbf ._abbe .CustomHeightAttr =_a .Bool (true );};

// Type returns the type of anchor
func (_dbaf OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };

// AddCell adds a cell to a spreadsheet.
func (_adcc Row )AddCell ()Cell {_fce :=uint32 (len (_adcc ._abbe .C ));var _bgba *string ;if _fce > 0{_ebbb :=_a .Stringf ("\u0025\u0073\u0025\u0064",_ffb .IndexToColumn (_fce -1),_adcc .RowNumber ());if _adcc ._abbe .C [_fce -1].RAttr !=nil &&*_adcc ._abbe .C [_fce -1].RAttr ==*_ebbb {_bgba =_a .Stringf ("\u0025\u0073\u0025\u0064",_ffb .IndexToColumn (_fce ),_adcc .RowNumber ());
};};_dfca :=_ee .NewCT_Cell ();_adcc ._abbe .C =append (_adcc ._abbe .C ,_dfca );if _bgba ==nil {_feac :=uint32 (0);for _ ,_bfea :=range _adcc ._abbe .C {if _bfea .RAttr !=nil {_ggbd ,_ :=_ffb .ParseCellReference (*_bfea .RAttr );if _ggbd .ColumnIdx >=_feac {_feac =_ggbd .ColumnIdx +1;
};};};_bgba =_a .Stringf ("\u0025\u0073\u0025\u0064",_ffb .IndexToColumn (_feac ),_adcc .RowNumber ());};_dfca .RAttr =_bgba ;return Cell {_adcc ._gbgf ,_adcc ._baec ,_adcc ._abbe ,_dfca };};type Fill struct{_cecec *_ee .CT_Fill ;_dcfd *_ee .CT_Fills ;
};

// Name returns the name of the table
func (_bgcgb Table )Name ()string {if _bgcgb ._gbba .NameAttr !=nil {return *_bgcgb ._gbba .NameAttr ;};return "";};

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_bbg Cell )SetString (s string )int {_bbg ._cfg .ensureSharedStringsRelationships ();_bbg .clearValue ();_ac :=_bbg ._cfg .SharedStrings .AddString (s );_bbg ._ged .V =_a .String (_dc .Itoa (_ac ));_bbg ._ged .TAttr =_ee .ST_CellTypeS ;return _ac ;
};

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_dffg DataValidation )SetRange (cellRange string ){_dffg ._abdc .SqrefAttr =_ee .ST_Sqref {cellRange };};

// Row is a row within a spreadsheet.
type Row struct{_gbgf *Workbook ;_baec *Sheet ;_abbe *_ee .CT_Row ;};func (_gfba RichTextRun )ensureRpr (){if _gfba ._caeb .RPr ==nil {_gfba ._caeb .RPr =_ee .NewCT_RPrElt ();};if _gfba ._caeb .RPr .RPrEltChoice ==nil {_gfba ._caeb .RPr .RPrEltChoice =[]*_ee .CT_RPrEltChoice {};
};};func _deb (_daedb string )bool {_daedb =_e .Replace (_daedb ,"\u0024","",-1);if _bdca :=_gaag .FindStringSubmatch (_e .ToLower (_daedb ));len (_bdca )> 2{_egg :=_bdca [1];_ggb ,_bbge :=_dc .Atoi (_bdca [2]);if _bbge !=nil {return false ;};return _ggb <=1048576&&_egg <="\u007a\u007a";
};return false ;};

// LockStructure controls the locking of the workbook structure.
func (_ddfed WorkbookProtection )LockStructure (b bool ){if !b {_ddfed ._cafd .LockStructureAttr =nil ;}else {_ddfed ._cafd .LockStructureAttr =_a .Bool (true );};};

// X returns the inner wrapped XML type.
func (_acd ColorScale )X ()*_ee .CT_ColorScale {return _acd ._fag };var _gaag *_cc .Regexp =_cc .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_ffeb StyleSheet )AddNumberFormat ()NumberFormat {if _ffeb ._dbdd .NumFmts ==nil {_ffeb ._dbdd .NumFmts =_ee .NewCT_NumFmts ();};_deed :=_ee .NewCT_NumFmt ();_deed .NumFmtIdAttr =uint32 (200+len (_ffeb ._dbdd .NumFmts .NumFmt ));_ffeb ._dbdd .NumFmts .NumFmt =append (_ffeb ._dbdd .NumFmts .NumFmt ,_deed );
_ffeb ._dbdd .NumFmts .CountAttr =_a .Uint32 (uint32 (len (_ffeb ._dbdd .NumFmts .NumFmt )));return NumberFormat {_ffeb ._ecfba ,_deed };};

// SetWidth sets the width of the anchored object.
func (_aaef OneCellAnchor )SetWidth (w _ddde .Distance ){_aaef ._adf .Ext .CxAttr =int64 (w /_ddde .EMU )};

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_faad Cell )SetBool (v bool ){_faad .clearValue ();_faad ._ged .V =_a .String (_dc .Itoa (_fbcf (v )));_faad ._ged .TAttr =_ee .ST_CellTypeB ;};

// MoveTo is a no-op.
func (_cdc AbsoluteAnchor )MoveTo (x ,y int32 ){};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_ggd Sheet )ValidateWithPath (path string )error {return _ggd ._bbag .ValidateWithPath (path )};

// X returns the inner wrapped XML type.
func (_abdd SharedStrings )X ()*_ee .Sst {return _abdd ._aggf };

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_ebaf Row )AddNamedCell (col string )Cell {_ffad :=_ee .NewCT_Cell ();_ffad .RAttr =_a .Stringf ("\u0025\u0073\u0025\u0064",col ,_ebaf .RowNumber ());_aegb :=-1;_fbd :=_ffb .ColumnToIndex (col );for _cac ,_faff :=range _ebaf ._abbe .C {_gbee ,_fbe :=_ffb .ParseCellReference (*_faff .RAttr );
if _fbe !=nil {return Cell {};};if _fbd < _gbee .ColumnIdx {_aegb =_cac ;break ;};};if _aegb ==-1{_ebaf ._abbe .C =append (_ebaf ._abbe .C ,_ffad );}else {_ebaf ._abbe .C =append (_ebaf ._abbe .C [:_aegb ],append ([]*_ee .CT_Cell {_ffad },_ebaf ._abbe .C [_aegb :]...)...);
};return Cell {_ebaf ._gbgf ,_ebaf ._baec ,_ebaf ._abbe ,_ffad };};

// AddRun adds a new run of text to the cell.
func (_eagd RichText )AddRun ()RichTextRun {_fade :=_ee .NewCT_RElt ();_eagd ._beac .R =append (_eagd ._beac .R ,_fade );return RichTextRun {_fade };};func (_cggd *evalContext )Cell (ref string ,ev _ffc .Evaluator )_ffc .Result {if !_deb (ref ){return _ffc .MakeErrorResultType (_ffc .ErrorTypeName ,"");
};_bbgb :=_cggd ._abf .Name ()+"\u0021"+ref ;if _fba ,_cbg :=ev .GetFromCache (_bbgb );_cbg {return _fba ;};_ece ,_gcg :=_ffb .ParseCellReference (ref );if _gcg !=nil {return _ffc .MakeErrorResult (_abb .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_gcg ));
};if _cggd ._bedf !=0&&!_ece .AbsoluteColumn {_ece .ColumnIdx +=_cggd ._bedf ;_ece .Column =_ffb .IndexToColumn (_ece .ColumnIdx );};if _cggd ._dcef !=0&&!_ece .AbsoluteRow {_ece .RowIdx +=_cggd ._dcef ;};_abaf :=_cggd ._abf .Cell (_ece .String ());if _abaf .HasFormula (){if _ ,_cdd :=_cggd ._adbd [ref ];
_cdd {return _ffc .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );
};_cggd ._adbd [ref ]=struct{}{};_fgab :=ev .Eval (_cggd ,_abaf .GetFormula ());delete (_cggd ._adbd ,ref );ev .SetCache (_bbgb ,_fgab );return _fgab ;};if _abaf .IsEmpty (){_gcfd :=_ffc .MakeEmptyResult ();ev .SetCache (_bbgb ,_gcfd );return _gcfd ;}else if _abaf .IsNumber (){_aff ,_ :=_abaf .GetValueAsNumber ();
_dbde :=_ffc .MakeNumberResult (_aff );ev .SetCache (_bbgb ,_dbde );return _dbde ;}else if _abaf .IsBool (){_afd ,_ :=_abaf .GetValueAsBool ();_gbge :=_ffc .MakeBoolResult (_afd );ev .SetCache (_bbgb ,_gbge );return _gbge ;};_ffcb ,_ :=_abaf .GetRawValue ();
if _abaf .IsError (){_dac :=_ffc .MakeErrorResult ("");_dac .ValueString =_ffcb ;ev .SetCache (_bbgb ,_dac );return _dac ;};_gaf :=_ffc .MakeStringResult (_ffcb );ev .SetCache (_bbgb ,_gaf );return _gaf ;};

// Comment is a single comment within a sheet.
type Comment struct{_aga *Workbook ;_eba *_ee .CT_Comment ;_ddda *_ee .Comments ;};

// PasswordHash returns the hash of the workbook password.
func (_dceg SheetProtection )PasswordHash ()string {if _dceg ._bbaf .PasswordAttr ==nil {return "";};return *_dceg ._bbaf .PasswordAttr ;};

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_dag Cell )SetTime (d _cd .Time ){_dag .clearValue ();d =_dgd (d );_fbf :=_dag ._cfg .Epoch ();if d .Before (_fbf ){_gb .Log .Debug ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");
return ;};_gfa :=d .Sub (_fbf );_bdg :=new (_ddd .Float );_bfd :=new (_ddd .Float );_bfd .SetPrec (128);_bfd .SetUint64 (uint64 (_gfa ));_cdf :=new (_ddd .Float );_cdf .SetUint64 (24*60*60*1e9);_bdg .Quo (_bfd ,_cdf );_dag ._ged .V =_a .String (_bdg .Text ('g',20));
};

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};

// DefinedNames returns a slice of all defined names in the workbook.
func (_efbg *Workbook )DefinedNames ()[]DefinedName {if _efbg ._bcbedf .DefinedNames ==nil {return nil ;};_gegfc :=[]DefinedName {};for _ ,_ecad :=range _efbg ._bcbedf .DefinedNames .DefinedName {_gegfc =append (_gegfc ,DefinedName {_ecad });};return _gegfc ;
};

// Wrapped returns true if the cell will wrap text.
func (_edc CellStyle )Wrapped ()bool {if _edc ._beg .Alignment ==nil {return false ;};if _edc ._beg .Alignment .WrapTextAttr ==nil {return false ;};return *_edc ._beg .Alignment .WrapTextAttr ;};

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_dfabd Sheet )Extents ()string {_dge ,_egdee ,_bddf ,_aace :=_dfabd .ExtentsIndex ();return _abb .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_dge ,_egdee ,_bddf ,_aace );};

// SetRowOffset sets the row offset of the two cell anchor
func (_cfeda TwoCellAnchor )SetRowOffset (m _ddde .Distance ){_fgee :=m -_cfeda .TopLeft ().RowOffset ();_cfeda .TopLeft ().SetRowOffset (m );_cfeda .BottomRight ().SetRowOffset (_cfeda .BottomRight ().RowOffset ()+_fgee );};func (_abfc Fills )X ()*_ee .CT_Fills {return _abfc ._ebfc };


// Save writes the workbook out to a writer in the zipped xlsx format.
func (_ddga *Workbook )Save (w _d .Writer )error {const _bgbf ="\u0073\u0070\u0072\u0065ad\u0073\u0068\u0065\u0065\u0074\u003a\u0077\u0062\u002e\u0053\u0061\u0076\u0065";if !_ff .GetLicenseKey ().IsLicensed ()&&!_bagb {_abb .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");
_abb .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");
return _gf .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_cebee :="\u0075n\u006b\u006e\u006f\u0077\u006e";if _fbgd ,_aceec :=w .(*_f .File );
_aceec {_cebee =_fbgd .Name ();};if len (_ddga ._cdaa )==0{_adbdg ,_bged :=_ff .GenRefId ("\u0073\u0077");if _bged !=nil {_gb .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bged );return _bged ;};_ddga ._cdaa =_adbdg ;};if _bdda :=_ff .Track (_ddga ._cdaa ,_bgbf ,_cebee );
_bdda !=nil {_gb .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bdda );return _bdda ;};_gbfb :=_ab .NewWriter (w );defer _gbfb .Close ();_cedf :=_a .DocTypeSpreadsheet ;if _aaf :=_ed .MarshalXML (_gbfb ,_a .BaseRelsFilename ,_ddga .Rels .X ());
_aaf !=nil {return _aaf ;};if _cedac :=_ed .MarshalXMLByType (_gbfb ,_cedf ,_a .ExtendedPropertiesType ,_ddga .AppProperties .X ());_cedac !=nil {return _cedac ;};if _begg :=_ed .MarshalXMLByType (_gbfb ,_cedf ,_a .CorePropertiesType ,_ddga .CoreProperties .X ());
_begg !=nil {return _begg ;};_ddcd :=_a .AbsoluteFilename (_cedf ,_a .OfficeDocumentType ,0);if _effa :=_ed .MarshalXML (_gbfb ,_ddcd ,_ddga ._bcbedf );_effa !=nil {return _effa ;};if _dfec :=_ed .MarshalXML (_gbfb ,_ed .RelationsPathFor (_ddcd ),_ddga ._afafd .X ());
_dfec !=nil {return _dfec ;};if _egea :=_ed .MarshalXMLByType (_gbfb ,_cedf ,_a .StylesType ,_ddga .StyleSheet .X ());_egea !=nil {return _egea ;};for _gebb ,_badag :=range _ddga ._gdgc {if _bgedd :=_ed .MarshalXMLByTypeIndex (_gbfb ,_cedf ,_a .ThemeType ,_gebb +1,_badag );
_bgedd !=nil {return _bgedd ;};};for _feaa ,_afde :=range _ddga ._adce {_afde .Dimension .RefAttr =Sheet {_ddga ,nil ,_afde }.Extents ();_bcfd :=_a .AbsoluteFilename (_cedf ,_a .WorksheetType ,_feaa +1);_ed .MarshalXML (_gbfb ,_bcfd ,_afde );_ed .MarshalXML (_gbfb ,_ed .RelationsPathFor (_bcfd ),_ddga ._bggf [_feaa ].X ());
};if _eebb :=_ed .MarshalXMLByType (_gbfb ,_cedf ,_a .SharedStringsType ,_ddga .SharedStrings .X ());_eebb !=nil {return _eebb ;};if _ddga .CustomProperties .X ()!=nil {if _eeca :=_ed .MarshalXMLByType (_gbfb ,_cedf ,_a .CustomPropertiesType ,_ddga .CustomProperties .X ());
_eeca !=nil {return _eeca ;};};if _ddga .Thumbnail !=nil {_adfg :=_a .AbsoluteFilename (_cedf ,_a .ThumbnailType ,0);_deaaa ,_cafe :=_gbfb .Create (_adfg );if _cafe !=nil {return _cafe ;};if _baaa :=_b .Encode (_deaaa ,_ddga .Thumbnail ,nil );_baaa !=nil {return _baaa ;
};};for _dgca ,_ccgf :=range _ddga ._gceec {_badf :=_a .AbsoluteFilename (_cedf ,_a .ChartType ,_dgca +1);_ed .MarshalXML (_gbfb ,_badf ,_ccgf );};for _cagc ,_ccaabc :=range _ddga ._dege {_baeca :=_a .AbsoluteFilename (_cedf ,_a .TableType ,_cagc +1);_ed .MarshalXML (_gbfb ,_baeca ,_ccaabc );
};for _gddd ,_aegce :=range _ddga ._cefb {_dcdg :=_a .AbsoluteFilename (_cedf ,_a .DrawingType ,_gddd +1);_ed .MarshalXML (_gbfb ,_dcdg ,_aegce );if !_ddga ._dffd [_gddd ].IsEmpty (){_ed .MarshalXML (_gbfb ,_ed .RelationsPathFor (_dcdg ),_ddga ._dffd [_gddd ].X ());
};};for _aadg ,_cdbf :=range _ddga ._aegc {_ed .MarshalXML (_gbfb ,_a .AbsoluteFilename (_cedf ,_a .VMLDrawingType ,_aadg +1),_cdbf );};for _faea ,_fbdf :=range _ddga .Images {if _fegg :=_bb .AddImageToZip (_gbfb ,_fbdf ,_faea +1,_a .DocTypeSpreadsheet );
_fegg !=nil {return _fegg ;};};if _fff :=_ed .MarshalXML (_gbfb ,_a .ContentTypesFilename ,_ddga .ContentTypes .X ());_fff !=nil {return _fff ;};for _dfcde ,_adab :=range _ddga ._fbda {if _adab ==nil {continue ;};_ed .MarshalXML (_gbfb ,_a .AbsoluteFilename (_cedf ,_a .CommentsType ,_dfcde +1),_adab );
};if _dgcaf :=_ddga .WriteExtraFiles (_gbfb );_dgcaf !=nil {return _dgcaf ;};return _gbfb .Close ();};

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _d .ReaderAt ,size int64 )(*Workbook ,error ){const _ggg ="\u0073\u0070r\u0065\u0061\u0064s\u0068\u0065\u0065\u0074\u003a\u0052\u0065\u0061\u0064";if !_ff .GetLicenseKey ().IsLicensed ()&&!_bagb {_abb .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");
_abb .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");
return nil ,_gf .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_afa :="\u0075n\u006b\u006e\u006f\u0077\u006e";if _cbgd ,_fgdb :=r .(*_f .File );
_fgdb {_afa =_cbgd .Name ();};_aacfd :=New ();_fab ,_ebfe :=_ff .GenRefId ("\u0073\u0072");if _ebfe !=nil {_gb .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ebfe );return nil ,_ebfe ;};_aacfd ._cdaa =_fab ;if _bbed :=_ff .Track (_aacfd ._cdaa ,_ggg ,_afa );
_bbed !=nil {_gb .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bbed );return nil ,_bbed ;};_fggb ,_ebfe :=_fa .TempDir ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078");if _ebfe !=nil {return nil ,_ebfe ;
};_aacfd .TmpPath =_fggb ;_edbg ,_ebfe :=_ab .NewReader (r ,size );if _ebfe !=nil {return nil ,_abb .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_ebfe );};_dde :=[]*_ab .File {};_dde =append (_dde ,_edbg .File ...);
_gcbc :=false ;for _ ,_fabd :=range _dde {if _fabd .FileHeader .Name =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_gcbc =true ;break ;};};if _gcbc {_aacfd .CreateCustomProperties ();};_ccbg :=_ed .DecodeMap {};
_ccbg .SetOnNewRelationshipFunc (_aacfd .onNewRelationship );_ccbg .AddTarget (_a .ContentTypesFilename ,_aacfd .ContentTypes .X (),"",0);_ccbg .AddTarget (_a .BaseRelsFilename ,_aacfd .Rels .X (),"",0);if _bcfg :=_ccbg .Decode (_dde );_bcfg !=nil {return nil ,_bcfg ;
};for _ ,_adbe :=range _dde {if _adbe ==nil {continue ;};if _afbd :=_aacfd .AddExtraFileFromZip (_adbe );_afbd !=nil {return nil ,_afbd ;};};if _gcbc {_dfdef :=false ;for _ ,_fdab :=range _aacfd .Rels .X ().Relationship {if _fdab .TargetAttr =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_dfdef =true ;
break ;};};if !_dfdef {_aacfd .AddCustomRelationships ();};};return _aacfd ,nil ;};

// GetFormat returns a cell data format.
func (_daed *evalContext )GetFormat (cellRef string )string {return _daed ._abf .Cell (cellRef ).getFormat ();};

// SaveToFile writes the workbook out to a file.
func (_cbfdd *Workbook )SaveToFile (path string )error {_ddbfe ,_dbae :=_f .Create (path );if _dbae !=nil {return _dbae ;};defer _ddbfe .Close ();return _cbfdd .Save (_ddbfe );};

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_fag *_ee .CT_ColorScale };

// GetValueAsNumber retrieves the cell's value as a number
func (_fgb Cell )GetValueAsNumber ()(float64 ,error ){if _fgb ._ged .V ==nil &&_fgb ._ged .Is ==nil {return 0,nil ;};if _fgb ._ged .TAttr ==_ee .ST_CellTypeS ||!_abbg .IsNumber (*_fgb ._ged .V ){return _dca .NaN (),_gf .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");
};return _dc .ParseFloat (*_fgb ._ged .V ,64);};

// SetHyperlink sets a hyperlink on a cell.
func (_add Cell )SetHyperlink (hl _bb .Hyperlink ){_dccb :=_add ._ge ._bbag ;if _dccb .Hyperlinks ==nil {_dccb .Hyperlinks =_ee .NewCT_Hyperlinks ();};_fae :=_bb .Relationship (hl );_bdgb :=_ee .NewCT_Hyperlink ();_bdgb .RefAttr =_add .Reference ();_bdgb .IdAttr =_a .String (_fae .ID ());
_dccb .Hyperlinks .Hyperlink =append (_dccb .Hyperlinks .Hyperlink ,_bdgb );};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_bfg *Workbook )SetActiveSheetIndex (idx uint32 ){if _bfg ._bcbedf .BookViews ==nil {_bfg ._bcbedf .BookViews =_ee .NewCT_BookViews ();};if len (_bfg ._bcbedf .BookViews .WorkbookView )==0{_bfg ._bcbedf .BookViews .WorkbookView =append (_bfg ._bcbedf .BookViews .WorkbookView ,_ee .NewCT_BookView ());
};_bfg ._bcbedf .BookViews .WorkbookView [0].ActiveTabAttr =_a .Uint32 (idx );};func _fbcf (_ead bool )int {if _ead {return 1;};return 0;};

// SetHidden controls the visibility of a column.
func (_fgf Column )SetHidden (b bool ){if !b {_fgf ._ace .HiddenAttr =nil ;}else {_fgf ._ace .HiddenAttr =_a .Bool (true );};};

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_aadd *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_e .Replace (rangeRef ,"\u0024","",-1);_aadd ._bbag .AutoFilter =_ee .NewCT_AutoFilter ();_aadd ._bbag .AutoFilter .RefAttr =_a .String (rangeRef );_cff :="\u0027"+_aadd .Name ()+"\u0027\u0021";
var _ccaf DefinedName ;for _ ,_fabdd :=range _aadd ._edad .DefinedNames (){if _fabdd .Name ()==_ddbef {if _e .HasPrefix (_fabdd .Content (),_cff ){_ccaf =_fabdd ;_ccaf .SetContent (_aadd .RangeReference (rangeRef ));break ;};};};if _ccaf .X ()==nil {_ccaf =_aadd ._edad .AddDefinedName (_ddbef ,_aadd .RangeReference (rangeRef ));
};for _gfdg ,_bga :=range _aadd ._edad ._adce {if _bga ==_aadd ._bbag {_ccaf .SetLocalSheetID (uint32 (_gfdg ));};};};func NewPatternFill (fills *_ee .CT_Fills )PatternFill {_ecdc :=_ee .NewCT_Fill ();_ecdc .FillChoice =_ee .NewCT_FillChoice ();_ecdc .FillChoice .PatternFill =_ee .NewCT_PatternFill ();
return PatternFill {_ecdc .FillChoice .PatternFill ,_ecdc };};func (_dbeb *Sheet )slideCellsLeft (_ffbd []*_ee .CT_Cell )[]*_ee .CT_Cell {for _ ,_fefb :=range _ffbd {_fbec ,_cdeff :=_ffb .ParseCellReference (*_fefb .RAttr );if _cdeff !=nil {return _ffbd ;
};_accag :=_fbec .ColumnIdx -1;_aada :=_ffb .IndexToColumn (_accag )+_abb .Sprintf ("\u0025\u0064",_fbec .RowIdx );_fefb .RAttr =&_aada ;};return _ffbd ;};func NewFills ()Fills {return Fills {_ee .NewCT_Fills ()}};

// CellStyle is a formatting style for a cell. CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_eae *Workbook ;_beg *_ee .CT_Xf ;_egc *_ee .CT_CellXfs ;};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_cgfba TwoCellAnchor )SetWidthCells (w int32 ){_dbag :=_cgfba .TopLeft ();_abafb :=_cgfba .BottomRight ();_abafb .SetCol (_dbag .Col ()+w );};

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_bbc Cell )GetString ()string {switch _bbc ._ged .TAttr {case _ee .ST_CellTypeInlineStr :if _bbc ._ged .Is !=nil &&_bbc ._ged .Is .T !=nil {return *_bbc ._ged .Is .T ;};if _bbc ._ged .V !=nil {return *_bbc ._ged .V ;};case _ee .ST_CellTypeS :if _bbc ._ged .V ==nil {return "";
};_defc ,_fgg :=_dc .Atoi (*_bbc ._ged .V );if _fgg !=nil {return "";};_efd ,_fgg :=_bbc ._cfg .SharedStrings .GetString (_defc );if _fgg !=nil {return "";};return _efd ;};if _bbc ._ged .V ==nil {return "";};return *_bbc ._ged .V ;};

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_gbbb *Sheet )Cell (cellRef string )Cell {_dggb ,_ccba :=_ffb .ParseCellReference (cellRef );if _ccba !=nil {_gb .Log .Debug ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_ccba );
return _gbbb .AddRow ().AddCell ();};return _gbbb .Row (_dggb .RowIdx ).Cell (_dggb .Column );};

// Name returns the name of the defined name.
func (_cbed DefinedName )Name ()string {return _cbed ._degb .NameAttr };func (_ggae PatternFill )ClearFgColor (){_ggae ._fegc .FgColor =nil };

// SetWidth controls the width of a column.
func (_acda Column )SetWidth (w _ddde .Distance ){_acda ._ace .WidthAttr =_a .Float64 (float64 (w /_ddde .Character ));};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_bdgd Sheet )RangeReference (n string )string {_fgaf :=_e .Split (n ,"\u003a");_cdbg ,_ :=_ffb .ParseCellReference (_fgaf [0]);_cbdd :=_abb .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_cdbg .Column ,_cdbg .RowIdx );if len (_fgaf )==1{return _abb .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_bdgd .Name (),_cbdd );
};_ecfb ,_ :=_ffb .ParseCellReference (_fgaf [1]);_bfedb :=_abb .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_ecfb .Column ,_ecfb .RowIdx );return _abb .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_bdgd .Name (),_cbdd ,_bfedb );
};

// IsStructureLocked returns whether the workbook structure is locked.
func (_afbdd WorkbookProtection )IsStructureLocked ()bool {return _afbdd ._cafd .LockStructureAttr !=nil &&*_afbdd ._cafd .LockStructureAttr ;};

// HasFormula returns true if the cell contains formula.
func (_abg *evalContext )HasFormula (cellRef string )bool {return _abg ._abf .Cell (cellRef ).HasFormula ()};

// Protection controls the protection on an individual sheet.
func (_cead *Sheet )Protection ()SheetProtection {if _cead ._bbag .SheetProtection ==nil {_cead ._bbag .SheetProtection =_ee .NewCT_SheetProtection ();};return SheetProtection {_cead ._bbag .SheetProtection };};func (_eaaab StandardFormat )String ()string {switch {case 0<=_eaaab &&_eaaab <=4:return _faeea [_bebb [_eaaab ]:_bebb [_eaaab +1]];
case 9<=_eaaab &&_eaaab <=22:_eaaab -=9;return _fcec [_cadf [_eaaab ]:_cadf [_eaaab +1]];case 37<=_eaaab &&_eaaab <=40:_eaaab -=37;return _gdfb [_ccccc [_eaaab ]:_ccccc [_eaaab +1]];case 45<=_eaaab &&_eaaab <=49:_eaaab -=45;return _ebaa [_daeef [_eaaab ]:_daeef [_eaaab +1]];
default:return _abb .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_eaaab );};};

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_efdb *evalContext )LastRow (col string )int {_bege :=_efdb ._abf ;_dfa :=int (_ffb .ColumnToIndex (col ));_fbg :=1;for _ ,_baac :=range _bege ._bbag .SheetData .Row {if _baac .RAttr !=nil {_dacc :=Row {_bege ._edad ,_bege ,_baac };_babd :=len (_dacc .Cells ());
if _babd > _dfa {_fbg =int (_dacc .RowNumber ());};};};return _fbg ;};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_eag ,_fgce :=_f .Open (filename );if _fgce !=nil {return nil ,_abb .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_fgce );};defer _eag .Close ();
_cdeb ,_fgce :=_f .Stat (filename );if _fgce !=nil {return nil ,_abb .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_fgce );};_gdbb ,_fgce :=Read (_eag ,_cdeb .Size ());if _fgce !=nil {return nil ,_fgce ;
};_afgb ,_ :=_aec .Abs (_aec .Dir (filename ));_gdbb ._bcgeg =_aec .Join (_afgb ,filename );return _gdbb ,nil ;};

// SetRotation configures the cell to be rotated.
func (_aabg CellStyle )SetRotation (deg uint8 ){if _aabg ._beg .Alignment ==nil {_aabg ._beg .Alignment =_ee .NewCT_CellAlignment ();};_aabg ._beg .ApplyAlignmentAttr =_a .Bool (true );_aabg ._beg .Alignment .TextRotationAttr =_a .Uint8 (deg );};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_aeaf *Workbook )ClearCachedFormulaResults (){for _ ,_eccc :=range _aeaf .Sheets (){_eccc .ClearCachedFormulaResults ();};};

// RowOffset returns the offset from the row cell.
func (_eda CellMarker )RowOffset ()_ddde .Distance {if _eda ._fed .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _ddde .Distance (float64 (*_eda ._fed .RowOff .ST_CoordinateUnqualified )*_ddde .EMU );};

// RemoveDefinedName removes an existing defined name.
func (_dbff *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _gf .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");
};for _efbbe ,_fgadee :=range _dbff ._bcbedf .DefinedNames .DefinedName {if _fgadee ==dn .X (){copy (_dbff ._bcbedf .DefinedNames .DefinedName [_efbbe :],_dbff ._bcbedf .DefinedNames .DefinedName [_efbbe +1:]);_dbff ._bcbedf .DefinedNames .DefinedName [len (_dbff ._bcbedf .DefinedNames .DefinedName )-1]=nil ;
_dbff ._bcbedf .DefinedNames .DefinedName =_dbff ._bcbedf .DefinedNames .DefinedName [:len (_dbff ._bcbedf .DefinedNames .DefinedName )-1];return nil ;};};return _gf .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");
};func (_bbgc *Sheet )setArray (_ffga string ,_agfg _ffc .Result )error {_ddgc ,_aege :=_ffb .ParseCellReference (_ffga );if _aege !=nil {return _aege ;};for _efag ,_ddbf :=range _agfg .ValueArray {_febb :=_bbgc .Row (_ddgc .RowIdx +uint32 (_efag ));for _ecfcf ,_gcag :=range _ddbf {_egad :=_febb .Cell (_ffb .IndexToColumn (_ddgc .ColumnIdx +uint32 (_ecfcf )));
if _gcag .Type !=_ffc .ResultTypeEmpty {if _gcag .IsBoolean {_egad .SetBool (_gcag .ValueNumber !=0);}else {_egad .SetCachedFormulaResult (_gcag .String ());};};};};return nil ;};

// X returns the inner wrapped XML type.
func (_cged Row )X ()*_ee .CT_Row {return _cged ._abbe };

// IsSheetLocked returns whether the sheet objects are locked.
func (_dadf SheetProtection )IsObjectLocked ()bool {return _dadf ._bbaf .ObjectsAttr !=nil &&*_dadf ._bbaf .ObjectsAttr ;};

// SortOrder is a column sort order.
//
//go:generate stringer -type=SortOrder
type SortOrder byte ;

// SetHeightAuto sets the row height to be automatically determined.
func (_accf Row )SetHeightAuto (){_accf ._abbe .HtAttr =nil ;_accf ._abbe .CustomHeightAttr =nil };

// IsBool returns true if the cell is a boolean type cell.
func (_bdc Cell )IsBool ()bool {return _bdc ._ged .TAttr ==_ee .ST_CellTypeB };

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_aggf *_ee .Sst ;_bagg map[string ]int ;};

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_cgb *_ee .CT_DataValidation };

// X returns the inner wrapped XML type.
func (_baf Cell )X ()*_ee .CT_Cell {return _baf ._ged };var _bccf =_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .SharedStringsType ,0);

// AddFill creates a new empty Fill style.
func (_age Fills )AddFill ()Fill {_gfbd :=_ee .NewCT_Fill ();return Fill {_gfbd ,_age ._ebfc }};

// X returns the inner wrapped XML type.
func (_dfgb SheetView )X ()*_ee .CT_SheetView {return _dfgb ._ceda };

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_faef *Sheet )SetBorder (cellRange string ,border Border )error {_eaf ,_eefb ,_cfge :=_ffb .ParseRangeReference (cellRange );if _cfge !=nil {return _cfge ;};_egae :=_faef ._edad .StyleSheet .AddCellStyle ();_fgaea :=_faef ._edad .StyleSheet .AddBorder ();
_egae .SetBorder (_fgaea );_fgaea ._cde .Top =border ._cde .Top ;_fgaea ._cde .Left =border ._cde .Left ;_deaf :=_faef ._edad .StyleSheet .AddCellStyle ();_bfc :=_faef ._edad .StyleSheet .AddBorder ();_deaf .SetBorder (_bfc );_bfc ._cde .Top =border ._cde .Top ;
_bfc ._cde .Right =border ._cde .Right ;_dbaad :=_faef ._edad .StyleSheet .AddCellStyle ();_acca :=_faef ._edad .StyleSheet .AddBorder ();_dbaad .SetBorder (_acca );_acca ._cde .Top =border ._cde .Top ;_dfcbd :=_faef ._edad .StyleSheet .AddCellStyle ();
_gaaf :=_faef ._edad .StyleSheet .AddBorder ();_dfcbd .SetBorder (_gaaf );_gaaf ._cde .Left =border ._cde .Left ;_gge :=_faef ._edad .StyleSheet .AddCellStyle ();_edff :=_faef ._edad .StyleSheet .AddBorder ();_gge .SetBorder (_edff );_edff ._cde .Right =border ._cde .Right ;
_ecdg :=_faef ._edad .StyleSheet .AddCellStyle ();_fafec :=_faef ._edad .StyleSheet .AddBorder ();_ecdg .SetBorder (_fafec );_fafec ._cde .Bottom =border ._cde .Bottom ;_dgcd :=_faef ._edad .StyleSheet .AddCellStyle ();_fcfe :=_faef ._edad .StyleSheet .AddBorder ();
_dgcd .SetBorder (_fcfe );_fcfe ._cde .Bottom =border ._cde .Bottom ;_fcfe ._cde .Left =border ._cde .Left ;_gffb :=_faef ._edad .StyleSheet .AddCellStyle ();_bcge :=_faef ._edad .StyleSheet .AddBorder ();_gffb .SetBorder (_bcge );_bcge ._cde .Bottom =border ._cde .Bottom ;
_bcge ._cde .Right =border ._cde .Right ;_ecg :=_eaf .RowIdx ;_abafg :=_eaf .ColumnIdx ;_bbeb :=_eefb .RowIdx ;_cgff :=_eefb .ColumnIdx ;for _cdcd :=_ecg ;_cdcd <=_bbeb ;_cdcd ++{for _edab :=_abafg ;_edab <=_cgff ;_edab ++{_bdb :=_abb .Sprintf ("\u0025\u0073\u0025\u0064",_ffb .IndexToColumn (_edab ),_cdcd );
switch {case _cdcd ==_ecg &&_edab ==_abafg :_faef .Cell (_bdb ).SetStyle (_egae );case _cdcd ==_ecg &&_edab ==_cgff :_faef .Cell (_bdb ).SetStyle (_deaf );case _cdcd ==_bbeb &&_edab ==_abafg :_faef .Cell (_bdb ).SetStyle (_dgcd );case _cdcd ==_bbeb &&_edab ==_cgff :_faef .Cell (_bdb ).SetStyle (_gffb );
case _cdcd ==_ecg :_faef .Cell (_bdb ).SetStyle (_dbaad );case _cdcd ==_bbeb :_faef .Cell (_bdb ).SetStyle (_ecdg );case _edab ==_abafg :_faef .Cell (_bdb ).SetStyle (_dfcbd );case _edab ==_cgff :_faef .Cell (_bdb ).SetStyle (_gge );};};};return nil ;};


// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_aabd *Workbook )AddDefinedName (name ,ref string )DefinedName {if _aabd ._bcbedf .DefinedNames ==nil {_aabd ._bcbedf .DefinedNames =_ee .NewCT_DefinedNames ();};_acbdb :=_ee .NewCT_DefinedName ();_acbdb .Content =ref ;_acbdb .NameAttr =name ;_aabd ._bcbedf .DefinedNames .DefinedName =append (_aabd ._bcbedf .DefinedNames .DefinedName ,_acbdb );
return DefinedName {_acbdb };};

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_cdgf TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_cdgf ._dedde .From }};

// SetNumber sets the cell type to number, and the value to the given number
func (_bfe Cell )SetNumber (v float64 ){_bfe .clearValue ();if _dca .IsNaN (v )||_dca .IsInf (v ,0){_bfe ._ged .TAttr =_ee .ST_CellTypeE ;_bfe ._ged .V =_a .String ("\u0023\u004e\u0055M\u0021");return ;};_bfe ._ged .TAttr =_ee .ST_CellTypeN ;_bfe ._ged .V =_a .String (_dc .FormatFloat (v ,'f',-1,64));
};func (_abff *Sheet )setShared (_ecbga string ,_acad ,_ccefd _ffb .CellReference ,_eaba string ){_edaa :=_abff .FormulaContext ();_gagae :=_ffc .NewEvaluator ();for _acbd :=_acad .RowIdx ;_acbd <=_ccefd .RowIdx ;_acbd ++{for _agab :=_acad .ColumnIdx ;
_agab <=_ccefd .ColumnIdx ;_agab ++{_ccee :=_acbd -_acad .RowIdx ;_ceaaf :=_agab -_acad .ColumnIdx ;_edaa .SetOffset (_ceaaf ,_ccee );_gffa :=_gagae .Eval (_edaa ,_eaba );_bdag :=_abb .Sprintf ("\u0025\u0073\u0025\u0064",_ffb .IndexToColumn (_agab ),_acbd );
_aagce :=_abff .Cell (_bdag );if _gffa .Type ==_ffc .ResultTypeNumber {_aagce .X ().TAttr =_ee .ST_CellTypeN ;}else {_aagce .X ().TAttr =_ee .ST_CellTypeInlineStr ;};_aagce .X ().V =_a .String (_gffa .Value ());};};_ =_gagae ;_ =_edaa ;};func (_gcca Sheet )validateSheetNames ()error {_caed :=len ([]rune (_gcca .Name ()));
if _caed > 31{return _abb .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_gcca .Name (),_caed );
};return nil ;};

// SetIcons sets the icon set to use for display.
func (_dfdb IconScale )SetIcons (t _ee .ST_IconSetType ){_dfdb ._bccd .IconSetAttr =t };func (_dcde DifferentialStyle )Fill ()Fill {if _dcde ._efef .Fill ==nil {_dcde ._efef .Fill =_ee .NewCT_Fill ();};return Fill {_dcde ._efef .Fill ,nil };};func (_fedd StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));
};for _ ,_adcg :=range _fedd ._dbdd .NumFmts .NumFmt {if _adcg .NumFmtIdAttr ==id {return NumberFormat {_fedd ._ecfba ,_adcg };};};return NumberFormat {};};

// X returns the inner wrapped XML type.
func (_bge Comment )X ()*_ee .CT_Comment {return _bge ._eba };func (_cabb Border )SetTop (style _ee .ST_BorderStyle ,c _cb .Color ){if _cabb ._cde .Top ==nil {_cabb ._cde .Top =_ee .NewCT_BorderPr ();};_cabb ._cde .Top .Color =_ee .NewCT_Color ();_cabb ._cde .Top .Color .RgbAttr =c .AsRGBAString ();
_cabb ._cde .Top .StyleAttr =style ;};

// GetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_egcd CellStyle )GetHorizontalAlignment ()_ee .ST_HorizontalAlignment {if _egcd ._beg .Alignment ==nil {return _ee .ST_HorizontalAlignmentUnset ;};return _egcd ._beg .Alignment .HorizontalAttr ;};

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_caeb *_ee .CT_RElt };

// Workbook returns sheet's parent workbook.
func (_dcca *Sheet )Workbook ()*Workbook {return _dcca ._edad };

// SetWidth is a no-op.
func (_dbec TwoCellAnchor )SetWidth (w _ddde .Distance ){};

// Validate attempts to validate the structure of a workbook.
func (_dfcc *Workbook )Validate ()error {if _dfcc ==nil ||_dfcc ._bcbedf ==nil {return _gf .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");
};_dccd :=uint32 (0);for _ ,_aefd :=range _dfcc ._bcbedf .Sheets .Sheet {if _aefd .SheetIdAttr > _dccd {_dccd =_aefd .SheetIdAttr ;};};if _dccd !=uint32 (len (_dfcc ._adce )){return _abb .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_dccd ,len (_dfcc ._adce ));
};_abgg :=map[string ]struct{}{};for _ebge ,_bdad :=range _dfcc ._bcbedf .Sheets .Sheet {_efde :=Sheet {_dfcc ,_bdad ,_dfcc ._adce [_ebge ]};if _ ,_bcbcc :=_abgg [_efde .Name ()];_bcbcc {return _abb .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_ebge ,_efde .Name ());
};_abgg [_efde .Name ()]=struct{}{};if _ccea :=_efde .ValidateWithPath (_abb .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_ebge ));_ccea !=nil {return _ccea ;};if _ecgf :=_efde .Validate ();_ecgf !=nil {return _ecgf ;
};};return nil ;};

// ClearNumberFormat removes any number formatting from the style.
func (_dfbg CellStyle )ClearNumberFormat (){_dfbg ._beg .NumFmtIdAttr =nil ;_dfbg ._beg .ApplyNumberFormatAttr =nil ;};

// GetFill gets a Fill from a cell style.
func (_ceag CellStyle )GetFill ()*_ee .CT_Fill {if _dcf :=_ceag ._beg .FillIdAttr ;_dcf !=nil {_bgc :=_ceag ._eae .StyleSheet .Fills ().X ().Fill ;if int (*_dcf )< len (_bgc ){return _bgc [int (*_dcf )];};};return nil ;};

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_fdaa SheetView )SetZoom (pct uint32 ){_fdaa ._ceda .ZoomScaleAttr =&pct };

// IsNumber returns true if the cell is a number type cell.
func (_gbg Cell )IsNumber ()bool {switch _gbg ._ged .TAttr {case _ee .ST_CellTypeN :return true ;case _ee .ST_CellTypeS ,_ee .ST_CellTypeB :return false ;};return _gbg ._ged .V !=nil &&_abbg .IsNumber (*_gbg ._ged .V );};func (_ebb Font )SetBold (b bool ){_aaab :=false ;
for _dgdg ,_dda :=range _ebb ._eadf .FontChoice {if _dda .B !=nil {if b {_ebb ._eadf .FontChoice [_dgdg ].B =&_ee .CT_BooleanProperty {};}else {_ebb ._eadf .FontChoice [_dgdg ]=nil ;};_aaab =true ;};};if !_aaab {_ebb ._eadf .FontChoice =append (_ebb ._eadf .FontChoice ,&_ee .CT_FontChoice {B :&_ee .CT_BooleanProperty {}});
};};

// SetBold causes the text to be displayed in bold.
func (_gcffb RichTextRun )SetBold (b bool ){_gcffb .ensureRpr ();for _ ,_aebb :=range _gcffb ._caeb .RPr .RPrEltChoice {if _aebb .B !=nil {_aebb .B .ValAttr =_a .Bool (b );return ;};};_gcffb ._caeb .RPr .RPrEltChoice =append (_gcffb ._caeb .RPr .RPrEltChoice ,&_ee .CT_RPrEltChoice {B :&_ee .CT_BooleanProperty {ValAttr :_a .Bool (b )}});
};

// SetHidden hides or unhides the row
func (_cecf Row )SetHidden (hidden bool ){if !hidden {_cecf ._abbe .HiddenAttr =nil ;}else {_cecf ._abbe .HiddenAttr =_a .Bool (true );};};

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_ee .Comments )Comments {return Comments {w ,x }};var _bagb =false ;

// Operator returns the operator for the rule
func (_dcdff ConditionalFormattingRule )Operator ()_ee .ST_ConditionalFormattingOperator {return _dcdff ._ddg .OperatorAttr ;};

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_cfad *Workbook )Close ()error {if _cfad .TmpPath !=""{return _fa .RemoveAll (_cfad .TmpPath );};return nil ;};

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_ebff DataValidationList )SetRange (cellRange string ){_ebff ._cgb .Formula1 =_a .String (cellRange );_ebff ._cgb .Formula2 =_a .String ("\u0030");};

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_cbe AbsoluteAnchor )SetRowOffset (m _ddde .Distance ){_cbe ._gg .Pos .YAttr .ST_CoordinateUnqualified =_a .Int64 (int64 (m /_ddde .EMU ));};func (_dafb *Sheet )addNumberedRowFast (_edca uint32 )Row {_ebbd :=_ee .NewCT_Row ();_ebbd .RAttr =_a .Uint32 (_edca );
_dafb ._bbag .SheetData .Row =append (_dafb ._bbag .SheetData .Row ,_ebbd );return Row {_dafb ._edad ,_dafb ,_ebbd };};

// SetColor sets the text color.
func (_dfga RichTextRun )SetColor (c _cb .Color ){_dfga .ensureRpr ();_dgdgc :="\u0066\u0066"+*c .AsRGBString ();for _ ,_bae :=range _dfga ._caeb .RPr .RPrEltChoice {if _bae .Color !=nil {_bae .Color .RgbAttr =&_dgdgc ;return ;};};_dfga ._caeb .RPr .RPrEltChoice =append (_dfga ._caeb .RPr .RPrEltChoice ,&_ee .CT_RPrEltChoice {Color :&_ee .CT_Color {RgbAttr :&_dgdgc }});
};

// LockObject controls the locking of the sheet objects.
func (_gedf SheetProtection )LockObject (b bool ){if !b {_gedf ._bbaf .ObjectsAttr =nil ;}else {_gedf ._bbaf .ObjectsAttr =_a .Bool (true );};};

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_gfd CellStyle )SetVerticalAlignment (a _ee .ST_VerticalAlignment ){if _gfd ._beg .Alignment ==nil {_gfd ._beg .Alignment =_ee .NewCT_CellAlignment ();};_gfd ._beg .ApplyAlignmentAttr =_a .Bool (true );_gfd ._beg .Alignment .VerticalAttr =a ;};

// SetMinLength sets the minimum bar length in percent.
func (_defg DataBarScale )SetMinLength (l uint32 ){_defg ._dgg .MinLengthAttr =_a .Uint32 (l )};

// SetRow set the row of the cell marker.
func (_dff CellMarker )SetRow (row int32 ){_dff ._fed .Row =row };

// BottomRight is a no-op.
func (_ddbdg OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};func (_gfbg DataValidation )clear (){_gfbg ._abdc .Formula1 =_a .String ("\u0030");_gfbg ._abdc .Formula2 =_a .String ("\u0030");};

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_ddbg *Workbook )Uses1904Dates ()bool {if _ddbg ._bcbedf .WorkbookPr ==nil ||_ddbg ._bcbedf .WorkbookPr .Date1904Attr ==nil {return false ;};return *_ddbg ._bcbedf .WorkbookPr .Date1904Attr ;};func _gdb (_cgf *Sheet )*evalContext {return &evalContext {_abf :_cgf ,_adbd :make (map[string ]struct{})};
};

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_ecbd *Sheet )SetDrawing (d Drawing ){var _gcab _bb .Relationships ;for _gcfb ,_fdd :=range _ecbd ._edad ._adce {if _fdd ==_ecbd ._bbag {_gcab =_ecbd ._edad ._bggf [_gcfb ];break ;};};var _ebfa string ;for _dagf ,_baee :=range d ._ffcd ._cefb {if _baee ==d ._aaedc {_ebdg :=_gcab .AddAutoRelationship (_a .DocTypeSpreadsheet ,_a .WorksheetType ,_dagf +1,_a .DrawingType );
_ebfa =_ebdg .ID ();break ;};};_ecbd ._bbag .Drawing =_ee .NewCT_Drawing ();_ecbd ._bbag .Drawing .IdAttr =_ebfa ;};func (_cbd Cell )getRawSortValue ()(string ,bool ){if _cbd .HasFormula (){_fbba :=_cbd .GetCachedFormulaResult ();return _fbba ,_abbg .IsNumber (_fbba );
};_cgc ,_ :=_cbd .GetRawValue ();return _cgc ,_abbg .IsNumber (_cgc );};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_bee Row )RowNumber ()uint32 {if _bee ._abbe .RAttr !=nil {return *_bee ._abbe .RAttr ;};return 0;};

// X returns the inner wrapped XML type.
func (_gcfe CellMarker )X ()*_cce .CT_Marker {return _gcfe ._fed };

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_fabg *Sheet )InsertRow (rowNum int )Row {_ecc :=uint32 (rowNum );for _ ,_eebg :=range _fabg .Rows (){if _eebg ._abbe .RAttr !=nil &&*_eebg ._abbe .RAttr >=_ecc {*_eebg ._abbe .RAttr ++;for _ ,_fdgg :=range _eebg .Cells (){_fage ,_dbfb :=_ffb .ParseCellReference (_fdgg .Reference ());
if _dbfb !=nil {continue ;};_fage .RowIdx ++;_fdgg ._ged .RAttr =_a .String (_fage .String ());};};};for _ ,_gccc :=range _fabg .MergedCells (){_gfdb ,_gede ,_edbf :=_ffb .ParseRangeReference (_gccc .Reference ());if _edbf !=nil {continue ;};if int (_gfdb .RowIdx )>=rowNum {_gfdb .RowIdx ++;
};if int (_gede .RowIdx )>=rowNum {_gede .RowIdx ++;};_decg :=_abb .Sprintf ("\u0025\u0073\u003a%\u0073",_gfdb ,_gede );_gccc .SetReference (_decg );};return _fabg .AddNumberedRow (_ecc );};

// SetHidden marks the defined name as hidden.
func (_cbc DefinedName )SetHidden (b bool ){_cbc ._degb .HiddenAttr =_a .Bool (b )};

// SetHeightCells is a no-op.
func (_afc OneCellAnchor )SetHeightCells (int32 ){};

// GetFormat sets the number format code.
func (_defa NumberFormat )GetFormat ()string {return _defa ._addg .FormatCodeAttr };func (_bbce *evalContext )NamedRange (ref string )_ffc .Reference {for _ ,_edcc :=range _bbce ._abf ._edad .DefinedNames (){if _edcc .Name ()==ref {return _ffc .MakeRangeReference (_edcc .Content ());
};};for _ ,_ffa :=range _bbce ._abf ._edad .Tables (){if _ffa .Name ()==ref {return _ffc .MakeRangeReference (_abb .Sprintf ("\u0025\u0073\u0021%\u0073",_bbce ._abf .Name (),_ffa .Reference ()));};};return _ffc .ReferenceInvalid ;};

// SetMaxLength sets the maximum bar length in percent.
func (_gdbe DataBarScale )SetMaxLength (l uint32 ){_gdbe ._dgg .MaxLengthAttr =_a .Uint32 (l )};

// AddSheet adds a new sheet to a workbook.
func (_bebg *Workbook )AddSheet ()Sheet {_fgea :=_ee .NewCT_Sheet ();_fgea .SheetIdAttr =1;for _ ,_gdac :=range _bebg ._bcbedf .Sheets .Sheet {if _fgea .SheetIdAttr <=_gdac .SheetIdAttr {_fgea .SheetIdAttr =_gdac .SheetIdAttr +1;};};_bebg ._bcbedf .Sheets .Sheet =append (_bebg ._bcbedf .Sheets .Sheet ,_fgea );
_fgea .NameAttr =_abb .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_fgea .SheetIdAttr );_ffagc :=_ee .NewWorksheet ();_ffagc .Dimension =_ee .NewCT_SheetDimension ();_ffagc .Dimension .RefAttr ="\u0041\u0031";_bebg ._adce =append (_bebg ._adce ,_ffagc );
_gfec :=_bb .NewRelationships ();_bebg ._bggf =append (_bebg ._bggf ,_gfec );_ffagc .SheetData =_ee .NewCT_SheetData ();_bebg ._fbda =append (_bebg ._fbda ,nil );_cbbdb :=_a .DocTypeSpreadsheet ;_fcab :=_bebg ._afafd .AddAutoRelationship (_cbbdb ,_a .OfficeDocumentType ,len (_bebg ._bcbedf .Sheets .Sheet ),_a .WorksheetType );
_fgea .IdAttr =_fcab .ID ();_bebg .ContentTypes .AddOverride (_a .AbsoluteFilename (_cbbdb ,_a .WorksheetContentType ,len (_bebg ._bcbedf .Sheets .Sheet )),_a .WorksheetContentType );return Sheet {_bebg ,_fgea ,_ffagc };};

// HasNumberFormat returns true if the cell style has a number format applied.
func (_dafg CellStyle )HasNumberFormat ()bool {return _dafg ._beg .NumFmtIdAttr !=nil &&_dafg ._beg .ApplyNumberFormatAttr !=nil &&*_dafg ._beg .ApplyNumberFormatAttr ;};

// Sheet is a single sheet within a workbook.
type Sheet struct{_edad *Workbook ;_aefa *_ee .CT_Sheet ;_bbag *_ee .Worksheet ;};

// InitializeDefaults initializes a border to its defaulte empty values.
func (_cea Border )InitializeDefaults (){_cea ._cde .Left =_ee .NewCT_BorderPr ();_cea ._cde .Bottom =_ee .NewCT_BorderPr ();_cea ._cde .Right =_ee .NewCT_BorderPr ();_cea ._cde .Top =_ee .NewCT_BorderPr ();_cea ._cde .Diagonal =_ee .NewCT_BorderPr ();
};

// SetAllowBlank controls if blank values are accepted.
func (_acfd DataValidation )SetAllowBlank (b bool ){if !b {_acfd ._abdc .AllowBlankAttr =nil ;}else {_acfd ._abdc .AllowBlankAttr =_a .Bool (true );};};var _cfaea =_a .RelativeFilename (_a .DocTypeSpreadsheet ,_a .OfficeDocumentType ,_a .SharedStringsType ,0);


// SetYSplit sets the row split point
func (_fadb SheetView )SetYSplit (v float64 ){_fadb .ensurePane ();_fadb ._ceda .Pane .YSplitAttr =_a .Float64 (v );};

// X returns the inner wrapped XML type.
func (_aaed ConditionalFormatting )X ()*_ee .CT_ConditionalFormatting {return _aaed ._cfgb };func _fge (_eeef string ,_adag uint32 ,_beag bool )string {_cgea ,_bcfgg ,_fggdd :=_ffb .ParseRangeReference (_eeef );if _fggdd ==nil {_gbff ,_ccfb :=_cgea .ColumnIdx ,_bcfgg .ColumnIdx ;
if _adag >=_gbff &&_adag <=_ccfb {if _gbff ==_ccfb {if _beag {return "";}else {return _eeef ;};}else {_ebfce :=_bcfgg .Update (_gc .UpdateActionRemoveColumn );return _abb .Sprintf ("\u0025\u0073\u003a%\u0073",_cgea .String (),_ebfce .String ());};}else if _adag < _gbff {_cbaa :=_cgea .Update (_gc .UpdateActionRemoveColumn );
_bacb :=_bcfgg .Update (_gc .UpdateActionRemoveColumn );return _abb .Sprintf ("\u0025\u0073\u003a%\u0073",_cbaa .String (),_bacb .String ());};}else {_ggf ,_deaa ,_ddbeg :=_ffb .ParseColumnRangeReference (_eeef );if _ddbeg !=nil {return "";};_faaa ,_bbgd :=_ggf .ColumnIdx ,_deaa .ColumnIdx ;
if _adag >=_faaa &&_adag <=_bbgd {if _faaa ==_bbgd {if _beag {return "";}else {return _eeef ;};}else {_cafc :=_deaa .Update (_gc .UpdateActionRemoveColumn );return _abb .Sprintf ("\u0025\u0073\u003a%\u0073",_ggf .String (),_cafc .String ());};}else if _adag < _faaa {_adega :=_ggf .Update (_gc .UpdateActionRemoveColumn );
_fdb :=_deaa .Update (_gc .UpdateActionRemoveColumn );return _abb .Sprintf ("\u0025\u0073\u003a%\u0073",_adega .String (),_fdb .String ());};};return "";};

// SetRowOffset sets a column offset in absolute distance.
func (_ccfg CellMarker )SetRowOffset (m _ddde .Distance ){_ccfg ._fed .RowOff .ST_CoordinateUnqualified =_a .Int64 (int64 (m /_ddde .EMU ));};

// SetHeight is a nop-op.
func (_fadcg TwoCellAnchor )SetHeight (h _ddde .Distance ){};

// SetText sets the text to be displayed.
func (_gaff RichTextRun )SetText (s string ){_gaff ._caeb .T =s };

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_cbb Drawing )AddImage (img _bb .ImageRef ,at AnchorType )Anchor {_fde :=0;for _aagc ,_cded :=range _cbb ._ffcd .Images {if _cded ==img {_fde =_aagc +1;break ;};};var _ffba string ;for _bgec ,_daec :=range _cbb ._ffcd ._cefb {if _daec ==_cbb ._aaedc {_bcbga :=_abb .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_fde ,img .Format ());
_fgfe :=_cbb ._ffcd ._dffd [_bgec ].AddRelationship (_bcbga ,_a .ImageType );_ffba =_fgfe .ID ();break ;};};var _daee Anchor ;var _ccbd *_cce .CT_Picture ;switch at {case AnchorTypeAbsolute :_gbfa :=_bgfb ();_cbb ._aaedc .EG_Anchor =append (_cbb ._aaedc .EG_Anchor ,&_cce .EG_Anchor {AnchorChoice :&_cce .EG_AnchorChoice {AbsoluteAnchor :_gbfa }});
_gbfa .ObjectChoicesChoice =&_cce .EG_ObjectChoicesChoice {};_gbfa .ObjectChoicesChoice .Pic =_cce .NewCT_Picture ();_gbfa .Pos .XAttr .ST_CoordinateUnqualified =_a .Int64 (0);_gbfa .Pos .YAttr .ST_CoordinateUnqualified =_a .Int64 (0);_ccbd =_gbfa .ObjectChoicesChoice .Pic ;
_daee =AbsoluteAnchor {_gbfa };case AnchorTypeOneCell :_gdc :=_ebcc ();_cbb ._aaedc .EG_Anchor =append (_cbb ._aaedc .EG_Anchor ,&_cce .EG_Anchor {AnchorChoice :&_cce .EG_AnchorChoice {OneCellAnchor :_gdc }});_gdc .ObjectChoicesChoice =&_cce .EG_ObjectChoicesChoice {};
_gdc .ObjectChoicesChoice .Pic =_cce .NewCT_Picture ();_ccbd =_gdc .ObjectChoicesChoice .Pic ;_daee =OneCellAnchor {_gdc };case AnchorTypeTwoCell :_efca :=_affb ();_cbb ._aaedc .EG_Anchor =append (_cbb ._aaedc .EG_Anchor ,&_cce .EG_Anchor {AnchorChoice :&_cce .EG_AnchorChoice {TwoCellAnchor :_efca }});
_efca .ObjectChoicesChoice =&_cce .EG_ObjectChoicesChoice {};_efca .ObjectChoicesChoice .Pic =_cce .NewCT_Picture ();_ccbd =_efca .ObjectChoicesChoice .Pic ;_daee =TwoCellAnchor {_efca };};_ccbd .NvPicPr .CNvPr .IdAttr =uint32 (len (_cbb ._aaedc .EG_Anchor ));
_ccbd .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_ccbd .BlipFill .Blip =_df .NewCT_Blip ();_ccbd .BlipFill .Blip .EmbedAttr =_a .String (_ffba );_ccbd .BlipFill .FillModePropertiesChoice .Stretch =_df .NewCT_StretchInfoProperties ();_ccbd .SpPr =_df .NewCT_ShapeProperties ();
_ccbd .SpPr .Xfrm =_df .NewCT_Transform2D ();_ccbd .SpPr .Xfrm .Off =_df .NewCT_Point2D ();_ccbd .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_a .Int64 (0);_ccbd .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_a .Int64 (0);_ccbd .SpPr .Xfrm .Ext =_df .NewCT_PositiveSize2D ();
_ccbd .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_ddde .Pixel72 )/_ddde .EMU );_ccbd .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_ddde .Pixel72 )/_ddde .EMU );_ccbd .SpPr .GeometryChoice .PrstGeom =_df .NewCT_PresetGeometry2D ();
_ccbd .SpPr .GeometryChoice .PrstGeom .PrstAttr =_df .ST_ShapeTypeRect ;_ccbd .SpPr .Ln =_df .NewCT_LineProperties ();_ccbd .SpPr .Ln .LineFillPropertiesChoice .NoFill =_df .NewCT_NoFillProperties ();return _daee ;};var (_bebb =[...]uint8 {0,21,46,61,76,91};
_cadf =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_ccccc =[...]uint8 {0,16,32,48,64};_daeef =[...]uint8 {0,16,32,48,64,80};);

// Borders returns the list of borders defined in the stylesheet.
func (_dfad StyleSheet )Borders ()[]Border {_beec :=[]Border {};for _ ,_debd :=range _dfad ._dbdd .Borders .Border {_beec =append (_beec ,Border {_cde :_debd });};return _beec ;};type PatternFill struct{_fegc *_ee .CT_PatternFill ;_aca *_ee .CT_Fill ;};


// SetState sets the sheet view state (frozen/split/frozen-split)
func (_cbecf SheetView )SetState (st _ee .ST_PaneState ){_cbecf .ensurePane ();_cbecf ._ceda .Pane .StateAttr =st ;};

// SetHeightCells is a no-op.
func (_ccb AbsoluteAnchor )SetHeightCells (int32 ){};

// ClearFill clears any fill configuration from the cell style.
func (_eeg CellStyle )ClearFill (){_eeg ._beg .FillIdAttr =nil ;_eeg ._beg .ApplyFillAttr =nil };

// WorkbookText is an array of extracted text items which has some methods for representing extracted text from a workbook.
type WorkbookText struct{Sheets []*SheetText ;};

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_adf *_cce .CT_OneCellAnchor };

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_ceda *_ee .CT_SheetView };

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_ccg IconScale )AddFormatValue (t _ee .ST_CfvoType ,val string ){_gdce :=_ee .NewCT_Cfvo ();_gdce .TypeAttr =t ;_gdce .ValAttr =_a .String (val );_ccg ._bccd .Cfvo =append (_ccg ._bccd .Cfvo ,_gdce );};

// X returns the inner wrapped XML type.
func (_acee RichText )X ()*_ee .CT_Rst {return _acee ._beac };

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_aea Cell )SetFormulaShared (formulaStr string ,rows ,cols uint32 )error {_cef :=_ffc .ParseString (formulaStr );if _cef ==nil {return _gf .New (_abb .Sprintf ("\u0043a\u006en\u006f\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0073",formulaStr ));
};_aea .clearValue ();_aea ._ged .TAttr =_ee .ST_CellTypeStr ;_aea ._ged .F =_ee .NewCT_CellFormula ();_aea ._ged .F .TAttr =_ee .ST_CellFormulaTypeShared ;_aea ._ged .F .Content =formulaStr ;_dbf ,_eac :=_ffb .ParseCellReference (_aea .Reference ());if _eac !=nil {return _eac ;
};_fef :=uint32 (0);for _ ,_gfef :=range _aea ._ge .Rows (){for _ ,_eb :=range _gfef ._abbe .C {if _eb .F !=nil &&_eb .F .SiAttr !=nil &&*_eb .F .SiAttr >=_fef {_fef =*_eb .F .SiAttr ;};};};_fef ++;_cae :=_abb .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_dbf .Column ,_dbf .RowIdx ,_ffb .IndexToColumn (_dbf .ColumnIdx +cols ),_dbf .RowIdx +rows );
_aea ._ged .F .RefAttr =_a .String (_cae );_aea ._ged .F .SiAttr =_a .Uint32 (_fef );_ddbd :=Sheet {_aea ._cfg ,_aea ._ge ._aefa ,_aea ._ge ._bbag };for _dbfe :=_dbf .RowIdx ;_dbfe <=_dbf .RowIdx +rows ;_dbfe ++{for _bab :=_dbf .ColumnIdx ;_bab <=_dbf .ColumnIdx +cols ;
_bab ++{if _dbfe ==_dbf .RowIdx &&_bab ==_dbf .ColumnIdx {continue ;};_fg :=_abb .Sprintf ("\u0025\u0073\u0025\u0064",_ffb .IndexToColumn (_bab ),_dbfe );_ddbd .Cell (_fg ).Clear ();_ddbd .Cell (_fg ).X ().F =_ee .NewCT_CellFormula ();_ddbd .Cell (_fg ).X ().F .TAttr =_ee .ST_CellFormulaTypeShared ;
_ddbd .Cell (_fg ).X ().F .SiAttr =_a .Uint32 (_fef );};};return nil ;};

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_aggg *Sheet )RemoveMergedCell (mc MergedCell ){for _eadbb ,_gfae :=range _aggg ._bbag .MergeCells .MergeCell {if _gfae ==mc .X (){copy (_aggg ._bbag .MergeCells .MergeCell [_eadbb :],_aggg ._bbag .MergeCells .MergeCell [_eadbb +1:]);_aggg ._bbag .MergeCells .MergeCell [len (_aggg ._bbag .MergeCells .MergeCell )-1]=nil ;
_aggg ._bbag .MergeCells .MergeCell =_aggg ._bbag .MergeCells .MergeCell [:len (_aggg ._bbag .MergeCells .MergeCell )-1];};};};

// SetPasswordHash sets the password hash to the input.
func (_bdac SheetProtection )SetPasswordHash (pwHash string ){_bdac ._bbaf .PasswordAttr =_a .String (pwHash );};

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_cbcg StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_bbege :=range _cbcg .CellStyles (){if _bbege .HasNumberFormat ()&&_bbege .NumberFormat ()==uint32 (f ){return _bbege ;};};_fecde :=_cbcg .AddCellStyle ();_fecde .SetNumberFormatStandard (f );
return _fecde ;};

// AddBorder creates a new empty Border style.
func (_gefd StyleSheet )AddBorder ()Border {_faeg :=_ee .NewCT_Border ();return Border {_faeg ,_gefd ._dbdd .Borders };};

// GetBorder gets a Border from a cell style.
func (_ebf CellStyle )GetBorder ()*_ee .CT_Border {if _aeda :=_ebf ._beg .BorderIdAttr ;_aeda !=nil {_gde :=_ebf ._eae .StyleSheet .Borders ();if int (*_aeda )< len (_gde ){return _gde [int (*_aeda )].X ();};};return nil ;};

// X returns the inner wrapped XML type.
func (_gdg SheetProtection )X ()*_ee .CT_SheetProtection {return _gdg ._bbaf };

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_ccbdb *Sheet )RecalculateFormulas (){_dfe :=_ffc .NewEvaluator ();_faag :=_ccbdb .FormulaContext ();for _ ,_ddcf :=range _ccbdb .Rows (){for _ ,_cbfg :=range _ddcf .Cells (){if _cbfg .X ().F !=nil {_bdfgb :=_cbfg .X ().F .Content ;if _cbfg .X ().F .TAttr ==_ee .ST_CellFormulaTypeShared &&len (_bdfgb )==0{continue ;
};_acfda :=_dfe .Eval (_faag ,_bdfgb ).AsString ();if _acfda .Type ==_ffc .ResultTypeError {_gb .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_bdfgb ,_acfda .ErrorMessage );
_cbfg .X ().V =nil ;}else {if _acfda .Type ==_ffc .ResultTypeNumber {_cbfg .X ().TAttr =_ee .ST_CellTypeN ;}else {_cbfg .X ().TAttr =_ee .ST_CellTypeInlineStr ;};_cbfg .X ().V =_a .String (_acfda .Value ());if _cbfg .X ().F .TAttr ==_ee .ST_CellFormulaTypeArray {if _acfda .Type ==_ffc .ResultTypeArray {_ccbdb .setArray (_cbfg .Reference (),_acfda );
}else if _acfda .Type ==_ffc .ResultTypeList {_ccbdb .setList (_cbfg .Reference (),_acfda );};}else if _cbfg .X ().F .TAttr ==_ee .ST_CellFormulaTypeShared &&_cbfg .X ().F .RefAttr !=nil {_ccad ,_cbge ,_ffbcg :=_ffb .ParseRangeReference (*_cbfg .X ().F .RefAttr );
if _ffbcg !=nil {_gb .Log .Debug ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_ffbcg );continue ;
};_ccbdb .setShared (_cbfg .Reference (),_ccad ,_cbge ,_bdfgb );};};};};};};

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_agfb *Sheet )Column (idx uint32 )Column {for _ ,_ccbgf :=range _agfb ._bbag .Cols {for _ ,_ggca :=range _ccbgf .Col {if idx >=_ggca .MinAttr &&idx <=_ggca .MaxAttr {return Column {_ggca };};};};var _bffe *_ee .CT_Cols ;if len (_agfb ._bbag .Cols )==0{_bffe =_ee .NewCT_Cols ();
_agfb ._bbag .Cols =append (_agfb ._bbag .Cols ,_bffe );}else {_bffe =_agfb ._bbag .Cols [0];};_dddf :=_ee .NewCT_Col ();_dddf .MinAttr =idx ;_dddf .MaxAttr =idx ;_bffe .Col =append (_bffe .Col ,_dddf );return Column {_dddf };};

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_bcgf *Sheet )AddHyperlink (url string )_bb .Hyperlink {for _aegf ,_efa :=range _bcgf ._edad ._adce {if _efa ==_bcgf ._bbag {return _bcgf ._edad ._bggf [_aegf ].AddHyperlink (url );};};return _bb .Hyperlink {};};const _cbcdd ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";
func (_cefg PatternFill )ClearBgColor (){_cefg ._fegc .BgColor =nil };

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_cceg Cell )GetCachedFormulaResult ()string {if _cceg ._ged .V !=nil {return *_cceg ._ged .V ;};return "";};

// SetPassword sets the password hash to a hash of the input password.
func (_dgcg WorkbookProtection )SetPassword (pw string ){_dgcg .SetPasswordHash (PasswordHash (pw ))};

// Type returns the type of the rule
func (_fee ConditionalFormattingRule )Type ()_ee .ST_CfType {return _fee ._ddg .TypeAttr };func (_bgca *Sheet )updateAfterRemove (_fdca uint32 ,_efbdb _gc .UpdateAction )error {_gcd :=_bgca .Name ();_bgcf :=&_gc .UpdateQuery {UpdateType :_efbdb ,ColumnIdx :_fdca ,SheetToUpdate :_gcd };
for _ ,_bfda :=range _bgca ._edad .Sheets (){_bgcf .UpdateCurrentSheet =_gcd ==_bfda .Name ();for _ ,_ggce :=range _bfda .Rows (){for _ ,_aebf :=range _ggce .Cells (){if _aebf .X ().F !=nil {_bcbed :=_aebf .X ().F .Content ;_eage :=_ffc .ParseString (_bcbed );
if _eage ==nil {_aebf .SetError ("\u0023\u0052\u0045F\u0021");}else {_fedbg :=_eage .Update (_bgcf );_aebf .X ().F .Content =_abb .Sprintf ("\u003d\u0025\u0073",_fedbg .String ());};};};};};return nil ;};

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_defd StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _defd ._dbdd .Dxfs ==nil {_defd ._dbdd .Dxfs =_ee .NewCT_Dxfs ();};_gcaa :=_ee .NewCT_Dxf ();_defd ._dbdd .Dxfs .Dxf =append (_defd ._dbdd .Dxfs .Dxf ,_gcaa );_defd ._dbdd .Dxfs .CountAttr =_a .Uint32 (uint32 (len (_defd ._dbdd .Dxfs .Dxf )));
return DifferentialStyle {_gcaa ,_defd ._ecfba ,_defd ._dbdd .Dxfs };};

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_cebe StyleSheet )Fills ()Fills {return Fills {_cebe ._dbdd .Fills }};func _affb ()*_cce .CT_TwoCellAnchor {_edgg :=_cce .NewCT_TwoCellAnchor ();_edgg .EditAsAttr =_cce .ST_EditAsOneCell ;_edgg .From .Col =5;_edgg .From .Row =0;_edgg .From .ColOff .ST_CoordinateUnqualified =_a .Int64 (0);
_edgg .From .RowOff .ST_CoordinateUnqualified =_a .Int64 (0);_edgg .To .Col =10;_edgg .To .Row =20;_edgg .To .ColOff .ST_CoordinateUnqualified =_a .Int64 (0);_edgg .To .RowOff .ST_CoordinateUnqualified =_a .Int64 (0);return _edgg ;};func (_gcee CellStyle )Index ()uint32 {for _egcb ,_gfg :=range _gcee ._egc .Xf {if _gcee ._beg ==_gfg {return uint32 (_egcb );
};};return 0;};

// SetType sets the type of the rule.
func (_cad ConditionalFormattingRule )SetType (t _ee .ST_CfType ){_cad ._ddg .TypeAttr =t };func (_fgdd Cell )setLocked (_bfdf bool ){_fcd :=_fgdd ._ged .SAttr ;if _fcd !=nil {_deg :=_fgdd ._cfg .StyleSheet .GetCellStyle (*_fcd );if _deg ._beg .Protection ==nil {_deg ._beg .Protection =_ee .NewCT_CellProtection ();
};_deg ._beg .Protection .LockedAttr =&_bfdf ;};};

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_ddfc *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_dddc :=_ee .NewCT_ConditionalFormatting ();_ddfc ._bbag .ConditionalFormatting =append (_ddfc ._bbag .ConditionalFormatting ,_dddc );_gff :=make (_ee .ST_Sqref ,0,0);
_dddc .SqrefAttr =&_gff ;for _ ,_afgbf :=range cellRanges {*_dddc .SqrefAttr =append (*_dddc .SqrefAttr ,_afgbf );};return ConditionalFormatting {_dddc };};

// Tables returns a slice of all defined tables in the workbook.
func (_fefc *Workbook )Tables ()[]Table {if _fefc ._dege ==nil {return nil ;};_gae :=[]Table {};for _ ,_beab :=range _fefc ._dege {_gae =append (_gae ,Table {_beab });};return _gae ;};

// AddGradientStop adds a color gradient stop.
func (_cabbf ColorScale )AddGradientStop (color _cb .Color ){_afg :=_ee .NewCT_Color ();_afg .RgbAttr =color .AsRGBAString ();_cabbf ._fag .Color =append (_cabbf ._fag .Color ,_afg );};

// X returns the inner wrapped XML type.
func (_bcg NumberFormat )X ()*_ee .CT_NumFmt {return _bcg ._addg };func (_bag Cell )clearValue (){_bag ._ged .F =nil ;_bag ._ged .Is =nil ;_bag ._ged .V =nil ;_bag ._ged .TAttr =_ee .ST_CellTypeUnset ;};

// LockSheet controls the locking of the sheet.
func (_dddgf SheetProtection )LockSheet (b bool ){if !b {_dddgf ._bbaf .SheetAttr =nil ;}else {_dddgf ._bbaf .SheetAttr =_a .Bool (true );};};func (_dggg Font )SetItalic (b bool ){_dedd :=false ;for _gec ,_afe :=range _dggg ._eadf .FontChoice {if _afe .I !=nil {if b {_dggg ._eadf .FontChoice [_gec ].I =&_ee .CT_BooleanProperty {};
}else {_dggg ._eadf .FontChoice [_gec ].I =nil ;};_dedd =true ;};};if !_dedd {_dggg ._eadf .FontChoice =append (_dggg ._eadf .FontChoice ,&_ee .CT_FontChoice {I :&_ee .CT_BooleanProperty {}});};};

// SetColOffset sets a column offset in absolute distance.
func (_afb CellMarker )SetColOffset (m _ddde .Distance ){_afb ._fed .ColOff .ST_CoordinateUnqualified =_a .Int64 (int64 (m /_ddde .EMU ));};

// LockWindow controls the locking of the workbook windows.
func (_afbc WorkbookProtection )LockWindow (b bool ){if !b {_afbc ._cafd .LockWindowsAttr =nil ;}else {_afbc ._cafd .LockWindowsAttr =_a .Bool (true );};};

// SetPasswordHash sets the password hash to the input.
func (_egeae WorkbookProtection )SetPasswordHash (pwHash string ){_egeae ._cafd .WorkbookPasswordAttr =_a .String (pwHash );};

// SetFormat sets the number format code.
func (_eece NumberFormat )SetFormat (f string ){_eece ._addg .FormatCodeAttr =f };

// MoveTo moves the top-left of the anchored object.
func (_bbae OneCellAnchor )MoveTo (col ,row int32 ){_bbae .TopLeft ().SetCol (col );_bbae .TopLeft ().SetRow (row );};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_degb *_ee .CT_DefinedName };

// ClearProtection removes any protections applied to teh sheet.
func (_acbb *Sheet )ClearProtection (){_acbb ._bbag .SheetProtection =nil };

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_gaac Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_bbcea :=[]Cell {};for _edfd :=uint32 (0);_edfd <=lastColIdx ;_edfd ++{_edgb :=_gaac .Cell (_ffb .IndexToColumn (_edfd ));_bbcea =append (_bbcea ,_edgb );};return _bbcea ;};func (_edae *Workbook )ensureSharedStringsRelationships (){_ccga :=false ;
for _ ,_edag :=range _edae .ContentTypes .X ().TypesChoice {if _edag .Override !=nil &&_edag .Override .ContentTypeAttr ==_a .SharedStringsContentType {_ccga =true ;break ;};};if !_ccga {_edae .ContentTypes .AddOverride (_bccf ,_a .SharedStringsContentType );
};_agd :=false ;for _ ,_dgb :=range _edae ._afafd .Relationships (){if _dgb .X ().TargetAttr ==_cfaea {_agd =true ;break ;};};if !_agd {_edae ._afafd .AddRelationship (_cfaea ,_a .SharedStringsType );};};func (_gfgd Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _caedg ,_dgdgd ,_gaaa ,_ageb uint32 =1,1,0,0;
for _ ,_bda :=range _gfgd .Rows (){if _bda .RowNumber ()< _caedg {_caedg =_bda .RowNumber ();}else if _bda .RowNumber ()> _dgdgd {_dgdgd =_bda .RowNumber ();};for _ ,_efdd :=range _bda .Cells (){_fadf ,_efcb :=_ffb .ParseCellReference (_efdd .Reference ());
if _efcb ==nil {if _fadf .ColumnIdx < _gaaa {_gaaa =_fadf .ColumnIdx ;}else if _fadf .ColumnIdx > _ageb {_ageb =_fadf .ColumnIdx ;};};};};return _ffb .IndexToColumn (_gaaa ),_caedg ,_ffb .IndexToColumn (_ageb ),_dgdgd ;};

// SetStyle sets the cell style for an entire column.
func (_dea Column )SetStyle (cs CellStyle ){_dea ._ace .StyleAttr =_a .Uint32 (cs .Index ())};

// Clear clears the cell's value and type.
func (_eaa Cell )Clear (){_eaa .clearValue ();_eaa ._ged .TAttr =_ee .ST_CellTypeUnset };

// SetProtectedAndHidden sets protected and hidden for given cellStyle
func (_abba CellStyle )SetProtection (protected bool ,hidden bool ){_abba ._beg .Protection =&_ee .CT_CellProtection {LockedAttr :&protected ,HiddenAttr :&hidden };};

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_ecfa *Workbook )AddDrawing ()Drawing {_addef :=_cce .NewWsDr ();_ecfa ._cefb =append (_ecfa ._cefb ,_addef );_bggc :=_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .DrawingType ,len (_ecfa ._cefb ));_ecfa .ContentTypes .AddOverride (_bggc ,_a .DrawingContentType );
_ecfa ._dffd =append (_ecfa ._dffd ,_bb .NewRelationships ());return Drawing {_ecfa ,_addef };};

// X returns the inner wrapped XML type.
func (_gbgc Column )X ()*_ee .CT_Col {return _gbgc ._ace };

// Fonts returns the list of fonts defined in the stylesheet.
func (_acbbef StyleSheet )Fonts ()[]Font {_fadc :=[]Font {};for _ ,_gfff :=range _acbbef ._dbdd .Fonts .Font {_fadc =append (_fadc ,Font {_gfff ,_acbbef ._dbdd });};return _fadc ;};func (_cgcd DataValidationCompare )SetValue2 (v string ){_cgcd ._edg .Formula2 =&v };


// SetConditionValue sets the condition value to be used for style applicaton.
func (_afge ConditionalFormattingRule )SetConditionValue (v string ){_afge ._ddg .Formula =[]string {v }};func (_gbgca Font )Index ()uint32 {for _aeg ,_bacc :=range _gbgca ._dcac .Fonts .Font {if _gbgca ._eadf ==_bacc {return uint32 (_aeg );};};return 0;
};

// ClearBorder clears any border configuration from the cell style.
func (_eed CellStyle )ClearBorder (){_eed ._beg .BorderIdAttr =nil ;_eed ._beg .ApplyBorderAttr =nil };

// SetFont sets the font name for a rich text run.
func (_dbbbg RichTextRun )SetFont (s string ){_dbbbg .ensureRpr ();for _ ,_aefg :=range _dbbbg ._caeb .RPr .RPrEltChoice {if _aefg .RFont !=nil {_aefg .RFont .ValAttr =s ;return ;};};_dbbbg ._caeb .RPr .RPrEltChoice =append (_dbbbg ._caeb .RPr .RPrEltChoice ,&_ee .CT_RPrEltChoice {RFont :&_ee .CT_FontName {ValAttr :s }});
};

// X returns the inner wrapped XML type.
func (_fegf IconScale )X ()*_ee .CT_IconSet {return _fegf ._bccd };

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_ec Cell )Reference ()string {if _ec ._ged .RAttr !=nil {return *_ec ._ged .RAttr ;};return "";};

// GetVerticalAlignment sets the vertical alignment of a cell style.
func (_cgg CellStyle )GetVerticalAlignment ()_ee .ST_VerticalAlignment {if _cgg ._beg .Alignment ==nil {return _ee .ST_VerticalAlignmentUnset ;};return _cgg ._beg .Alignment .VerticalAttr ;};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_acb Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _fedb ,_feg Cell ;for _ ,_adb :=range lhs .Cells (){_dbbf ,_ :=_ffb .ParseCellReference (_adb .Reference ());if _dbbf .Column ==column {_fedb =_adb ;break ;};};for _ ,_cdb :=range rhs .Cells (){_baa ,_ :=_ffb .ParseCellReference (_cdb .Reference ());
if _baa .Column ==column {_feg =_cdb ;break ;};};return _acb .LessCells (_fedb ,_feg );};

// SetHeight sets the height of the anchored object.
func (_acba OneCellAnchor )SetHeight (h _ddde .Distance ){_acba ._adf .Ext .CyAttr =int64 (h /_ddde .EMU )};const (DVOpGreater =_ee .ST_DataValidationOperatorGreaterThanOrEqual ;);func (_gecc Font )SetColor (c _cb .Color ){_dfbf :=_ee .NewCT_Color ();_abe :="\u0066\u0066"+*c .AsRGBString ();
_dfbf .RgbAttr =&_abe ;_fcge :=false ;for _dfab ,_eaeg :=range _gecc ._eadf .FontChoice {if _eaeg .Color !=nil {_gecc ._eadf .FontChoice [_dfab ].Color =_dfbf ;_fcge =true ;};};if !_fcge {_gecc ._eadf .FontChoice =append (_gecc ._eadf .FontChoice ,&_ee .CT_FontChoice {Color :_dfbf });
};};

// SetContent sets the defined name content.
func (_ddc DefinedName )SetContent (s string ){_ddc ._degb .Content =s };

// StyleSheet is a document style sheet.
type StyleSheet struct{_ecfba *Workbook ;_dbdd *_ee .StyleSheet ;};

// SetInlineString adds a string inline instead of in the shared strings table.
func (_abd Cell )SetInlineString (s string ){_abd .clearValue ();_abd ._ged .Is =_ee .NewCT_Rst ();_abd ._ged .Is .T =_a .String (s );_abd ._ged .TAttr =_ee .ST_CellTypeInlineStr ;};func (_fgad ConditionalFormattingRule )clear (){_fgad ._ddg .OperatorAttr =_ee .ST_ConditionalFormattingOperatorUnset ;
_fgad ._ddg .ColorScale =nil ;_fgad ._ddg .IconSet =nil ;_fgad ._ddg .Formula =nil ;};const _ddbef ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";func (_gaacg *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _gaacg .getAllCellsInFormulaArrays (false );
};

// ClearAutoFilter removes the autofilters from the sheet.
func (_ffec *Sheet )ClearAutoFilter (){_ffec ._bbag .AutoFilter =nil ;_cddd :="\u0027"+_ffec .Name ()+"\u0027\u0021";for _ ,_bdcc :=range _ffec ._edad .DefinedNames (){if _bdcc .Name ()==_ddbef {if _e .HasPrefix (_bdcc .Content (),_cddd ){_ffec ._edad .RemoveDefinedName (_bdcc );
break ;};};};};

// SetXSplit sets the column split point
func (_aceb SheetView )SetXSplit (v float64 ){_aceb .ensurePane ();_aceb ._ceda .Pane .XSplitAttr =_a .Float64 (v );};

// SheetCount returns the number of sheets in the workbook.
func (_ffab Workbook )SheetCount ()int {return len (_ffab ._adce )};const (StandardFormatGeneral StandardFormat =0;StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;
StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;
StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;
StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;
StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;
);

// SetDateWithStyle sets a date with the default date style applied.
func (_facc Cell )SetDateWithStyle (d _cd .Time ){_facc .SetDate (d );for _ ,_def :=range _facc ._cfg .StyleSheet .CellStyles (){if _def .HasNumberFormat ()&&_def .NumberFormat ()==uint32 (StandardFormatDate ){_facc .SetStyle (_def );return ;};};_aacf :=_facc ._cfg .StyleSheet .AddCellStyle ();
_aacf .SetNumberFormatStandard (StandardFormatDate );_facc .SetStyle (_aacf );};

// SetShowRuler controls the visibility of the ruler
func (_acag SheetView )SetShowRuler (b bool ){if !b {_acag ._ceda .ShowRulerAttr =_a .Bool (false );}else {_acag ._ceda .ShowRulerAttr =nil ;};};

// ExtractText returns text from the workbook as a WorkbookText object.
func (_ceg *Workbook )ExtractText ()*WorkbookText {_cecb :=[]*SheetText {};for _ ,_gfedc :=range _ceg .Sheets (){_cecb =append (_cecb ,&SheetText {Cells :_gfedc .ExtractText ().Cells });};return &WorkbookText {Sheets :_cecb };};

// Text returns text from the workbook as one string separated with line breaks.
func (_aaba *WorkbookText )Text ()string {_cdef :=_dd .NewBuffer ([]byte {});for _ ,_ecae :=range _aaba .Sheets {_cdef .WriteString (_ecae .Text ());};return _cdef .String ();};

// GetFormula returns the formula for a cell.
func (_cefc Cell )GetFormula ()string {if _cefc ._ged .F !=nil {return _cefc ._ged .F .Content ;};return "";};

// MergedCells returns the merged cell regions within the sheet.
func (_cddc *Sheet )MergedCells ()[]MergedCell {if _cddc ._bbag .MergeCells ==nil {return nil ;};_defgb :=[]MergedCell {};for _ ,_dcab :=range _cddc ._bbag .MergeCells .MergeCell {_defgb =append (_defgb ,MergedCell {_cddc ._edad ,_cddc ,_dcab });};return _defgb ;
};

// SetPassword sets the password hash to a hash of the input password.
func (_eeec SheetProtection )SetPassword (pw string ){_eeec .SetPasswordHash (PasswordHash (pw ))};

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_eef AbsoluteAnchor )SetColOffset (m _ddde .Distance ){_eef ._gg .Pos .XAttr .ST_CoordinateUnqualified =_a .Int64 (int64 (m /_ddde .EMU ));};

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_ebeg :=_ee .NewStyleSheet ();_ebeg .CellStyleXfs =_ee .NewCT_CellStyleXfs ();_ebeg .CellXfs =_ee .NewCT_CellXfs ();_ebeg .CellStyles =_ee .NewCT_CellStyles ();_dafc :=_ee .NewCT_CellStyle ();_dafc .NameAttr =_a .String ("\u004e\u006f\u0072\u006d\u0061\u006c");
_dafc .XfIdAttr =0;_dafc .BuiltinIdAttr =_a .Uint32 (0);_ebeg .CellStyles .CellStyle =append (_ebeg .CellStyles .CellStyle ,_dafc );_ebeg .CellStyles .CountAttr =_a .Uint32 (uint32 (len (_ebeg .CellStyles .CellStyle )));_fgcf :=_ee .NewCT_Xf ();_fgcf .NumFmtIdAttr =_a .Uint32 (0);
_fgcf .FontIdAttr =_a .Uint32 (0);_fgcf .FillIdAttr =_a .Uint32 (0);_fgcf .BorderIdAttr =_a .Uint32 (0);_ebeg .CellStyleXfs .Xf =append (_ebeg .CellStyleXfs .Xf ,_fgcf );_ebeg .CellStyleXfs .CountAttr =_a .Uint32 (uint32 (len (_ebeg .CellStyleXfs .Xf )));
_afba :=NewFills ();_ebeg .Fills =_afba .X ();_dfaa :=_afba .appendFill ().SetPatternFill ();_dfaa .SetPattern (_ee .ST_PatternTypeNone );_dfaa =_afba .appendFill ().SetPatternFill ();_dfaa .SetPattern (_ee .ST_PatternTypeGray125 );_ebeg .Fonts =_ee .NewCT_Fonts ();
_ebeg .Borders =_ee .NewCT_Borders ();_bdfga :=StyleSheet {wb ,_ebeg };_bdfga .appendBorder ().InitializeDefaults ();_ffcg :=_bdfga .appendFont ();_ffcg .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_ffcg .SetSize (11);_befed :=_ee .NewCT_Xf ();*_befed =*_fgcf ;
_befed .XfIdAttr =_a .Uint32 (0);_ebeg .CellXfs .Xf =append (_ebeg .CellXfs .Xf ,_befed );_ebeg .CellXfs .CountAttr =_a .Uint32 (uint32 (len (_ebeg .CellXfs .Xf )));return _bdfga ;};

// Reference returns the table reference (the cells within the table)
func (_cbfd Table )Reference ()string {return _cbfd ._gbba .RefAttr };

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_bfa *Sheet )RemoveColumn (column string )error {_fbeg ,_ebgb :=_bfa .getAllCellsInFormulaArraysForColumn ();if _ebgb !=nil {return _ebgb ;};_fca :=_ffb .ColumnToIndex (column );for _ ,_cba :=range _bfa .Rows (){_eagb :=_abb .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_cba .X ().RAttr );
if _ ,_afadd :=_fbeg [_eagb ];_afadd {return nil ;};};for _ ,_bdcd :=range _bfa .Rows (){_febe :=_bdcd ._abbe .C ;for _abeg ,_abege :=range _febe {_bfb ,_gdad :=_ffb .ParseCellReference (*_abege .RAttr );if _gdad !=nil {return _gdad ;};if _bfb .ColumnIdx ==_fca {_bdcd ._abbe .C =append (_febe [:_abeg ],_bfa .slideCellsLeft (_febe [_abeg +1:])...);
break ;}else if _bfb .ColumnIdx > _fca {_bdcd ._abbe .C =append (_febe [:_abeg ],_bfa .slideCellsLeft (_febe [_abeg :])...);break ;};};};_ebgb =_bfa .updateAfterRemove (_fca ,_gc .UpdateActionRemoveColumn );if _ebgb !=nil {return _ebgb ;};_ebgb =_bfa .removeColumnFromNamedRanges (_fca );
if _ebgb !=nil {return _ebgb ;};_ebgb =_bfa .removeColumnFromMergedCells (_fca );if _ebgb !=nil {return _ebgb ;};for _ ,_egbb :=range _bfa ._edad .Sheets (){_egbb .RecalculateFormulas ();};return nil ;};

// X returns the inner wrapped XML type.
func (_bcbe MergedCell )X ()*_ee .CT_MergeCell {return _bcbe ._bcfc };

// Reference returns the region of cells that are merged.
func (_gdcc MergedCell )Reference ()string {return _gdcc ._bcfc .RefAttr };func (_bbfc Font )SetSize (size float64 ){_fdfa :=false ;for _ccd ,_eace :=range _bbfc ._eadf .FontChoice {if _eace .Sz !=nil {_bbfc ._eadf .FontChoice [_ccd ].Sz =&_ee .CT_FontSize {ValAttr :size };
_fdfa =true ;};};if !_fdfa {_bbfc ._eadf .FontChoice =append (_bbfc ._eadf .FontChoice ,&_ee .CT_FontChoice {Sz :&_ee .CT_FontSize {ValAttr :size }});};};

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_bbcb *Workbook )Epoch ()_cd .Time {if _bbcb .Uses1904Dates (){_cd .Date (1904,1,1,0,0,0,0,_cd .UTC );};return _cd .Date (1899,12,30,0,0,0,0,_cd .UTC );};

// Content returns the content of the defined range (the range in most cases)/
func (_gcb DefinedName )Content ()string {return _gcb ._degb .Content };

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_fceg *Sheet )FormulaContext ()_ffc .Context {return _gdb (_fceg )};

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_gd Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_gd .SetNumber (v );_gd .SetStyle (_gd ._cfg .StyleSheet .GetOrCreateStandardNumberFormat (f ));};func (_bbfgf *Sheet )setList (_agag string ,_ddad _ffc .Result )error {_faaea ,_eaddf :=_ffb .ParseCellReference (_agag );
if _eaddf !=nil {return _eaddf ;};_afaf :=_bbfgf .Row (_faaea .RowIdx );for _edda ,_dcff :=range _ddad .ValueList {_abbaf :=_afaf .Cell (_ffb .IndexToColumn (_faaea .ColumnIdx +uint32 (_edda )));if _dcff .Type !=_ffc .ResultTypeEmpty {if _dcff .IsBoolean {_abbaf .SetBool (_dcff .ValueNumber !=0);
}else {_abbaf .SetCachedFormulaResult (_dcff .String ());};};};return nil ;};func (_dcdd CellStyle )SetShrinkToFit (b bool ){if _dcdd ._beg .Alignment ==nil {_dcdd ._beg .Alignment =_ee .NewCT_CellAlignment ();};_dcdd ._beg .ApplyAlignmentAttr =_a .Bool (true );
if !b {_dcdd ._beg .Alignment .ShrinkToFitAttr =nil ;}else {_dcdd ._beg .Alignment .ShrinkToFitAttr =_a .Bool (b );};};

// SetName sets the sheet name.
func (_eecee *Sheet )SetName (name string ){_eecee ._aefa .NameAttr =name };

// SetHeight sets the height of the anchored object.
func (_ca AbsoluteAnchor )SetHeight (h _ddde .Distance ){_ca ._gg .Ext .CyAttr =int64 (h /_ddde .EMU )};func (_dfc Border )SetLeft (style _ee .ST_BorderStyle ,c _cb .Color ){if _dfc ._cde .Left ==nil {_dfc ._cde .Left =_ee .NewCT_BorderPr ();};_dfc ._cde .Left .Color =_ee .NewCT_Color ();
_dfc ._cde .Left .Color .RgbAttr =c .AsRGBAString ();_dfc ._cde .Left .StyleAttr =style ;};

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_egf ConditionalFormattingRule )SetDataBar ()DataBarScale {_egf .clear ();_egf .SetType (_ee .ST_CfTypeDataBar );_egf ._ddg .DataBar =_ee .NewCT_DataBar ();_fgade :=DataBarScale {_egf ._ddg .DataBar };_fgade .SetShowValue (true );_fgade .SetMinLength (10);
_fgade .SetMaxLength (90);return _fgade ;};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_afdfb *Sheet )ClearCachedFormulaResults (){for _ ,_gegf :=range _afdfb .Rows (){for _ ,_dgae :=range _gegf .Cells (){if _dgae .X ().F !=nil {_dgae .X ().V =nil ;};};};};

// Text returns text from the sheet as one string separated with line breaks.
func (_cege *SheetText )Text ()string {_bgce :=_dd .NewBuffer ([]byte {});for _ ,_fecb :=range _cege .Cells {if _fecb .Text !=""{_bgce .WriteString (_fecb .Text );_bgce .WriteString ("\u000a");};};return _bgce .String ();};

// Index returns the index of the border for use with a cell style.
func (_ccc Border )Index ()uint32 {for _af ,_fd :=range _ccc ._cf .Border {if _fd ==_ccc ._cde {return uint32 (_af );};};return 0;};

// X returns the inner wrapped XML type.
func (_edd Border )X ()*_ee .CT_Border {return _edd ._cde };func (_dbgd SheetView )ensurePane (){if _dbgd ._ceda .Pane ==nil {_dbgd ._ceda .Pane =_ee .NewCT_Pane ();_dbgd ._ceda .Pane .ActivePaneAttr =_ee .ST_PaneBottomLeft ;};};

// ClearProtection clears all workbook protections.
func (_gegd *Workbook )ClearProtection (){_gegd ._bcbedf .WorkbookProtection =nil };

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_cefca Row )Cell (col string )Cell {_bada :=_abb .Sprintf ("\u0025\u0073\u0025\u0064",col ,_cefca .RowNumber ());for _ ,_gaacc :=range _cefca ._abbe .C {if _gaacc .RAttr !=nil &&*_gaacc .RAttr ==_bada {return Cell {_cefca ._gbgf ,_cefca ._baec ,_cefca ._abbe ,_gaacc };
};};return _cefca .AddNamedCell (col );};

// Type returns the type of anchor
func (_dddb TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_gfac TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_gfac ._dedde .To }};

// SetLocked sets cell locked or not.
func (_dba *evalContext )SetLocked (cellRef string ,locked bool ){_dba ._abf .Cell (cellRef ).setLocked (locked );};

// IsEmpty returns true if the cell is empty.
func (_beb Cell )IsEmpty ()bool {return _beb ._ged .TAttr ==_ee .ST_CellTypeUnset &&_beb ._ged .V ==nil &&_beb ._ged .F ==nil ;};

// SetWidth sets the width of the anchored object.
func (_faa AbsoluteAnchor )SetWidth (w _ddde .Distance ){_faa ._gg .Ext .CxAttr =int64 (w /_ddde .EMU )};