//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_f "encoding/hex";_d "errors";_e "fmt";_ec "github.com/unidoc/unioffice/common/tempstorage";_bd "io";_c "io/ioutil";_af "math/rand";_a "sync";);

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_ff *memFile )Write (p []byte )(int ,error ){_ff ._ed ._fa =append (_ff ._ed ._fa ,p ...);_ff ._ed ._eaf +=int64 (len (p ));return len (p ),nil ;};

// Name returns the filename of the underlying memDataCell
func (_ac *memFile )Name ()string {return _ac ._ed ._dc };

// TempDir creates a name for a new temp directory using a pattern argument
func (_ca *memStorage )TempDir (pattern string )(string ,error ){return _bda (pattern ),nil };

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_eg *memFile )Read (p []byte )(int ,error ){_cd :=_eg ._cb ;_ag :=_eg ._ed ._eaf ;_ce :=int64 (len (p ));if _ce > _ag {_ce =_ag ;p =p [:_ce ];};if _cd >=_ag {return 0,_bd .EOF ;};_g :=_cd +_ce ;if _g >=_ag {_g =_ag ;};_ea :=copy (p ,_eg ._ed ._fa [_cd :_g ]);
_eg ._cb =_g ;return _ea ,nil ;};func _bda (_ccc string )string {_eb ,_ :=_bdea (6);return _ccc +_eb };

// RemoveAll removes all files according to the dir argument prefix
func (_bde *memStorage )RemoveAll (dir string )error {_bde ._aba .Range (func (_fc ,_ef interface{})bool {_bde ._aba .Delete (_fc );return true });return nil ;};func _bdea (_bbb int )(string ,error ){_ege :=make ([]byte ,_bbb );if _ ,_da :=_af .Read (_ege );
_da !=nil {return "",_da ;};return _f .EncodeToString (_ege ),nil ;};type memFile struct{_ed *memDataCell ;_cb int64 ;};

// TempFile creates a new empty file in the storage and returns it
func (_bee *memStorage )TempFile (dir ,pattern string )(_ec .File ,error ){_fd :=dir +"\u002f"+_bda (pattern );_ffa :=&memDataCell {_dc :_fd ,_fa :[]byte {}};_bc :=&memFile {_ed :_ffa };_bee ._aba .Store (_fd ,_ffa );return _bc ,nil ;};type memStorage struct{_aba _a .Map };


// Add reads a file from a disk and adds it to the storage
func (_ece *memStorage )Add (path string )error {_ ,_fb :=_ece ._aba .Load (path );if _fb {return nil ;};_bb ,_agc :=_c .ReadFile (path );if _agc !=nil {return _agc ;};_ece ._aba .Store (path ,&memDataCell {_dc :path ,_fa :_bb ,_eaf :int64 (len (_bb ))});
return nil ;};

// Open returns tempstorage File object by name
func (_gb *memStorage )Open (path string )(_ec .File ,error ){_cc ,_cg :=_gb ._aba .Load (path );if !_cg {return nil ,_d .New (_e .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));
};return &memFile {_ed :_cc .(*memDataCell )},nil ;};

// ReadAt reads from the underlying memDataCell at an offset provided in order to implement ReaderAt interface.
// It does not affect f.readOffset.
func (_ab *memFile )ReadAt (p []byte ,readOffset int64 )(int ,error ){_be :=_ab ._ed ._eaf ;_ge :=int64 (len (p ));if _ge > _be {_ge =_be ;p =p [:_ge ];};if readOffset >=_be {return 0,_bd .EOF ;};_ad :=readOffset +_ge ;if _ad >=_be {_ad =_be ;};_adb :=copy (p ,_ab ._ed ._fa [readOffset :_ad ]);
return _adb ,nil ;};

// Close is not applicable in this implementation
func (_ga *memFile )Close ()error {return nil };

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_afc :=memStorage {_aba :_a .Map {}};_ec .SetAsStorage (&_afc )};type memDataCell struct{_dc string ;_fa []byte ;_eaf int64 ;};