//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_be "encoding/hex";_ea "errors";_b "fmt";_ed "github.com/unidoc/unioffice/v2/common/tempstorage";_eg "io";_eb "io/ioutil";_f "math/rand";_d "sync";);

// Add reads a file from a disk and adds it to the storage
func (_fg *memStorage )Add (path string )error {_ ,_gbg :=_fg ._egc .Load (path );if _gbg {return nil ;};_bdg ,_fga :=_eb .ReadFile (path );if _fga !=nil {return _fga ;};_fg ._egc .Store (path ,&memDataCell {_ag :path ,_bd :_bdg ,_ae :int64 (len (_bdg ))});
return nil ;};type memFile struct{_a *memDataCell ;_c int64 ;};

// Name returns the filename of the underlying memDataCell
func (_ff *memFile )Name ()string {return _ff ._a ._ag };

// TempFile creates a new empty file in the storage and returns it
func (_dff *memStorage )TempFile (dir ,pattern string )(_ed .File ,error ){_da :=dir +"\u002f"+_dbb (pattern );_aa :=&memDataCell {_ag :_da ,_bd :[]byte {}};_ac :=&memFile {_a :_aa };_dff ._egc .Store (_da ,_aa );return _ac ,nil ;};func _eee (_gca int )(string ,error ){_ddfa :=make ([]byte ,_gca );
if _ ,_edb :=_f .Read (_ddfa );_edb !=nil {return "",_edb ;};return _be .EncodeToString (_ddfa ),nil ;};

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_gb :=memStorage {_egc :_d .Map {}};_ed .SetAsStorage (&_gb )};func _dbb (_dd string )string {_ddf ,_ :=_eee (6);return _dd +_ddf };type memDataCell struct{_ag string ;_bd []byte ;_ae int64 ;};

// TempDir creates a name for a new temp directory using a pattern argument
func (_bdc *memStorage )TempDir (pattern string )(string ,error ){return _dbb (pattern ),nil };

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_g *memFile )Read (p []byte )(int ,error ){_ab :=_g ._c ;_df :=_g ._a ._ae ;_gf :=int64 (len (p ));if _gf > _df {_gf =_df ;p =p [:_gf ];};if _ab >=_df {return 0,_eg .EOF ;};_bb :=_ab +_gf ;if _bb >=_df {_bb =_df ;};_gff :=copy (p ,_g ._a ._bd [_ab :_bb ]);
_g ._c =_bb ;return _gff ,nil ;};type memStorage struct{_egc _d .Map };

// Open returns tempstorage File object by name
func (_aec *memStorage )Open (path string )(_ed .File ,error ){_gd ,_bc :=_aec ._egc .Load (path );if !_bc {return nil ,_ea .New (_b .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));
};return &memFile {_a :_gd .(*memDataCell )},nil ;};

// RemoveAll removes all files according to the dir argument prefix
func (_ca *memStorage )RemoveAll (dir string )error {_ca ._egc .Range (func (_aee ,_eac interface{})bool {_ca ._egc .Delete (_aee );return true });return nil ;};

// ReadAt reads from the underlying memDataCell at an offset provided in order to implement ReaderAt interface.
// It does not affect f.readOffset.
func (_dfe *memFile )ReadAt (p []byte ,readOffset int64 )(int ,error ){_fa :=_dfe ._a ._ae ;_gc :=int64 (len (p ));if _gc > _fa {_gc =_fa ;p =p [:_gc ];};if readOffset >=_fa {return 0,_eg .EOF ;};_egd :=readOffset +_gc ;if _egd >=_fa {_egd =_fa ;};_ee :=copy (p ,_dfe ._a ._bd [readOffset :_egd ]);
return _ee ,nil ;};

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_bf *memFile )Write (p []byte )(int ,error ){_bf ._a ._bd =append (_bf ._a ._bd ,p ...);_bf ._a ._ae +=int64 (len (p ));return len (p ),nil ;};

// Close is not applicable in this implementation
func (_abb *memFile )Close ()error {return nil };