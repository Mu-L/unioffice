//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_f "encoding/hex";_cb "errors";_g "fmt";_dd "github.com/unidoc/unioffice/common/tempstorage";_e "io";_d "io/ioutil";_c "math/rand";_a "sync";);type memStorage struct{_ea _a .Map };type memFile struct{_be *memDataCell ;_ce int64 ;
};

// RemoveAll removes all files according to the dir argument prefix
func (_ff *memStorage )RemoveAll (dir string )error {_ff ._ea .Range (func (_dbd ,_cbe interface{})bool {_ff ._ea .Delete (_dbd );return true });return nil ;};

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_cf :=memStorage {_ea :_a .Map {}};_dd .SetAsStorage (&_cf )};

// TempDir creates a name for a new temp directory using a pattern argument
func (_cfb *memStorage )TempDir (pattern string )(string ,error ){return _ga (pattern ),nil };

// Name returns the filename of the underlying memDataCell
func (_beb *memFile )Name ()string {return _beb ._be ._af };func _ga (_ae string )string {_afd ,_ :=_fbf (6);return _ae +_afd };

// ReadAt reads from the underlying memDataCell at an offset provided in order to implement ReaderAt interface.
// It does not affect f.readOffset.
func (_cbc *memFile )ReadAt (p []byte ,readOffset int64 )(int ,error ){_gf :=_cbc ._be ._ec ;_dc :=int64 (len (p ));if _dc > _gf {_dc =_gf ;p =p [:_dc ];};if readOffset >=_gf {return 0,_e .EOF ;};_dcd :=readOffset +_dc ;if _dcd >=_gf {_dcd =_gf ;};_fe :=copy (p ,_cbc ._be ._ba [readOffset :_dcd ]);
return _fe ,nil ;};

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_ega *memFile )Write (p []byte )(int ,error ){_ega ._be ._ba =append (_ega ._be ._ba ,p ...);_ega ._be ._ec +=int64 (len (p ));return len (p ),nil ;};func _fbf (_bac int )(string ,error ){_ddc :=make ([]byte ,_bac );if _ ,_eee :=_c .Read (_ddc );
_eee !=nil {return "",_eee ;};return _f .EncodeToString (_ddc ),nil ;};

// Open returns tempstorage File object by name
func (_feg *memStorage )Open (path string )(_dd .File ,error ){_ac ,_bc :=_feg ._ea .Load (path );if !_bc {return nil ,_cb .New (_g .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));
};return &memFile {_be :_ac .(*memDataCell )},nil ;};type memDataCell struct{_af string ;_ba []byte ;_ec int64 ;};

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_cba *memFile )Read (p []byte )(int ,error ){_fb :=_cba ._ce ;_cbb :=_cba ._be ._ec ;_eg :=int64 (len (p ));if _eg > _cbb {_eg =_cbb ;p =p [:_eg ];};if _fb >=_cbb {return 0,_e .EOF ;};_df :=_fb +_eg ;if _df >=_cbb {_df =_cbb ;};_dg :=copy (p ,_cba ._be ._ba [_fb :_df ]);
_cba ._ce =_df ;return _dg ,nil ;};

// Add reads a file from a disk and adds it to the storage
func (_bab *memStorage )Add (path string )error {_ ,_eaf :=_bab ._ea .Load (path );if _eaf {return nil ;};_gg ,_de :=_d .ReadFile (path );if _de !=nil {return _de ;};_bab ._ea .Store (path ,&memDataCell {_af :path ,_ba :_gg ,_ec :int64 (len (_gg ))});return nil ;
};

// TempFile creates a new empty file in the storage and returns it
func (_ee *memStorage )TempFile (dir ,pattern string )(_dd .File ,error ){_dgf :=dir +"\u002f"+_ga (pattern );_dce :=&memDataCell {_af :_dgf ,_ba :[]byte {}};_ad :=&memFile {_be :_dce };_ee ._ea .Store (_dgf ,_dce );return _ad ,nil ;};

// Close is not applicable in this implementation
func (_db *memFile )Close ()error {return nil };