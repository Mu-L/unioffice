//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_a "archive/zip";_acf "bytes";_bf "encoding/xml";_ac "fmt";_db "github.com/unidoc/unioffice/v2";_bd "github.com/unidoc/unioffice/v2/common/tempstorage";_e "github.com/unidoc/unioffice/v2/internal/sort";_d "github.com/unidoc/unioffice/v2/schema/soo/pkg/relationships";
_ad "io";_bcg "path";_g "sort";_bfg "strings";_bc "time";);

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_c *DecodeMap ,_gg ,_bcf string ,_ga []*_a .File ,_gf *_d .Relationship ,_df Target )error ;const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";
type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};func MarshalXMLByTypeIndex (z *_a .Writer ,dt _db .DocType ,typ string ,idx int ,v interface{})error {_eb :=_db .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_eb ,v );
};

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_a .File ,path string )(string ,error ){_ege ,_eaa :=_bd .TempFile (path ,"\u007a\u007a");if _eaa !=nil {return "",_eaa ;};defer _ege .Close ();_fbg ,_eaa :=f .Open ();if _eaa !=nil {return "",_eaa ;};defer _fbg .Close ();_ ,_eaa =_ad .Copy (_ege ,_fbg );
if _eaa !=nil {return "",_eaa ;};return _ege .Name (),nil ;};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_a .Writer ,filename string ,v interface{})error {_eff :=&_a .FileHeader {};_eff .Method =_a .Deflate ;_eff .Name =filename ;_eff .SetModTime (_bc .Now ());_gce ,_cb :=z .CreateHeader (_eff );if _cb !=nil {return _ac .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_cb );
};_ ,_cb =_gce .Write ([]byte (XMLHeader ));if _cb !=nil {return _ac .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_cb );
};if _cb =_bf .NewEncoder (SelfClosingWriter {_gce }).Encode (v );_cb !=nil {return _ac .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_cb );};_ ,_cb =_gce .Write (_aca );return _cb ;
};var _aag =[]byte {'/','>'};

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_a .Writer ,zipPath string ,data []byte )error {_dgb ,_cc :=z .Create (zipPath );if _cc !=nil {return _ac .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_cc );
};_ ,_cc =_ad .Copy (_dgb ,_acf .NewReader (data ));return _cc ;};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_fdff :=_bfg .Split (path ,"\u002f");_ca :=_bfg .Join (_fdff [0:len (_fdff )-1],"\u002f");_fb :=_fdff [len (_fdff )-1];_ca +="\u002f_\u0072\u0065\u006c\u0073\u002f";_fb +="\u002e\u0072\u0065l\u0073";return _ca +_fb ;
};func MarshalXMLByType (z *_a .Writer ,dt _db .DocType ,typ string ,v interface{})error {_dgc :=_db .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_dgc ,v );};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _ad .Writer ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_ef *DecodeMap )Decode (files []*_a .File )error {_ge :=1;for _ge > 0{for len (_ef ._gc )> 0{_ce :=_ef ._gc [0];_ef ._gc =_ef ._gc [1:];_ec :=_ce .Ifc .(*_d .Relationships );for _ ,_cg :=range _ec .Relationship {_ab :=_ef ._ee [_ec ];_aa :=_bfg .TrimPrefix (_cg .TargetAttr ,"\u002f");
if _bfg .HasPrefix (_cg .TargetAttr ,"\u002f"){_ =_ef ._be (_ef ,_aa ,_cg .TypeAttr ,files ,_cg ,_ce );}else {if _bfg .IndexByte (_ab ,'/')> -1{_dc :=_ab [:_bfg .IndexByte (_ab ,'/')+1];if _bfg .HasPrefix (_aa ,_dc ){_ab ="";};};if _bfg .HasPrefix (_aa ,_ab ){_ab ="";
};_ =_ef ._be (_ef ,_ab +_aa ,_cg .TypeAttr ,files ,_cg ,_ce );};};};for _fec ,_eef :=range files {if _eef ==nil {continue ;};if _dff ,_eee :=_ef ._f [_eef .Name ];_eee {delete (_ef ._f ,_eef .Name );if _ag :=Decode (_eef ,_dff .Ifc );_ag !=nil {return _ag ;
};files [_fec ]=nil ;if _da ,_efc :=_dff .Ifc .(*_d .Relationships );_efc {_ef ._gc =append (_ef ._gc ,_dff );_fcg ,_ :=_bcg .Split (_bcg .Clean (_eef .Name +"\u002f\u002e\u002e\u002f"));_ef ._ee [_da ]=_fcg ;_ge ++;};};};_ge --;};return nil ;};func (_fe *DecodeMap )RecordIndex (path string ,idx int ){_fe ._fa [path ]=idx };
var _aca =[]byte {'\r','\n'};func (_ff *DecodeMap )IndexFor (path string )int {return _ff ._fa [path ]};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_dg *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_dg ._be =fn };

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_fda *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _fda ._f ==nil {_fda ._f =make (map[string ]Target );_fda ._ee =make (map[*_d .Relationships ]string );_fda ._fd =make (map[string ]struct{});
_fda ._fa =make (map[string ]int );};if _bcg .IsAbs (filePath ){filePath =_bfg .TrimPrefix (filePath ,"\u002f");};_fc :=_bcg .Clean (filePath );if _ ,_beb :=_fda ._fd [_fc ];_beb {return false ;};_fda ._fd [_fc ]=struct{}{};_fda ._f [_fc ]=Target {Path :_fc ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };
return true ;};func (_dga SelfClosingWriter )Write (b []byte )(int ,error ){_ffg :=0;_adc :=0;for _ffc :=0;_ffc < len (b )-2;_ffc ++{if b [_ffc ]=='>'&&b [_ffc +1]=='<'&&b [_ffc +2]=='/'{_aad :=[]byte {};_bfe :=_ffc ;for _ebd :=_ffc ;_ebd >=0;_ebd --{if b [_ebd ]==' '{_bfe =_ebd ;
}else if b [_ebd ]=='<'{_aad =b [_ebd +1:_bfe ];break ;};};_gfa :=[]byte {};for _fgcf :=_ffc +3;_fgcf < len (b );_fgcf ++{if b [_fgcf ]=='>'{_gfa =b [_ffc +3:_fgcf ];break ;};};if !_acf .Equal (_aad ,_gfa ){continue ;};_bg ,_gge :=_dga .W .Write (b [_ffg :_ffc ]);
if _gge !=nil {return _adc +_bg ,_gge ;};_adc +=_bg ;_ ,_gge =_dga .W .Write (_aag );if _gge !=nil {return _adc ,_gge ;};_adc +=3;for _bfgd :=_ffc +2;_bfgd < len (b )&&b [_bfgd ]!='>';_bfgd ++{_adc ++;_ffg =_bfgd +2;_ffc =_ffg ;};};};_faa ,_adf :=_dga .W .Write (b [_ffg :]);
return _faa +_adc ,_adf ;};

// AddFileFromStorage reads a file from internal storage and adds it at a given path to a zip file.
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromStorage (z *_a .Writer ,zipPath ,storagePath string )error {_fgc ,_acg :=z .Create (zipPath );if _acg !=nil {return _ac .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_acg );
};_abe ,_acg :=_bd .Open (storagePath );if _acg !=nil {return _ac .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_acg );};defer _abe .Close ();_ ,_acg =_ad .Copy (_fgc ,_abe );return _acg ;
};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_a .File ,dest interface{})error {_cf ,_dbc :=f .Open ();if _dbc !=nil {return _ac .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_dbc );};defer _cf .Close ();_fde :=_bf .NewDecoder (_cf );
if _ea :=_fde .Decode (dest );_ea !=nil {return _ac .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_ea );};if _ba ,_af :=dest .(*_d .Relationships );_af {for _fg ,_eg :=range _ba .Relationship {switch _eg .TypeAttr {case _db .OfficeDocumentTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .OfficeDocumentType ;
case _db .StylesTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .StylesType ;case _db .ThemeTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .ThemeType ;case _db .ControlTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .ControlType ;case _db .SettingsTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .SettingsType ;
case _db .ImageTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .ImageType ;case _db .CommentsTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .CommentsType ;case _db .ThumbnailTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .ThumbnailType ;case _db .DrawingTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .DrawingType ;
case _db .ChartTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .ChartType ;case _db .ExtendedPropertiesTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .ExtendedPropertiesType ;case _db .CustomXMLTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .CustomXMLType ;
case _db .WorksheetTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .WorksheetType ;case _db .SharedStringsTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .SharedStringsType ;case _db .TableTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .TableType ;
case _db .HeaderTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .HeaderType ;case _db .FooterTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .FooterType ;case _db .NumberingTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .NumberingType ;case _db .FontTableTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .FontTableType ;
case _db .WebSettingsTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .WebSettingsType ;case _db .FootNotesTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .FootNotesType ;case _db .EndNotesTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .EndNotesType ;
case _db .SlideTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .SlideType ;case _db .VMLDrawingTypeStrict :_ba .Relationship [_fg ].TypeAttr =_db .VMLDrawingType ;};};_g .Slice (_ba .Relationship ,func (_efd ,_gd int )bool {_eed :=_ba .Relationship [_efd ];
_baa :=_ba .Relationship [_gd ];return _e .NaturalCompare (_eed .IdAttr ,_baa .IdAttr );});};return nil ;};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_f map[string ]Target ;_ee map[*_d .Relationships ]string ;_gc []Target ;_be OnNewRelationshipFunc ;_fd map[string ]struct{};_fa map[string ]int ;};