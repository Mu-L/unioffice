//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_c "archive/zip";_gc "bytes";_cf "encoding/xml";_g "fmt";_ff "github.com/unidoc/unioffice";_d "github.com/unidoc/unioffice/algo";_ed "github.com/unidoc/unioffice/common/tempstorage";_aaf "github.com/unidoc/unioffice/schema/soo/pkg/relationships";
_bf "io";_bfg "path";_f "path/filepath";_aa "sort";_e "strings";_a "time";);

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_gbe :=_e .Split (path ,"\u002f");_efa :=_e .Join (_gbe [0:len (_gbe )-1],"\u002f");_dge :=_gbe [len (_gbe )-1];_efa +="\u002f_\u0072\u0065\u006c\u0073\u002f";_dge +="\u002e\u0072\u0065l\u0073";return _efa +_dge ;
};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_c .Writer ,filename string ,v interface{})error {_cda :=&_c .FileHeader {};_cda .Method =_c .Deflate ;_cda .Name =filename ;_cda .SetModTime (_a .Now ());_fbe ,_ec :=z .CreateHeader (_cda );if _ec !=nil {return _g .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_ec );
};_ ,_ec =_fbe .Write ([]byte (XMLHeader ));if _ec !=nil {return _g .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_ec );
};if _ec =_cf .NewEncoder (SelfClosingWriter {_fbe }).Encode (v );_ec !=nil {return _g .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_ec );};_ ,_ec =_fbe .Write (_fgaf );return _ec ;
};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_da map[string ]Target ;_ea map[*_aaf .Relationships ]string ;_ab []Target ;_aae OnNewRelationshipFunc ;_abg map[string ]struct{};_db map[string ]int ;};func (_gdg SelfClosingWriter )Write (b []byte )(int ,error ){_ga :=0;_efab :=0;
for _cde :=0;_cde < len (b )-2;_cde ++{if b [_cde ]=='>'&&b [_cde +1]=='<'&&b [_cde +2]=='/'{_dbf :=[]byte {};_bb :=_cde ;for _gdd :=_cde ;_gdd >=0;_gdd --{if b [_gdd ]==' '{_bb =_gdd ;}else if b [_gdd ]=='<'{_dbf =b [_gdd +1:_bb ];break ;};};_abe :=[]byte {};
for _bed :=_cde +3;_bed < len (b );_bed ++{if b [_bed ]=='>'{_abe =b [_cde +3:_bed ];break ;};};if !_gc .Equal (_dbf ,_abe ){continue ;};_fe ,_dbfa :=_gdg .W .Write (b [_ga :_cde ]);if _dbfa !=nil {return _efab +_fe ,_dbfa ;};_efab +=_fe ;_ ,_dbfa =_gdg .W .Write (_ace );
if _dbfa !=nil {return _efab ,_dbfa ;};_efab +=3;for _aab :=_cde +2;_aab < len (b )&&b [_aab ]!='>';_aab ++{_efab ++;_ga =_aab +2;_cde =_ga ;};};};_facb ,_fff :=_gdg .W .Write (b [_ga :]);return _facb +_efab ,_fff ;};func (_fa *DecodeMap )IndexFor (path string )int {return _fa ._db [path ]};
const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";


// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_c .File ,path string )(string ,error ){_fga ,_dfb :=_ed .TempFile (path ,"\u007a\u007a");if _dfb !=nil {return "",_dfb ;};defer _fga .Close ();_cab ,_dfb :=f .Open ();if _dfb !=nil {return "",_dfb ;};defer _cab .Close ();_ ,_dfb =_bf .Copy (_fga ,_cab );
if _dfb !=nil {return "",_dfb ;};return _fga .Name (),nil ;};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_bd *DecodeMap ,_dd ,_dc string ,_gb []*_c .File ,_dde *_aaf .Relationship ,_ad Target )error ;var _fgaf =[]byte {'\r','\n'};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _bf .Writer ;};

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_c .Writer ,zipPath string ,data []byte )error {_gfb ,_bdf :=z .Create (zipPath );if _bdf !=nil {return _g .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_bdf );
};_ ,_bdf =_bf .Copy (_gfb ,_gc .NewReader (data ));return _bdf ;};

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_c .Writer ,zipPath ,storagePath string )error {_ca ,_be :=z .Create (zipPath );if _be !=nil {return _g .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_be );
};_gf ,_be :=_ed .Open (storagePath );if _be !=nil {return _g .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_be );};defer _gf .Close ();_ ,_be =_bf .Copy (_ca ,_gf );return _be ;
};var _ace =[]byte {'/','>'};func MarshalXMLByTypeIndex (z *_c .Writer ,dt _ff .DocType ,typ string ,idx int ,v interface{})error {_edb :=_ff .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_edb ,v );};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_c .File ,dest interface{})error {_gcf ,_fd :=f .Open ();if _fd !=nil {return _g .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_fd );};defer _gcf .Close ();_gca :=_cf .NewDecoder (_gcf );
if _af :=_gca .Decode (dest );_af !=nil {return _g .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_af );};if _ffe ,_aac :=dest .(*_aaf .Relationships );_aac {for _bfgc ,_df :=range _ffe .Relationship {switch _df .TypeAttr {case _ff .OfficeDocumentTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .OfficeDocumentType ;
case _ff .StylesTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .StylesType ;case _ff .ThemeTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .ThemeType ;case _ff .ControlTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .ControlType ;case _ff .SettingsTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .SettingsType ;
case _ff .ImageTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .ImageType ;case _ff .CommentsTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .CommentsType ;case _ff .ThumbnailTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .ThumbnailType ;
case _ff .DrawingTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .DrawingType ;case _ff .ChartTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .ChartType ;case _ff .ExtendedPropertiesTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .ExtendedPropertiesType ;
case _ff .CustomXMLTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .CustomXMLType ;case _ff .WorksheetTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .WorksheetType ;case _ff .SharedStringsTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .SharedStringsType ;
case _ff .TableTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .TableType ;case _ff .HeaderTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .HeaderType ;case _ff .FooterTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .FooterType ;case _ff .NumberingTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .NumberingType ;
case _ff .FontTableTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .FontTableType ;case _ff .WebSettingsTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .WebSettingsType ;case _ff .FootNotesTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .FootNotesType ;
case _ff .EndNotesTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .EndNotesType ;case _ff .SlideTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .SlideType ;case _ff .VMLDrawingTypeStrict :_ffe .Relationship [_bfgc ].TypeAttr =_ff .VMLDrawingType ;
};};_aa .Slice (_ffe .Relationship ,func (_fdc ,_fg int )bool {_dbeg :=_ffe .Relationship [_fdc ];_afc :=_ffe .Relationship [_fg ];return _d .NaturalLess (_dbeg .IdAttr ,_afc .IdAttr );});};return nil ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_de *DecodeMap )Decode (files []*_c .File )error {_ddd :=1;for _ddd > 0{for len (_de ._ab )> 0{_fcd :=_de ._ab [0];_de ._ab =_de ._ab [1:];_dg :=_fcd .Ifc .(*_aaf .Relationships );for _ ,_cc :=range _dg .Relationship {_dac :=_de ._ea [_dg ];if _f .IsAbs (_cc .TargetAttr ){_cc .TargetAttr =_e .TrimPrefix (_cc .TargetAttr ,"\u002f");
if _e .HasPrefix (_cc .TargetAttr ,_dac ){_dac ="";};};_de ._aae (_de ,_dac +_cc .TargetAttr ,_cc .TypeAttr ,files ,_cc ,_fcd );};};for _cd ,_ba :=range files {if _ba ==nil {continue ;};if _dcf ,_gg :=_de ._da [_ba .Name ];_gg {delete (_de ._da ,_ba .Name );
if _ef :=Decode (_ba ,_dcf .Ifc );_ef !=nil {return _ef ;};files [_cd ]=nil ;if _dee ,_fb :=_dcf .Ifc .(*_aaf .Relationships );_fb {_de ._ab =append (_de ._ab ,_dcf );_eg ,_ :=_bfg .Split (_bfg .Clean (_ba .Name +"\u002f\u002e\u002e\u002f"));_de ._ea [_dee ]=_eg ;
_ddd ++;};};};_ddd --;};return nil ;};func MarshalXMLByType (z *_c .Writer ,dt _ff .DocType ,typ string ,v interface{})error {_eb :=_ff .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_eb ,v );};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_bg *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_bg ._aae =fn };func (_fc *DecodeMap )RecordIndex (path string ,idx int ){_fc ._db [path ]=idx };

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_gd *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _gd ._da ==nil {_gd ._da =make (map[string ]Target );_gd ._ea =make (map[*_aaf .Relationships ]string );_gd ._abg =make (map[string ]struct{});
_gd ._db =make (map[string ]int );};if _bfg .IsAbs (filePath ){filePath =_e .TrimPrefix (filePath ,"\u002f");};_adf :=_bfg .Clean (filePath );if _ ,_ada :=_gd ._abg [_adf ];_ada {return false ;};_gd ._abg [_adf ]=struct{}{};_gd ._da [_adf ]=Target {Path :_adf ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };
return true ;};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};