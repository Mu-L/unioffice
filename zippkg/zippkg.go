//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_d "archive/zip";_ef "bytes";_gd "encoding/xml";_c "fmt";_a "github.com/unidoc/unioffice";_eg "github.com/unidoc/unioffice/algo";_cbf "github.com/unidoc/unioffice/common/tempstorage";_df "github.com/unidoc/unioffice/schema/soo/pkg/relationships";
_ge "io";_efb "path";_f "sort";_cb "strings";_g "time";);

// Decode loops decoding targets registered with AddTarget and calling th
func (_fga *DecodeMap )Decode (files []*_d .File )error {_adg :=1;for _adg > 0{for len (_fga ._b )> 0{_ea :=_fga ._b [0];_fga ._b =_fga ._b [1:];_de :=_ea .Ifc .(*_df .Relationships );for _ ,_ac :=range _de .Relationship {_egf :=_fga ._gc [_de ];_ac .TargetAttr =_cb .TrimPrefix (_ac .TargetAttr ,"\u002f");
if _cb .IndexByte (_egf ,'/')> -1{_gda :=_egf [:_cb .IndexByte (_egf ,'/')+1];if _cb .HasPrefix (_ac .TargetAttr ,_gda ){_egf ="";};};if _cb .HasPrefix (_ac .TargetAttr ,_egf ){_egf ="";};_fga ._eee (_fga ,_egf +_ac .TargetAttr ,_ac .TypeAttr ,files ,_ac ,_ea );
};};for _dd ,_cf :=range files {if _cf ==nil {continue ;};if _dc ,_fb :=_fga ._da [_cf .Name ];_fb {delete (_fga ._da ,_cf .Name );if _fbe :=Decode (_cf ,_dc .Ifc );_fbe !=nil {return _fbe ;};files [_dd ]=nil ;if _fgb ,_cc :=_dc .Ifc .(*_df .Relationships );
_cc {_fga ._b =append (_fga ._b ,_dc );_ae ,_ :=_efb .Split (_efb .Clean (_cf .Name +"\u002f\u002e\u002e\u002f"));_fga ._gc [_fgb ]=_ae ;_adg ++;};};};_adg --;};return nil ;};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};func (_db SelfClosingWriter )Write (b []byte )(int ,error ){_ead :=0;
_be :=0;for _abf :=0;_abf < len (b )-2;_abf ++{if b [_abf ]=='>'&&b [_abf +1]=='<'&&b [_abf +2]=='/'{_fgd :=[]byte {};_gbg :=_abf ;for _acg :=_abf ;_acg >=0;_acg --{if b [_acg ]==' '{_gbg =_acg ;}else if b [_acg ]=='<'{_fgd =b [_acg +1:_gbg ];break ;};
};_edf :=[]byte {};for _ged :=_abf +3;_ged < len (b );_ged ++{if b [_ged ]=='>'{_edf =b [_abf +3:_ged ];break ;};};if !_ef .Equal (_fgd ,_edf ){continue ;};_bgg ,_ga :=_db .W .Write (b [_ead :_abf ]);if _ga !=nil {return _be +_bgg ,_ga ;};_be +=_bgg ;_ ,_ga =_db .W .Write (_eb );
if _ga !=nil {return _be ,_ga ;};_be +=3;for _gcf :=_abf +2;_gcf < len (b )&&b [_gcf ]!='>';_gcf ++{_be ++;_ead =_gcf +2;_abf =_ead ;};};};_dg ,_dfc :=_db .W .Write (b [_ead :]);return _dg +_be ,_dfc ;};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";


// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_d .Writer ,zipPath string ,data []byte )error {_ba ,_acd :=z .Create (zipPath );if _acd !=nil {return _c .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_acd );
};_ ,_acd =_ge .Copy (_ba ,_ef .NewReader (data ));return _acd ;};var _eb =[]byte {'/','>'};func MarshalXMLByType (z *_d .Writer ,dt _a .DocType ,typ string ,v interface{})error {_fbd :=_a .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_fbd ,v );
};func (_aaa *DecodeMap )RecordIndex (path string ,idx int ){_aaa ._bd [path ]=idx };

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_d .File ,path string )(string ,error ){_bfa ,_aadd :=_cbf .TempFile (path ,"\u007a\u007a");if _aadd !=nil {return "",_aadd ;};defer _bfa .Close ();_ade ,_aadd :=f .Open ();if _aadd !=nil {return "",_aadd ;};defer _ade .Close ();
_ ,_aadd =_ge .Copy (_bfa ,_ade );if _aadd !=nil {return "",_aadd ;};return _bfa .Name (),nil ;};func (_ad *DecodeMap )IndexFor (path string )int {return _ad ._bd [path ]};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_ce :=_cb .Split (path ,"\u002f");_fa :=_cb .Join (_ce [0:len (_ce )-1],"\u002f");_bg :=_ce [len (_ce )-1];_fa +="\u002f_\u0072\u0065\u006c\u0073\u002f";_bg +="\u002e\u0072\u0065l\u0073";return _fa +_bg ;};var _fag =[]byte {'\r','\n'};


// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_fe *DecodeMap ,_dfb ,_ff string ,_ee []*_d .File ,_af *_df .Relationship ,_cd Target )error ;

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_d .Writer ,zipPath ,storagePath string )error {_fd ,_daf :=z .Create (zipPath );if _daf !=nil {return _c .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_daf );
};_aee ,_daf :=_cbf .Open (storagePath );if _daf !=nil {return _c .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_daf );};defer _aee .Close ();_ ,_daf =_ge .Copy (_fd ,_aee );return _daf ;
};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_d .Writer ,filename string ,v interface{})error {_efdf :=&_d .FileHeader {};_efdf .Method =_d .Deflate ;_efdf .Name =filename ;_efdf .SetModTime (_g .Now ());_cfc ,_ece :=z .CreateHeader (_efdf );if _ece !=nil {return _c .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_ece );
};_ ,_ece =_cfc .Write ([]byte (XMLHeader ));if _ece !=nil {return _c .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_ece );
};if _ece =_gd .NewEncoder (SelfClosingWriter {_cfc }).Encode (v );_ece !=nil {return _c .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_ece );};_ ,_ece =_cfc .Write (_fag );return _ece ;
};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_ed *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_ed ._eee =fn };

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_ab *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _ab ._da ==nil {_ab ._da =make (map[string ]Target );_ab ._gc =make (map[*_df .Relationships ]string );_ab ._aa =make (map[string ]struct{});_ab ._bd =make (map[string ]int );
};if _efb .IsAbs (filePath ){filePath =_cb .TrimPrefix (filePath ,"\u002f");};_fg :=_efb .Clean (filePath );if _ ,_gea :=_ab ._aa [_fg ];_gea {return false ;};_ab ._aa [_fg ]=struct{}{};_ab ._da [_fg ]=Target {Path :_fg ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };
return true ;};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_da map[string ]Target ;_gc map[*_df .Relationships ]string ;_b []Target ;_eee OnNewRelationshipFunc ;_aa map[string ]struct{};_bd map[string ]int ;};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_d .File ,dest interface{})error {_fc ,_dce :=f .Open ();if _dce !=nil {return _c .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_dce );};defer _fc .Close ();_cec :=_gd .NewDecoder (_fc );
if _ec :=_cec .Decode (dest );_ec !=nil {return _c .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_ec );};if _ag ,_fed :=dest .(*_df .Relationships );_fed {for _efd ,_aad :=range _ag .Relationship {switch _aad .TypeAttr {case _a .OfficeDocumentTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .OfficeDocumentType ;
case _a .StylesTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .StylesType ;case _a .ThemeTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .ThemeType ;case _a .ControlTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .ControlType ;case _a .SettingsTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .SettingsType ;
case _a .ImageTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .ImageType ;case _a .CommentsTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .CommentsType ;case _a .ThumbnailTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .ThumbnailType ;case _a .DrawingTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .DrawingType ;
case _a .ChartTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .ChartType ;case _a .ExtendedPropertiesTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .ExtendedPropertiesType ;case _a .CustomXMLTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .CustomXMLType ;
case _a .WorksheetTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .WorksheetType ;case _a .SharedStringsTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .SharedStringsType ;case _a .TableTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .TableType ;
case _a .HeaderTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .HeaderType ;case _a .FooterTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .FooterType ;case _a .NumberingTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .NumberingType ;case _a .FontTableTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .FontTableType ;
case _a .WebSettingsTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .WebSettingsType ;case _a .FootNotesTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .FootNotesType ;case _a .EndNotesTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .EndNotesType ;
case _a .SlideTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .SlideType ;case _a .VMLDrawingTypeStrict :_ag .Relationship [_efd ].TypeAttr =_a .VMLDrawingType ;};};_f .Slice (_ag .Relationship ,func (_fbc ,_bf int )bool {_eab :=_ag .Relationship [_fbc ];
_gbc :=_ag .Relationship [_bf ];return _eg .NaturalLess (_eab .IdAttr ,_gbc .IdAttr );});};return nil ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _ge .Writer ;};func MarshalXMLByTypeIndex (z *_d .Writer ,dt _a .DocType ,typ string ,idx int ,v interface{})error {_aca :=_a .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_aca ,v );};