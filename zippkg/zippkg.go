//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_f "archive/zip";_cc "bytes";_gf "encoding/xml";_g "fmt";_ba "github.com/unidoc/unioffice/v2";_ga "github.com/unidoc/unioffice/v2/common/tempstorage";_b "github.com/unidoc/unioffice/v2/internal/sort";_ccb "github.com/unidoc/unioffice/v2/schema/soo/pkg/relationships";
_dd "io";_ca "path";_a "sort";_fb "strings";_c "time";);

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_f .Writer ,filename string ,v interface{})error {_bca :=&_f .FileHeader {};_bca .Method =_f .Deflate ;_bca .Name =filename ;_bca .SetModTime (_c .Now ());_ffg ,_eaa :=z .CreateHeader (_bca );if _eaa !=nil {return _g .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_eaa );
};_ ,_eaa =_ffg .Write ([]byte (XMLHeader ));if _eaa !=nil {return _g .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_eaa );
};if _eaa =_gf .NewEncoder (SelfClosingWriter {_ffg }).Encode (v );_eaa !=nil {return _g .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_eaa );};_ ,_eaa =_ffg .Write (_dab );return _eaa ;
};

// AddFileFromStorage reads a file from internal storage and adds it at a given path to a zip file.
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromStorage (z *_f .Writer ,zipPath ,storagePath string )error {_fbg ,_de :=z .Create (zipPath );if _de !=nil {return _g .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_de );
};_cbc ,_de :=_ga .Open (storagePath );if _de !=nil {return _g .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_de );};defer _cbc .Close ();_ ,_de =_dd .Copy (_fbg ,_cbc );return _de ;
};func (_ge *DecodeMap )IndexFor (path string )int {return _ge ._ac [path ]};

// Decode loops decoding targets registered with AddTarget and calling th
func (_bab *DecodeMap )Decode (files []*_f .File )error {_gee :=1;for _gee > 0{for len (_bab ._ef )> 0{_fge :=_bab ._ef [0];_bab ._ef =_bab ._ef [1:];_fc :=_fge .Ifc .(*_ccb .Relationships );for _ ,_dc :=range _fc .Relationship {_bc :=_bab ._fa [_fc ];
_ee :=_fb .TrimPrefix (_dc .TargetAttr ,"\u002f");if _fb .HasPrefix (_dc .TargetAttr ,"\u002f"){_ =_bab ._gfa (_bab ,_ee ,_dc .TypeAttr ,files ,_dc ,_fge );}else {if _fb .IndexByte (_bc ,'/')> -1{_af :=_bc [:_fb .IndexByte (_bc ,'/')+1];if _fb .HasPrefix (_ee ,_af ){_bc ="";
};};if _fb .HasPrefix (_ee ,_bc ){_bc ="";};_ =_bab ._gfa (_bab ,_bc +_ee ,_dc .TypeAttr ,files ,_dc ,_fge );};};};for _gc ,_bf :=range files {if _bf ==nil {continue ;};if _ed ,_bbb :=_bab ._ec [_bf .Name ];_bbb {delete (_bab ._ec ,_bf .Name );if _abf :=Decode (_bf ,_ed .Ifc );
_abf !=nil {return _abf ;};files [_gc ]=nil ;if _eea ,_eb :=_ed .Ifc .(*_ccb .Relationships );_eb {_bab ._ef =append (_bab ._ef ,_ed );_acc ,_ :=_ca .Split (_ca .Clean (_bf .Name +"\u002f\u002e\u002e\u002f"));_bab ._fa [_eea ]=_acc ;_gee ++;};};};_gee --;
};return nil ;};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_fg *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_fg ._gfa =fn };func MarshalXMLByTypeIndex (z *_f .Writer ,dt _ba .DocType ,typ string ,idx int ,v interface{})error {_eed :=_ba .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_eed ,v );
};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _dd .Writer ;};func MarshalXMLByType (z *_f .Writer ,dt _ba .DocType ,typ string ,v interface{})error {_gd :=_ba .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_gd ,v );};

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_f .File ,path string )(string ,error ){_cgf ,_dad :=_ga .TempFile (path ,"\u007a\u007a");if _dad !=nil {return "",_dad ;};defer _cgf .Close ();_efeg ,_dad :=f .Open ();if _dad !=nil {return "",_dad ;};defer _efeg .Close ();_ ,_dad =_dd .Copy (_cgf ,_efeg );
if _dad !=nil {return "",_dad ;};return _cgf .Name (),nil ;};var _dab =[]byte {'\r','\n'};var _ffd =[]byte {'/','>'};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_e *DecodeMap ,_cce ,_da string ,_bad []*_f .File ,_bade *_ccb .Relationship ,_bb Target )error ;

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_ec map[string ]Target ;_fa map[*_ccb .Relationships ]string ;_ef []Target ;_gfa OnNewRelationshipFunc ;_bd map[string ]struct{};_ac map[string ]int ;};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};func (_acb *DecodeMap )RecordIndex (path string ,idx int ){_acb ._ac [path ]=idx };


// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_f .Writer ,zipPath string ,data []byte )error {_ecg ,_gcd :=z .Create (zipPath );if _gcd !=nil {return _g .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_gcd );
};_ ,_gcd =_dd .Copy (_ecg ,_cc .NewReader (data ));return _gcd ;};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_cg :=_fb .Split (path ,"\u002f");_cb :=_fb .Join (_cg [0:len (_cg )-1],"\u002f");_geef :=_cg [len (_cg )-1];_cb +="\u002f_\u0072\u0065\u006c\u0073\u002f";_geef +="\u002e\u0072\u0065l\u0073";return _cb +_geef ;
};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_f .File ,dest interface{})error {_efe ,_bdf :=f .Open ();if _bdf !=nil {return _g .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_bdf );};defer _efe .Close ();_cf :=_gf .NewDecoder (_efe );
if _ace :=_cf .Decode (dest );_ace !=nil {return _g .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_ace );};if _fbe ,_fd :=dest .(*_ccb .Relationships );_fd {for _db ,_ad :=range _fbe .Relationship {switch _ad .TypeAttr {case _ba .OfficeDocumentTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .OfficeDocumentType ;
case _ba .StylesTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .StylesType ;case _ba .ThemeTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .ThemeType ;case _ba .ControlTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .ControlType ;case _ba .SettingsTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .SettingsType ;
case _ba .ImageTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .ImageType ;case _ba .CommentsTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .CommentsType ;case _ba .ThumbnailTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .ThumbnailType ;case _ba .DrawingTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .DrawingType ;
case _ba .ChartTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .ChartType ;case _ba .ExtendedPropertiesTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .ExtendedPropertiesType ;case _ba .CustomXMLTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .CustomXMLType ;
case _ba .WorksheetTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .WorksheetType ;case _ba .SharedStringsTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .SharedStringsType ;case _ba .TableTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .TableType ;
case _ba .HeaderTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .HeaderType ;case _ba .FooterTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .FooterType ;case _ba .NumberingTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .NumberingType ;case _ba .FontTableTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .FontTableType ;
case _ba .WebSettingsTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .WebSettingsType ;case _ba .FootNotesTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .FootNotesType ;case _ba .EndNotesTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .EndNotesType ;
case _ba .SlideTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .SlideType ;case _ba .VMLDrawingTypeStrict :_fbe .Relationship [_db ].TypeAttr =_ba .VMLDrawingType ;};};_a .Slice (_fbe .Relationship ,func (_bcc ,_edg int )bool {_ea :=_fbe .Relationship [_bcc ];
_ff :=_fbe .Relationship [_edg ];return _b .NaturalCompare (_ea .IdAttr ,_ff .IdAttr );});};return nil ;};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_gag *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _gag ._ec ==nil {_gag ._ec =make (map[string ]Target );_gag ._fa =make (map[*_ccb .Relationships ]string );_gag ._bd =make (map[string ]struct{});
_gag ._ac =make (map[string ]int );};if _ca .IsAbs (filePath ){filePath =_fb .TrimPrefix (filePath ,"\u002f");};_df :=_ca .Clean (filePath );if _ ,_ab :=_gag ._bd [_df ];_ab {return false ;};_gag ._bd [_df ]=struct{}{};_gag ._ec [_df ]=Target {Path :_df ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };
return true ;};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";
func (_bda SelfClosingWriter )Write (b []byte )(int ,error ){_gg :=0;_baf :=0;for _ffa :=0;_ffa < len (b )-2;_ffa ++{if b [_ffa ]=='>'&&b [_ffa +1]=='<'&&b [_ffa +2]=='/'{_ede :=[]byte {};_bfc :=_ffa ;for _bdd :=_ffa ;_bdd >=0;_bdd --{if b [_bdd ]==' '{_bfc =_bdd ;
}else if b [_bdd ]=='<'{_ede =b [_bdd +1:_bfc ];break ;};};_fba :=[]byte {};for _bfb :=_ffa +3;_bfb < len (b );_bfb ++{if b [_bfb ]=='>'{_fba =b [_ffa +3:_bfb ];break ;};};if !_cc .Equal (_ede ,_fba ){continue ;};_cgfg ,_eae :=_bda .W .Write (b [_gg :_ffa ]);
if _eae !=nil {return _baf +_cgfg ,_eae ;};_baf +=_cgfg ;_ ,_eae =_bda .W .Write (_ffd );if _eae !=nil {return _baf ,_eae ;};_baf +=3;for _cd :=_ffa +2;_cd < len (b )&&b [_cd ]!='>';_cd ++{_baf ++;_gg =_cd +2;_ffa =_gg ;};};};_ae ,_dcg :=_bda .W .Write (b [_gg :]);
return _ae +_baf ,_dcg ;};